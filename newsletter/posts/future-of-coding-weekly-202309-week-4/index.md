<!--
.. title: Future of Coding Weekly 2023/09 Week 4
.. slug: future-of-coding-weekly-202309-week-4
.. date: 2023-09-25 00:08:18 UTC+02:00
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text
-->

‚òû Computation as Philology üé≠ The Meaning of Live üìñ Programming Interactive Fiction üßÆ Logic is Algebra

# Two Minute Week

üé• [Fibonacci implemented in a visual flow](https://youtu.be/hO_emZq0dEI) via [Maikel van de Lisdonk](https://www.devhelpr.com/)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/two-minute-week.html#2023-09-24T10:50:13.845Z)

![Youtube Thumbnail](https://img.youtube.com/vi/hO_emZq0dEI/hqdefault.jpg)

Hi, this week I finally managed to make a much smaller version of the fibonacci algorithm in a visual flow : [youtu.be/hO_emZq0dEI](https://youtu.be/hO_emZq0dEI)



What helped, is to be able to define variables inside a flow and use them in an expression, even if the variables are defined in nodes that comes after the expression node in where they are used. In this case it's an array variable node that is needed.



Something that I currently am trying to accomplish is creating visual flows that are smaller and therefore hopefully clearer and more helpful in explaining algorithms.



In my previous visual implementations of the Fibonacci algorithm much more nodes and connections where needed not helping in explaning the algortihm (in the thread I have shared a previous implementation). 



I think this new approach helps and I'll explore this further.



** update ** after uploading the video I got another idea that helps showing the invisible connections between the nodes: when the array/list-node elements are read or an item is added.. a small rectangle around the element now flashes üòé .. so I've re-uploaded the video

# Our Work

‚òû [ Computation as Philology](https://arbesman.substack.com/p/computation-as-philology) via **Sam Arbesman**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-18T01:30:51.843Z)

Folks here might get a kick out of this essay I wrote: [arbesman.substack.com/p/computation-as-philology](https://arbesman.substack.com/p/computation-as-philology)

>Logismics and the wide-ranging impacts of computing

üé• [üê¢ UI Combinators all the Way Down](https://www.youtube.com/watch?v=Ha3EajlWbDc) via [Mariano Guerra](https://twitter.com/warianoguerra)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-19T15:00:00.438Z)

![Youtube Thumbnail](https://img.youtube.com/vi/Ha3EajlWbDc/hqdefault.jpg)

üê¢ UI Combinators all the Way Down



üõ† UI Combinator builder to create & preview components

‚è™ Undo history implementation

‚öñÔ∏è [An experiment using a Rules as Code encoding in Blawx to create a converational tool that can accurately and explainably answer questions about that law](https://github.com/PHACDataHub/privacy_rac_demo) via [Jason Morris](https://twitter.com/RoundTableLaw)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-19T20:12:28.622Z)

The REAMDE.md below tells the story of how I used the user-friendly declarative logic tool I built over the last couple of years to encode a small portion of Canada's Privacy Act, and then had that code used as a tool by a langchain agent. Very interested in anyone's thoughts on both content and form. It's not as easy as it ought to be to talk publicly about what you are doing inside GoC, but evidently documentation for an open source software repository is something of an exception to the usual rule.

ü™£ [Fractal bucket](https://todepond.substack.com/p/todepond-pondcast-fractal-bucket) via [Lu Wilson](https://twitter.com/TodePond)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-19T22:31:08.230Z)

My plan for a new visual programming language, currently named [Fractal bucket](https://todepond.substack.com/p/todepond-pondcast-fractal-bucket)


üìù [Building machine learning products: lessons from Papercup's product team - Papercup](https://www.papercup.com/blog/machine-learning-product-management) via **Kilian Butler**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-20T21:12:56.283Z)

This isn‚Äôt as interesting as what most people here are doing but I wrote a blog post about building products with machine learning at their core.



I‚Äôve been working on ML focused products for the last 4 years and have learned a lot. Hopefully it may be useful to someone out there üòá Always happy to chat ML products if anyone‚Äôs interested 




>How to utillize machine learning capabilities to develop valuable products with real-world use cases.

üìù [The Meaning of Live: From Art Without Audience to Programs Without Users](https://zenodo.org/record/7843567) via **Alex McLean**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/share-your-work.html#2023-09-23T09:42:40.838Z)

The Meaning of Live: From Art Without Audience to Programs Without Users with Julian Rohrhuber and Renate Weiser


It includes critique of what we saw as the common approach to 'liveness' in future of coding community. We explain ways in which live debugging is the opposite of live coding.

>The concept of an `art without audience' has informed live coding since its beginnings. Live Coding concentrates on collective work and questions the division between producers and consumers. This understanding of art has enabled a parallel strategy in the understanding of programming: just as an audience is not necessary for art, a user isn't necessary for programming. In the same sense as we question the separation between developer and user, we question the juxtaposition of artist and audience. This gives us occasion to recall some aspects of live coding which we have always found central to this practice: the displacement of the relation between programmers and programs, and the emancipatory potential of public thought.

# Reading Together

üßÆ [Logic is Algebra](https://arxiv.org/abs/2304.00358) via **Nilesh Trivedi**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/reading-together.html#2023-09-24T05:47:05.714Z)

"Logic is Algebra" paper suggests Abstraction Logic as foundation of mathematics

It's from the creator of Practal proof language: [practal.com](https://practal.com/)

>Logic really is just algebra, given one uses the right kind of algebra, and the right kind of logic. The right kind of algebra is abstraction algebra, and the right kind of logic is abstraction logic.

# Thinking Together

üí¨ [Paul Tarvydas](https://guitarvydas.github.io/2021/09/23/Manifesto.html)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-19T01:24:41.821Z)

[Ivan Reese](http://ivanish.ca/) and **@Alex McLean** mentioned ‚Äú...hand drawn programming environments...‚Äú.  The first thing that I think of when I hear this is ‚Äúwhiteboards‚Äù.  What are the dimensions involved in whiteboards? x/y/t.  T goes forwards (e.g. adding new details by drawing them in over time) and backwards (erasing parts of drawings).  Iteration. Scrubbing.

üí¨ **Guyren Howe**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-19T17:43:47.272Z)

Why on earth, in this era of many-gigabyte machines, don‚Äôt all programming languages have a time-travel mode for debugging?

üìñ [Inform](https://ganelson.github.io/inform-website/) via **Qqwy / Marten**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-20T15:49:42.846Z)

Hi all! New here, but latest episode of Future of Coding (‚Äò _66 - a Small Matter of Programming_ ‚Äô) made me think of something closely related.

Part of the discussion was about using formal vs informal language to communicate with a computer, and whether ‚Äòend-user programming‚Äô would be feasible using those methods or not.



One tool which came to mind is ‚Äò[Inform](https://ganelson.github.io/inform-website/)‚Äô. It is a tool (mainly a programming language, though it also ships with its own IDE-like thing) to write text adventure games.

But rather than being geared towards  _programmers_ , it is geared towards  _writers._ 



An example of a simple program:






```
The Cabin is a room.  "The front of the small cabin is entirely occupied with navigational instruments, a radar display, and radios for calling back to shore. Along each side runs a bench with faded blue vinyl cushions, which can be lifted to reveal the storage space underneath. A glass case against the wall contains several fishing rods.

Scratched windows offer a view of the surrounding bay, and there is a door south to the deck. A sign taped to one wall announces the menu of tours offered by the Yakutat Charter Boat Company."

The Cabin contains a glass case. In the glass case is a collection of fishing rods.

The case is closed, transparent, and openable.

The bench is in the cabin. On the bench are some blue vinyl cushions.

The bench is enterable.

The Beach is a room. "A beautiful beach where the sunset can be seen. Some seagulls are flying overhead."

The Beach is south of the Cabin.
```







Some points for consideration are:




* Where do you think a language like Inform fall on the ‚Äòformal‚Äô vs ‚Äòinformal‚Äô spectrum?
* Inform is perhaps the most widely used tool to create text adventures with today. Could this be considered a success story where non-programmer end users were able to build something through ‚Äòprogramming‚Äô?



üìù [Attempto](http://attempto.ifi.uzh.ch/site/) via [Konrad Hinsen](https://khinsen.net/)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-21T07:06:16.600Z)


> Where do you think a language like Inform fall on the ‚Äòformal‚Äô vs ‚Äòinformal‚Äô spectrum?



Preliminary question; what exactly changes from one end to the other of that spectrum? My current answer is: how much of the total information conveyed is formal. I'd love to hear from others who have thought about this question, or know about work on this topic in the literature.



To illustrate my definition, a few examples:




* Machine code is near 100% formal.
* Standard programming languages are mostly formal, the informal part being the variable names, which convey context-dependent information to humans but nothing to the compiler/interpreter.
* Markup languages (HTML, Markdown, ...) are mostly informal, because the formalized information is not the most relevant part. You could strip it away and the rest would still fulfill its purpose.



There are lots of subtleties I am glossing over. Example: A Python program saying  `print("...")`  with a 100 KB string is basically just decorated informal prose. My definition applies to typical or intended use, not possible extremes.



Back to Inform: I cannot judge from the example which information is extracted from the code by formal processing. Is this a controlled natural language, like [Attempto](http://attempto.ifi.uzh.ch/site/) ? Or plain English from which some engine extracts isolated keywords?

üìñüé• [NarraScope 2020: Inform 7 Update](https://www.youtube.com/watch?v=ZL7HjuFyKeE) via **Alex McLean**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-21T08:22:15.714Z)

![Youtube Thumbnail](https://img.youtube.com/vi/ZL7HjuFyKeE/hqdefault.jpg)

On another inform tip, I really enjoyed this talk from Graham Nelson, with lots of take-home ideas for making a learnable language that's engaging and open to change 

üí¨ **Alex McLean**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-22T08:35:39.666Z)

One thing I've noticed working with Realtalk is that the natural language style tends to have a trade-off in making things easy to read, but a bit harder to write.. You can read them like English sentences but if you try to write them that way you probably will get a connective wrong or some other subtle thing and it won't parse or won't communicate with something else.

More generally I think it's easy to conflate readability and writeability, they're obviously related but still quite different properties.

Actually for a lot of things writeability is far more important than readability. E.g. when live-coding music you don't necessarily have to read/understand exactly what code is doing because you can understand the code by experiencing the results while writing, rather than reading the code.

üí¨ **Tim Lavoie**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-23T00:35:58.044Z)

I had a couple thoughts bouncing around, listening to, 66 ‚Ä¢ A Small Matter of Programming by Bonnie Nardi.




* Jimmy mentioned writing browser extensions. Just recently, there was a thread (probably on HN), with discussion of people sharing filter snippets for uBlock Origin. It turns out that besides simply filtering links and so on, the snippets are also being used to modify styles and visibility for all sorts of things that people find needing change on various web sites. This, along with the whole "view source" era discussion, suggests that it hasn't gone away. Browser extensions such as uBlock Origin also include a colour-style picker for identifying the elements on the page that you're interested in. So in a way, it is very much enabling a simple sort of end-user programming, right in the browser. You won't see the back-end, but can manipulate the DOM that is very much on the client.
* Regarding the discussion in the episode on early education, teaching kids programming, I was thinking along the lines of teaching the means to observe. "View source" is one such part, along with browser dev-tools. Perhaps most people won't be interested in modifying the programs they use, but teaching the idea that introspection, via software-as-microscope, is possible. Too much of our computing is directed to being strictly consumption, that I suspect few people will even think of being able to look at the innards. Think Wireshark for networks, source-level debuggers where you have source, or binary analysis tools where you don't. (Probably related, I got a Snapshot cartridge for the C64 as a youth, and was amazed at being able to capture the entire state of a program, fiddle with it, and save it as an executable to resume.)

üé• [I'm Re-Imagining the Command Line Interpreter](https://www.youtube.com/watch?v=NxsaHxON350) via [Peter Saxton](https://twitter.com/CrowdHailer)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/thinking-together.html#2023-09-24T20:45:40.859Z) and [üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-23T10:43:14.653Z)

![Youtube Thumbnail](https://img.youtube.com/vi/NxsaHxON350/hqdefault.jpg)

This was an interesting video. Not sure what the state of the project is, but it got me thinking along similar lines. 


# Content

üéôÔ∏è [‚ÄéHappy Path Programming: #82 The Future of Programming](https://podcasts.apple.com/us/podcast/82-the-future-of-programming/id1531666706?i=1000619939421) via **Greg Bylenok**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-18T13:39:49.092Z)

This podcast may be of interest to this group: "The Future of Programming" by Bruce Eckel and James Ward. What does the future of programming look like? In their opinion:




* static typing over dynamic typing
* IDE support is a must
* the happy path is the resource efficient path
* transparent concurrency
* transparently distributed systems
* embedded DSLs


üìù [How the Mac didn‚Äôt bring programming to the people](https://eclecticlight.co/2023/09/16/how-the-mac-didnt-bring-programming-to-the-people/) via [Mariano Guerra](https://twitter.com/warianoguerra)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-19T06:56:29.077Z)


>  Macs have brought a great deal to us over the years: desktop publishing, design, image editing and processing, multimedia, and more. One of the few fields where they have failed is programming, despite many attempts. Here I look back at some of those opportunities we missed

>HyperTalk, AppleScript, Prograph, Automator, Swift Playgrounds and Shortcuts ‚Äì all wonderful tools in their day, but none has brought coding to the crowd.

üìù [Notes on craft and interaction design](http://jonas.lowgren.info/ncixd.htm) via **Alex McLean**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-23T19:33:41.471Z)

Loving this annotated bibliography of craft and interaction design

üìù [It's okay to Make Something Nobody Wants](https://zhangluyao.com/blog/make-something-nobody-wants/) via [Jean-Louis Villecroze](https://twitter.com/CocoaGeek)

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-23T22:24:37.379Z)

Saw this article on hackerNews ‚Ä¶ thought it was pertinent to me, albeit oddly phrased at time but the author is likely not a native English speaker (like myself) so that‚Äôs to be expected üôÇ


>Products seem to be made for users, but I think this might be an illusion; they are more like a medium for self-expression.
Different expressions, conceived by various minds, undergo a form of natural selection, with the surviving expression being the one that resonates most with users.
I mean, the process unfolds like this: you create something not because ‚ÄúI think they might need this,‚Äù but because ‚ÄúI find this so fucking interesting.

üìù [Ashley Blewer](https://ashleyblewer.com/) via **Jonas**

[üßµ conversation](https://history.futureofcoding.org/history/weekly/2023/09/W4/linking-together.html#2023-09-24T07:59:49.834Z)

Hey! So [Ashley Blewer](https://ashleyblewer.com/) has created this [wonderful syllabus](https://bits.ashleyblewer.com/halt-and-catch-fire-syllabus/) to go along with the TV show "Halt and Catch Fire" (2014-2017), "a fictional narrative about people working in tech during the 1980s-1990s." The syllabus features readings on the history of technology, computers, programming etc. as well as recommended RFCs and emulators of old systems to take a look at to provide material for discussions about a set of episodes.



I wanted to watch the show for a long time now, and since I really enjoy the A Pattern Language book club that was linked to here a few months ago, I thought it might be a nice idea to create a watch club to go through the series together‚Äìthe way Ashley intended!



I created a Discord for this purpose. Right now, no date has been set for the first session, as I want to give people some time to show up first. I'll announce the schedule soon. If all this sounds like something you might be interested in, please join me in this adventure!



[Here's the link](https://discord.gg/T3BDJN6AXz)

