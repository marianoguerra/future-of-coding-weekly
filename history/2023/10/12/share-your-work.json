[
    {
        "client_msg_id": "2d273a99-c108-40ed-91dd-1cfb48f11b03",
        "type": "message",
        "text": "<https://m-ld.org/|m-ld> is a component for sharing live information peer-to-peer. (Lots of materials at the link, and click the big green button to <https://js.m-ld.org/|find code playgrounds>.)\n\nIt's intended to allow programs to be written \"local-first\", having a reactive local model that is concurrently editable from multiple remote locations, with a guarantee of eventual consistency. So, you more-or-less write your code as if the data is 100% local, embedding m-ld as a library, and magically find that other remote participants can read and write the data too (subject to security!).\n\nThere are two main use-cases we're targeting \u2013 client apps, like office tools, supporting collaborative editing (GDocs-style); and microservices sharing information like configuration or master data. In both cases, you don't need a (extra) server for the data (though you do need a way to pass messages, for example a pubsub).\n\nI've been working on this for a while so there's a million things I could ramble on about, but I'm curious to know if the above pricks up anyone's ears. Do those use-cases sound, well, useful? Does my description make you want to know more, or, ho-hum? Any feedback is welcome; will return with recent focus later! Many thanks",
        "user": "U05V95DDSLA",
        "ts": "1697101718.309229",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8yhfu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://m-ld.org/",
                                "text": "m-ld"
                            },
                            {
                                "type": "text",
                                "text": " is a component for sharing live information peer-to-peer. (Lots of materials at the link, and click the big green button to "
                            },
                            {
                                "type": "link",
                                "url": "https://js.m-ld.org/",
                                "text": "find code playgrounds"
                            },
                            {
                                "type": "text",
                                "text": ".)\n\nIt's intended to allow programs to be written \"local-first\", having a reactive local model that is concurrently editable from multiple remote locations, with a guarantee of eventual consistency. So, you more-or-less write your code as if the data is 100% local, embedding m-ld as a library, and magically find that other remote participants can read and write the data too (subject to security!).\n\nThere are two main use-cases we're targeting \u2013 client apps, like office tools, supporting collaborative editing (GDocs-style); and microservices sharing information like configuration or master data. In both cases, you don't need a (extra) server for the data (though you do need a way to pass messages, for example a pubsub).\n\nI've been working on this for a while so there's a million things I could ramble on about, but I'm curious to know if the above pricks up anyone's ears. Do those use-cases sound, well, useful? Does my description make you want to know more, or, ho-hum? Any feedback is welcome; will return with recent focus later! Many thanks"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "reply_count": 7,
        "reply_users_count": 3,
        "latest_reply": "1697137857.478559",
        "reply_users": [
            "UE6EFEPTQ",
            "U05V95DDSLA",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "URKQXRCAC",
                    "U0296ACR13M"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d13c7daf-1ac5-4b80-b245-eb17ee9f8824",
        "type": "message",
        "text": "CRDT-based?\n\nAnd how is it different from SyncThing (that kind of question people ask which is SOOO annoying cos it usually means they didn't bother to read or understand what your offering is!)",
        "user": "UE6EFEPTQ",
        "ts": "1697113547.543659",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nRqxa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "CRDT-based?\n\nAnd how is it different from SyncThing (that kind of question people ask which is SOOO annoying cos it usually means they didn't bother to read or understand what your offering is!)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1697113586.000000"
        },
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "27d2a0b5-e7e8-4280-bad8-ae11fef148d6",
        "type": "message",
        "text": "Yes, CRDT-based.\n\nHeh no worries, all q's are good, shows me what I need to lead with in the docs :grinning:. So SyncThing is <https://forum.syncthing.net/t/how-does-conflict-resolution-work/15113/4|\"not content-aware\"> \u2013 its atoms are opaque binary files. m-ld's atoms are numbers, strings, booleans etc. that live in a graph. (The graph could locally be represented as an object model, or structs with pointers, or whatever.) So what you're sharing is the application-specific data model, which might often correspond, when serialised, to the _contents_ of a file.",
        "user": "U05V95DDSLA",
        "ts": "1697115197.153899",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pgajC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, CRDT-based.\n\nHeh no worries, all q's are good, shows me what I need to lead with in the docs "
                            },
                            {
                                "type": "emoji",
                                "name": "grinning",
                                "unicode": "1f600"
                            },
                            {
                                "type": "text",
                                "text": ". So SyncThing is "
                            },
                            {
                                "type": "link",
                                "url": "https://forum.syncthing.net/t/how-does-conflict-resolution-work/15113/4",
                                "text": "\"not content-aware\""
                            },
                            {
                                "type": "text",
                                "text": " \u2013 its atoms are opaque binary files. m-ld's atoms are numbers, strings, booleans etc. that live in a graph. (The graph could locally be represented as an object model, or structs with pointers, or whatever.) So what you're sharing is the application-specific data model, which might often correspond, when serialised, to the "
                            },
                            {
                                "type": "text",
                                "text": "contents",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of a file."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "9f94c261-58c0-4e96-a7bc-b7bf6cddf826",
        "type": "message",
        "text": "Great answer, thanks, that's very clear.\n\nSo on permissions: is there a primary owner that configures write-permitted collaborators per (fine-grained) graph chunk? And I'd guess a kinda separate read permissions for more people to see bigger chunks of your graph?",
        "user": "UE6EFEPTQ",
        "ts": "1697126568.674739",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xLvFb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great answer, thanks, that's very clear.\n\nSo on permissions: is there a primary owner that configures write-permitted collaborators per (fine-grained) graph chunk? And I'd guess a kinda separate read permissions for more people to see bigger chunks of your graph?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "1e5c704a-58c1-4877-96f4-0e6461f0528a",
        "type": "message",
        "text": "This looks at the same time (1) very interesting and (2) scary.\n\nVery interesting for what it allows to do - I guess I don't need to expand on this.\n\nScary because it encourages \"apps\" to enclose data  in silos (the clones), which is the exact opposite of what I am hoping and advocating for.\n\nI do understand that apps can store the cloned data in persistent storage, such as a file system, in any format they like, and thereby make it accessible to other apps. But the focus of the documentation is on apps that \"own\" the user's data.",
        "user": "UJBAJNFLK",
        "ts": "1697128966.082259",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wSQTF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This looks at the same time (1) very interesting and (2) scary.\n\nVery interesting for what it allows to do - I guess I don't need to expand on this.\n\nScary because it encourages \"apps\" to enclose data  in silos (the clones), which is the exact opposite of what I am hoping and advocating for.\n\nI do understand that apps can store the cloned data in persistent storage, such as a file system, in any format they like, and thereby make it accessible to other apps. But the focus of the documentation is on apps that \"own\" the user's data."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "6fd68acd-3056-4ba5-b959-0bcbf7a7d570",
        "type": "message",
        "text": "> So on permissions: is there a primary owner that configures write-permitted collaborators per (fine-grained) graph chunk? And I'd guess a kinda separate read permissions for more people to see bigger chunks of your graph?\nThere's a 'grand vision' flavour of answer and an implementation-specific one. To start with the latter, let me first say that m-ld chunks the world into 'domains', which are generally expected to be file-size things, which are cloned in-full. Each domain is its own graph, and the convergence guarantee covers the contents of that domain.\n\nRead permissions in practice (so far) have been nicely covered by just controlling who has access to the messaging channel for that domain. For example, using MQTT, the channel is a Topic, which can be access controlled.\n\nThe baseline position for write permissions is, everyone has them \u2013 the component is intended for multi-editor writing. But that's not going to be satisfactory for every use-case. I did a whole research project on decentralised fine-grained write permissions. <https://github.com/m-ld/m-ld-security-spec/blob/main/design/suac.md|The long answer is here>. In short, the domain starts with the first \"genesis\" clone, which establishes the security model and its local user, identified by public key, as the authority over everything. After that, permissions can change by an 'agreement', which is a data update that disallows any concurrent update and so can be used to establish a kind of chain of custody which can be independently verified at each node. At the moment this model is tricky to set up and not well enough characterised, so for now, fine-grained write permissions are definitely in the realm of the experimental.\n\nTo return to the grand vision: we're pretty sure we can make domains less physically-bound, and be able to have big domains which are cloned only in part, as required. That would first require some refinements to the 'agreements' model. But also, these ideas go hand-in-hand with having untrusted nodes, which is the tricky bug-bear of any attempt to decentralise authority. (Sorry about the hand-waving. More thoughts on this are in the long answer linked above, in the 'trust' section at the end.)",
        "user": "U05V95DDSLA",
        "ts": "1697133127.242479",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pIA+b",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So on permissions: is there a primary owner that configures write-permitted collaborators per (fine-grained) graph chunk? And I'd guess a kinda separate read permissions for more people to see bigger chunks of your graph?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's a 'grand vision' flavour of answer and an implementation-specific one. To start with the latter, let me first say that m-ld chunks the world into 'domains', which are generally expected to be file-size things, which are cloned in-full. Each domain is its own graph, and the convergence guarantee covers the contents of that domain.\n\nRead permissions in practice (so far) have been nicely covered by just controlling who has access to the messaging channel for that domain. For example, using MQTT, the channel is a Topic, which can be access controlled.\n\nThe baseline position for write permissions is, everyone has them \u2013 the component is intended for multi-editor writing. But that's not going to be satisfactory for every use-case. I did a whole research project on decentralised fine-grained write permissions. "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/m-ld/m-ld-security-spec/blob/main/design/suac.md",
                                "text": "The long answer is here"
                            },
                            {
                                "type": "text",
                                "text": ". In short, the domain starts with the first \"genesis\" clone, which establishes the security model and its local user, identified by public key, as the authority over everything. After that, permissions can change by an 'agreement', which is a data update that disallows any concurrent update and so can be used to establish a kind of chain of custody which can be independently verified at each node. At the moment this model is tricky to set up and not well enough characterised, so for now, fine-grained write permissions are definitely in the realm of the experimental.\n\nTo return to the grand vision: we're pretty sure we can make domains less physically-bound, and be able to have big domains which are cloned only in part, as required. That would first require some refinements to the 'agreements' model. But also, these ideas go hand-in-hand with having untrusted nodes, which is the tricky bug-bear of any attempt to decentralise authority. (Sorry about the hand-waving. More thoughts on this are in the long answer linked above, in the 'trust' section at the end.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U05V95DDSLA",
            "ts": "1697135137.000000"
        },
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "b907b4cb-1c7a-4278-bb48-6e6d6e9b82e9",
        "type": "message",
        "text": "&gt; But the focus of the documentation is on apps that \"own\" the user's data.\nAh! That's great feedback, thanks, I definitely need to address that focus!\n\nSo, we're hoping the design of m-ld will actually encourage apps not to be parochial about their data structures. It's based on the W3C's <https://www.w3.org/2013/data/|Resource Description Framework (RDF)>. So it buys into a world of well-defined tools and techniques for data, including the ability to declare the data model in the data itself. I'm hoping that will encourage the use of standard and shared vocabularies.\n\nThis is the same fundamental choice as in the Solid Project, if you're familiar with that. As a component rather than a platform, we don't have the same opportunity to transform data ownership like they do. (It'd be great to explore how Solid and m-ld work together though.)",
        "user": "U05V95DDSLA",
        "ts": "1697134167.725999",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CRP9W",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But the focus of the documentation is on apps that \"own\" the user's data."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah! That's great feedback, thanks, I definitely need to address that focus!\n\nSo, we're hoping the design of m-ld will actually encourage apps not to be parochial about their data structures. It's based on the W3C's "
                            },
                            {
                                "type": "link",
                                "url": "https://www.w3.org/2013/data/",
                                "text": "Resource Description Framework (RDF)"
                            },
                            {
                                "type": "text",
                                "text": ". So it buys into a world of well-defined tools and techniques for data, including the ability to declare the data model in the data itself. I'm hoping that will encourage the use of standard and shared vocabularies.\n\nThis is the same fundamental choice as in the Solid Project, if you're familiar with that. As a component rather than a platform, we don't have the same opportunity to transform data ownership like they do. (It'd be great to explore how Solid and m-ld work together though.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    },
    {
        "client_msg_id": "65d41246-ea2b-482b-86ba-5aa6877c9b57",
        "type": "message",
        "text": "Thanks <@U05V95DDSLA>, that sounds a lot better than my first impression! A combination of m-ld with Solid sounds very interesting. The pod would provide the common reference that multiple apps can refer to.",
        "user": "UJBAJNFLK",
        "ts": "1697137857.478559",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Lwacf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "U05V95DDSLA"
                            },
                            {
                                "type": "text",
                                "text": ", that sounds a lot better than my first impression! A combination of m-ld with Solid sounds very interesting. The pod would provide the common reference that multiple apps can refer to."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1697101718.309229",
        "parent_user_id": "U05V95DDSLA"
    }
]