[
    {
        "client_msg_id": "7693E344-6CE8-4913-AA0D-AE5714878F07",
        "type": "message",
        "text": "I built a Magic Inky interface at work a while back. A metadata editor that presented as a nested bulleted list of English sentences with clickable words, like:\n\n\u201cFrom [time T1] to [time T2], an [event type] happens with [property P], and it\u2019s very [adjective].\u201d\n\nThe event descriptions are highly multi-dimensional and resonate well with this information design, though the timestamps suffer a bit. They want to be on a timeline, but I didn\u2019t have the budget. Despite this, the UI has saved us loads of time and people _love_ the sentence-based configuration compared to the forty-column table of dropdowns they envisioned when I started the project.\n\nThe biggest failure was that enforcing a few global constraints was _also_ outside my budget. Lacking those has led to data loss\u2014never more than a few minute\u2019s worth, but still. I felt bad. Thankfully, someone else recently picked up the project and will be correcting those omissions.\n\nBut we disagreed immediately on how to do it! I thought we should _present_ the errors: \u201cThese events overlap!\u201d The other person thought we should make the errors impossible: when you edit a timestamp, you implicitly edit all the others that are involved in the constraint.\n\nI generally agree with their approach. I mean, it\u2019s baked into the rest of the UI. When you change an event type, it changes the rest of the sentence. But if you change the type back, the sentence structure is restored and your previous values all come back. Cascading edits are more destructive than that. They force you to be careful about what you change and to be observant of unintended side-effects.\n\nThe block editor problem of representing invalid states is another way to look at it. Sometimes the most efficient path between two valid states passes through an invalid one. If you want to reorder two events, for example, a first step might be to copy the start and end times from one to the other, as part of an \u201ca = b; b = oldA\u201d sequence. They overlap until you\u2019re done. To do the same without ever breaking global constraints requires user ingenuity or a more featureful editor with a \u201cswap events\u201d button. Requiring user ingenuity wastes a lot of time and energy and happiness over the lifetime of the UI, but observing users and adding features to address every desired editing operation takes a lot of dev time too, and it has to happen _now_, or else people editing this data will be blocked whenever they find an impossible edit.\n\nAnyway, not too many answers here, but I thought it was an interesting case study, with thought-provoking _questions_ at least!",
        "user": "UFEQUBNNT",
        "ts": "1700405882.617679",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ov5o1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I built a Magic Inky interface at work a while back. A metadata editor that presented as a nested bulleted list of English sentences with clickable words, like:\n\n\u201cFrom [time T1] to [time T2], an [event type] happens with [property P], and it\u2019s very [adjective].\u201d\n\nThe event descriptions are highly multi-dimensional and resonate well with this information design, though the timestamps suffer a bit. They want to be on a timeline, but I didn\u2019t have the budget. Despite this, the UI has saved us loads of time and people "
                            },
                            {
                                "type": "text",
                                "text": "love",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " the sentence-based configuration compared to the forty-column table of dropdowns they envisioned when I started the project.\n\nThe biggest failure was that enforcing a few global constraints was "
                            },
                            {
                                "type": "text",
                                "text": "also",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " outside my budget. Lacking those has led to data loss\u2014never more than a few minute\u2019s worth, but still. I felt bad. Thankfully, someone else recently picked up the project and will be correcting those omissions.\n\nBut we disagreed immediately on how to do it! I thought we should "
                            },
                            {
                                "type": "text",
                                "text": "present",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " the errors: \u201cThese events overlap!\u201d The other person thought we should make the errors impossible: when you edit a timestamp, you implicitly edit all the others that are involved in the constraint.\n\nI generally agree with their approach. I mean, it\u2019s baked into the rest of the UI. When you change an event type, it changes the rest of the sentence. But if you change the type back, the sentence structure is restored and your previous values all come back. Cascading edits are more destructive than that. They force you to be careful about what you change and to be observant of unintended side-effects.\n\nThe block editor problem of representing invalid states is another way to look at it. Sometimes the most efficient path between two valid states passes through an invalid one. If you want to reorder two events, for example, a first step might be to copy the start and end times from one to the other, as part of an \u201ca = b; b = oldA\u201d sequence. They overlap until you\u2019re done. To do the same without ever breaking global constraints requires user ingenuity or a more featureful editor with a \u201cswap events\u201d button. Requiring user ingenuity wastes a lot of time and energy and happiness over the lifetime of the UI, but observing users and adding features to address every desired editing operation takes a lot of dev time too, and it has to happen "
                            },
                            {
                                "type": "text",
                                "text": "now",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": ", or else people editing this data will be blocked whenever they find an impossible edit.\n\nAnyway, not too many answers here, but I thought it was an interesting case study, with thought-provoking "
                            },
                            {
                                "type": "text",
                                "text": "questions",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " at least!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFEQUBNNT",
            "ts": "1700406020.000000"
        },
        "thread_ts": "1700405882.617679",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1700409466.535389",
        "reply_users": [
            "UCUSW7WVD"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "amiga-tick",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "thinking_face",
                "users": [
                    "UNCP67JSK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3f4a0af4-26ec-4fcd-b3f2-eec55e9988c2",
        "type": "message",
        "text": "My bias is fewer smarts. Like you said, it sucks when one change changes many things. You can mitigate it with undo (which would then be essential), but even so things can change outside your field of view. You now need to be able to visualize everything that changed. There's seldom the budget for that, and probably for the best; I'm sure it'll lead to new problems.\n\nAnother reason to prefer lower smarts: Often there are multiple ways to propagate a change to satisfy the constraints. Which one should you choose?",
        "user": "UCUSW7WVD",
        "ts": "1700409466.535389",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AGBEd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My bias is fewer smarts. Like you said, it sucks when one change changes many things. You can mitigate it with undo (which would then be essential), but even so things can change outside your field of view. You now need to be able to visualize everything that changed. There's seldom the budget for that, and probably for the best; I'm sure it'll lead to new problems.\n\nAnother reason to prefer lower smarts: Often there are multiple ways to propagate a change to satisfy the constraints. Which one should you choose?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700405882.617679",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "4d454e90-c683-46a5-9d05-a969c3c3a073",
        "type": "message",
        "text": "An idea is starting to form for me around prototype-based modeling being a good metaphor for programming effectively with LLMs. Essentially you can provide an example of a patttern/component/class/etc and have it return a version of it modified in specific ways, which can then be used as a prototype for future generations/instantiations.\n\nA version of this idea can be seen here with tldraw: <https://twitter.com/mrmkrs/status/1725959207365583196> where he generates the next more specific interface step off the previous one.\n\nAnother I'm kind of using this in my agent framework: <https://github.com/sublayerapp/sublayer/blob/main/lib/sublayer/agents/generate_sublayer_agent_agent.rb> where we generate new agents based off a simple agent template (and works surprisingly well).\n\nI know Hofstatder digs into this concept in GEB and Steve Yegge calls it the <https://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html|Universal Design Pattern>\n\nDoes this resonate with anyone here? Is anyone familiar with any other writing about prototype-based modeling/prototypal inheritance/etc for me to take this further?",
        "user": "U05GSC0B4A0",
        "ts": "1700418506.013839",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q+Ube",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An idea is starting to form for me around prototype-based modeling being a good metaphor for programming effectively with LLMs. Essentially you can provide an example of a patttern/component/class/etc and have it return a version of it modified in specific ways, which can then be used as a prototype for future generations/instantiations.\n\nA version of this idea can be seen here with tldraw: "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/mrmkrs/status/1725959207365583196"
                            },
                            {
                                "type": "text",
                                "text": " where he generates the next more specific interface step off the previous one.\n\nAnother I'm kind of using this in my agent framework: "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/sublayerapp/sublayer/blob/main/lib/sublayer/agents/generate_sublayer_agent_agent.rb"
                            },
                            {
                                "type": "text",
                                "text": " where we generate new agents based off a simple agent template (and works surprisingly well).\n\nI know Hofstatder digs into this concept in GEB and Steve Yegge calls it the "
                            },
                            {
                                "type": "link",
                                "url": "https://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html",
                                "text": "Universal Design Pattern"
                            },
                            {
                                "type": "text",
                                "text": "\n\nDoes this resonate with anyone here? Is anyone familiar with any other writing about prototype-based modeling/prototypal inheritance/etc for me to take this further?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700418506.013839",
        "reply_count": 5,
        "reply_users_count": 2,
        "latest_reply": "1700423981.304209",
        "reply_users": [
            "U03R0B9U1GD",
            "U05GSC0B4A0"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "ceb3f265-1a36-4dcb-a051-adf3a8bf7658",
        "type": "message",
        "text": "Hey I built the tldraw \"make real\" thing! Making that 'game loop' was the thing I added to Sawyer Hood's original version. I thought it was really important to have this 'back-and-forth' going on, like you can get with chatgpt.",
        "user": "U03R0B9U1GD",
        "ts": "1700422759.471269",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9/Es1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey I built the tldraw \"make real\" thing! Making that 'game loop' was the thing I added to Sawyer Hood's original version. I thought it was really important to have this 'back-and-forth' going on, like you can get with chatgpt."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700418506.013839",
        "parent_user_id": "U05GSC0B4A0"
    },
    {
        "client_msg_id": "aa32d6d7-4e7e-4aac-916e-973cee8de4a7",
        "type": "message",
        "text": "It's been interesting seeing alternatives pop up this week, which sometimes miss that as the important part. eg: In Figma's version, you can't annotate the generated html",
        "user": "U03R0B9U1GD",
        "ts": "1700422818.125879",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sJH++",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's been interesting seeing alternatives pop up this week, which sometimes miss that as the important part. eg: In Figma's version, you can't annotate the generated html"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03R0B9U1GD",
            "ts": "1700423862.000000"
        },
        "thread_ts": "1700418506.013839",
        "parent_user_id": "U05GSC0B4A0"
    },
    {
        "client_msg_id": "59C421D3-9A0D-4FE8-ACEF-073A4B065306",
        "type": "message",
        "text": "Ahh awesome! Yeah the make real thing is amazing, my mind has been racing since I\u2019ve seen it. Great job!",
        "user": "U05GSC0B4A0",
        "ts": "1700423826.605879",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Hs30P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ahh awesome! Yeah the make real thing is amazing, my mind has been racing since "
                            },
                            {
                                "type": "text",
                                "text": "I\u2019ve"
                            },
                            {
                                "type": "text",
                                "text": " seen it. Great job!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700418506.013839",
        "parent_user_id": "U05GSC0B4A0"
    },
    {
        "client_msg_id": "D9FAE2EE-78F5-4009-8F5A-DC0427C64134",
        "type": "message",
        "text": "But yeah, being able to annotate and generate and regenerate is definitely a key",
        "user": "U05GSC0B4A0",
        "ts": "1700423863.114309",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2k2hw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But yeah, being able to annotate and generate and regenerate is definitely a key"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700418506.013839",
        "parent_user_id": "U05GSC0B4A0"
    },
    {
        "client_msg_id": "CD3E36E2-C159-4AAA-A5CE-B23B0BB836CE",
        "type": "message",
        "text": "Like we\u2019re doing with the agents (in a purely code way) - we can then customize a generated agent and use that as a template for a future one (in a pre-release version we had one that returned a list of command line commands to then be run on the local machine)",
        "user": "U05GSC0B4A0",
        "ts": "1700423981.304209",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Iy485",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Like we\u2019re doing with the agents (in a purely code way) - we can then customize a generated agent and use that as a template for a future one (in a pre-release version we had one that returned a list of command line commands to then be run on the local machine)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700418506.013839",
        "parent_user_id": "U05GSC0B4A0"
    }
]