[
    {
        "client_msg_id": "A59D4CC8-B58B-47C4-A19F-FC9542F653A6",
        "type": "message",
        "text": "An essay on the challenges of image based/live systems: <https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/|https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/>",
        "user": "UKJGU23KP",
        "ts": "1700747986.966939",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mMnyh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An essay on the challenges of image based/live systems: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/",
                                "text": "https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "reply_count": 24,
        "reply_users_count": 6,
        "latest_reply": "1701030842.751999",
        "reply_users": [
            "UCUSW7WVD",
            "UKJGU23KP",
            "UJBAJNFLK",
            "U71PMQ1V0",
            "U8A5MS6R1",
            "U6KQ2S410"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart_decoration",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK",
                    "U04QB9V2RNG",
                    "U04QM16GS1J",
                    "U05597GCDDK",
                    "U8A5MS6R1",
                    "U02B6FQKZK8"
                ],
                "count": 6
            }
        ]
    },
    {
        "client_msg_id": "687510e4-9d7d-48af-9e2f-f6cde1b8e33a",
        "type": "message",
        "text": "This is outstanding, <@U71PMQ1V0>!",
        "user": "UCUSW7WVD",
        "ts": "1700752333.387869",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "icmlI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is outstanding, "
                            },
                            {
                                "type": "user",
                                "user_id": "U71PMQ1V0"
                            },
                            {
                                "type": "text",
                                "text": "!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "D710FCF7-D69E-435E-88AB-08055E611018",
        "type": "message",
        "text": "Ah yeah, I would\u2019ve tagged had I remembered he joined here. ",
        "user": "UKJGU23KP",
        "ts": "1700752389.383529",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BcR3O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah yeah, "
                            },
                            {
                                "type": "text",
                                "text": "I would\u2019ve"
                            },
                            {
                                "type": "text",
                                "text": " tagged had I remembered he joined here. "
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cb521daa-b8d1-4d2d-88bb-3b0a5ed54d0d",
        "type": "message",
        "text": "Nice! This reminds me of <https://www.n16f.net/blog/interactive-common-lisp-development/|another post I saw yesterday>, on what you need to keep in mind when doing interactive development in Lisp. It's quite a bit, but also because Common Lisp is a rather complex language.\n\nWondering:\n&gt; A saner option is to recompile and reload the entire codebase whenever a change is made, while preserving the state of the heap\nAre there any real-life implementations of that idea?",
        "user": "UJBAJNFLK",
        "ts": "1700754594.168189",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "79ct9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nice! This reminds me of "
                            },
                            {
                                "type": "link",
                                "url": "https://www.n16f.net/blog/interactive-common-lisp-development/",
                                "text": "another post I saw yesterday"
                            },
                            {
                                "type": "text",
                                "text": ", on what you need to keep in mind when doing interactive development in Lisp. It's quite a bit, but also because Common Lisp is a rather complex language.\n\nWondering:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A saner option is to recompile and reload the entire codebase whenever a change is made, while preserving the state of the heap"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there any real-life implementations of that idea?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://www.n16f.net/blog/interactive-common-lisp-development/",
                "id": 1,
                "original_url": "https://www.n16f.net/blog/interactive-common-lisp-development/",
                "fallback": "Brain dump: Interactive Common Lisp development",
                "text": "Common Lisp programming is often presented as &amp;ldquo;interactive&amp;rdquo;. In most languages, modifications to your program are applied by recompiling it and restarting it. In contrast, Common Lisp lets\u2026",
                "title": "Interactive Common Lisp development",
                "title_link": "https://www.n16f.net/blog/interactive-common-lisp-development/",
                "service_name": "Brain dump"
            }
        ],
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b860ebef-d194-4eba-b116-a79eb5b78a2a",
        "type": "message",
        "text": "&gt; Are there any real-life implementations of that idea?\nSort of erlang. It's designed for upgrading production services so it has a lot more toggles and manual controls than you'd want for interactive editing, and there's no undo if you screw up the migration. But it does work fairly well. Certainly compared to everything else.\n\nI also see a lot of game developers do this in C and it seems pretty useful even with the complete lack of type safety.",
        "user": "U71PMQ1V0",
        "ts": "1700764965.432619",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iM78u",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there any real-life implementations of that idea?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSort of erlang. It's designed for upgrading production services so it has a lot more toggles and manual controls than you'd want for interactive editing, and there's no undo if you screw up the migration. But it does work fairly well. Certainly compared to everything else.\n\nI also see a lot of game developers do this in C and it seems pretty useful even with the complete lack of type safety."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "45528ee0-6db2-4598-9d3b-4704f77d5601",
        "type": "message",
        "text": "Also tagging me did nothing, someone had to manually tell me about this thread. Is sending notification emails a paid feature on slack?",
        "user": "U71PMQ1V0",
        "ts": "1700765134.527789",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wJqCk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also tagging me did nothing, someone had to manually tell me about this thread. Is sending notification emails a paid feature on slack?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "BEA88543-4074-4010-8DF4-5E9B7537EF11",
        "type": "message",
        "text": "I know I\u2019ve only ever seen notifications inside slack, or on my iPhone screen when I gave slack that permission. So it\u2019s not a default that it does it.",
        "user": "UKJGU23KP",
        "ts": "1700820779.116479",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "brDd2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know "
                            },
                            {
                                "type": "text",
                                "text": "I\u2019ve"
                            },
                            {
                                "type": "text",
                                "text": " only ever seen notifications inside slack, or on my iPhone screen when I gave slack that permission. "
                            },
                            {
                                "type": "text",
                                "text": "So it\u2019s"
                            },
                            {
                                "type": "text",
                                "text": " not a default that it does it."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "type": "message",
        "text": "I have set the preference though. It just doesn't seem to work. Makes slack much less useful for occasionally visited communities.",
        "files": [
            {
                "id": "F0674QFC13P",
                "created": 1700846131,
                "timestamp": 1700846131,
                "name": "screenshot_2023-11-24_09-14-46.png",
                "title": "screenshot_2023-11-24_09-14-46.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U71PMQ1V0",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 9105,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F0674QFC13P/screenshot_2023-11-24_09-14-46.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F0674QFC13P/download/screenshot_2023-11-24_09-14-46.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F0674QFC13P-548db01f12/screenshot_2023-11-24_09-14-46_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F0674QFC13P-548db01f12/screenshot_2023-11-24_09-14-46_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F0674QFC13P-548db01f12/screenshot_2023-11-24_09-14-46_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 84,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F0674QFC13P-548db01f12/screenshot_2023-11-24_09-14-46_160.png",
                "original_w": 478,
                "original_h": 111,
                "thumb_tiny": "AwALADDRPHc80mT6n9KfSYHoKAEGc9W/Slwf7xpaKAEwf7xoAI7k0tFAH//Z",
                "permalink": "https://futureofcoding.slack.com/files/U71PMQ1V0/F0674QFC13P/screenshot_2023-11-24_09-14-46.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F0674QFC13P-6bbd8cc624",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "U71PMQ1V0",
        "display_as_bot": false,
        "ts": "1700846159.392189",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jinzx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have set the preference though. It just doesn't seem to work. Makes slack much less useful for occasionally visited communities."
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "e767fac6-866a-471a-bd0a-48f3fb99209b",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "901f7f6d-7281-4acb-9873-a68670653dac",
        "type": "message",
        "text": "It's definitely a bug.",
        "user": "UCUSW7WVD",
        "ts": "1700846496.385049",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WbpWO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's definitely a bug."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "3f3342fb-ef91-4b3b-891c-60d72e03f436",
        "type": "message",
        "text": "Excellent essay!\n\nI believe the issues described with live systems are not actually solved with dead systems, but just deferred until later. That\u2019s because dead systems don\u2019t often represent entire systems but only a slice of the system. Consider a system with a Rust (or another dead lang) web app backed by another web service and a db. One problem is evolving the web app code while preserving the db data and migrating the db schema. This is similar to evolving live code while the heap remains intact. Another problem is that upgrading the downstream service may change or delete an API method and it leave it incompatible with the caller web app. This is similar to upgrading a subset of functions within the same live program. Dead-lang approaches don\u2019t solve any of these problems of \u201cexternal couplings\u201d and \u201cexternalized data\u201d but simply exclude them from their scope, leaving us to wrangle these with other approaches. Live systems seems less tractable because these problems are harder, and more worthwhile (my position).",
        "user": "U8A5MS6R1",
        "ts": "1700850935.431519",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1EP70",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Excellent essay!\n\nI believe the issues described with live systems are not actually solved with dead systems, but just deferred until later. That\u2019s because dead systems don\u2019t often represent entire systems but only a slice of the system. Consider a system with a Rust (or another dead lang) web app backed by another web service and a db. One problem is evolving the web app code while preserving the db data and migrating the db schema. This is similar to evolving live code while the heap remains intact. Another problem is that upgrading the downstream service may change or delete an API method and it leave it incompatible with the caller web app. This is similar to upgrading a subset of functions within the same live program. Dead-lang approaches don\u2019t solve any of these problems of \u201cexternal couplings\u201d and \u201cexternalized data\u201d but simply exclude them from their scope, leaving us to wrangle these with other approaches. Live systems seems less tractable because these problems are harder, and more worthwhile (my position)."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "198f101e-8d05-4177-aad6-899483cb7da0",
        "type": "message",
        "text": "Another note on this:\n&gt; For a start, you can actually find the code as a single artifact rather than it being the product of a log of mutations.\nSome of this gets lost even in dead-langs when you\u2019re dealing with macros, metaprogramming or subsclassing at some level of complexity. Not only do you have to simulate the runtime semantics in your head, you also have to simulate the type checker and compiler semantics.",
        "user": "U8A5MS6R1",
        "ts": "1700851117.194719",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tTnYF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another note on this:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For a start, you can actually find the code as a single artifact rather than it being the product of a log of mutations."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some of this gets lost even in dead-langs when you\u2019re dealing with macros, metaprogramming or subsclassing at some level of complexity. Not only do you have to simulate the runtime semantics in your head, you also have to simulate the type checker and compiler semantics."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "ff4e7131-8a61-41e5-9ee0-42b7bc65eab7",
        "type": "message",
        "text": "Reading the essay, another idea that clicked for me was having a \u201cversion-aware runtime\u201d  - ie the system should be aware of the different versions of various artifacts (code, data, etc.). No dead-lang does this - there is only one version of all types.",
        "user": "U8A5MS6R1",
        "ts": "1700851265.767429",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WVl0b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Reading the essay, another idea that clicked for me was having a \u201cversion-aware runtime\u201d  - ie the system should be aware of the different versions of various artifacts (code, data, etc.). No dead-lang does this - there is only one version of all types."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1700851279.000000"
        },
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "CF5A0A1A-2633-429B-AFEC-59414EBCC485",
        "type": "message",
        "text": "Mentioning web apps and databases makes me think about how there are playbooks for migrations there\u2014you (if you\u2019re being careful) use monitoring, let both versions coexist, try to find callers using the old versions and encourage them to switch, etc. \n\nI wonder what the playbook looks like in a programming environment.",
        "user": "UKJGU23KP",
        "ts": "1700851479.924889",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eu7VC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Mentioning web apps and databases makes me think about how there are playbooks for migrations there"
                            },
                            {
                                "type": "text",
                                "text": "\u2014"
                            },
                            {
                                "type": "text",
                                "text": "you (if "
                            },
                            {
                                "type": "text",
                                "text": "you\u2019re"
                            },
                            {
                                "type": "text",
                                "text": " being careful) use monitoring, let both versions coexist, try to find callers using the old versions and encourage them to switch, etc. \n\nI wonder what the playbook looks like in a programming environment."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "3BCF9331-5CD5-4914-8F56-BB0531EC23B8",
        "type": "message",
        "text": "It\u2019s possible to do monitoring in your runtime.",
        "user": "UKJGU23KP",
        "ts": "1700851524.882279",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fh+M/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s"
                            },
                            {
                                "type": "text",
                                "text": " possible to do monitoring in your runtime."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "95504e18-8188-4826-aa95-ff7bb33e0382",
        "type": "message",
        "text": "<@U8A5MS6R1>\n&gt; I believe the issues described with live systems are not actually solved with dead systems, but just deferred until later. That\u2019s because dead systems don\u2019t often represent entire systems but only a slice of the system.. upgrading [a] downstream service may change or delete an API method and it leave it incompatible with the caller.\nThis depends on the context. If you think of the upstream and downstream as within a common ownership boundary, then such checks are valuable. However, if they span ownership boundaries then these checks can seem onerous.\n\nYou're right that dead systems work almost accidentally for the second case, by just not doing some work. Ideally we'd have both tools in our pocket, and the flexibility to select from them depending on the situation. However, this is a lot of complexity, and all code carries costs. So worse may be better here.\n\nThis situation is analogous to structured editing like in <@UFEQUBNNT>'s recent submission <https://futureofcoding.slack.com/archives/C5T9GPWFL/p1700405882617679>. It's easy for a structured editor to feel like an overbearing presence. The implementor has to juggle both technical complexity and UX nuance. Meanwhile plain text is often \"good enough\" and so we continue to muddle along..",
        "user": "UCUSW7WVD",
        "ts": "1700853311.588469",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DBEX4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I believe the issues described with live systems are not actually solved with dead systems, but just deferred until later. That\u2019s because dead systems don\u2019t often represent entire systems but only a slice of the system.. upgrading [a] downstream service may change or delete an API method and it leave it incompatible with the caller."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis depends on the context. If you think of the upstream and downstream as within a common ownership boundary, then such checks are valuable. However, if they span ownership boundaries then these checks can seem onerous.\n\nYou're right that dead systems work almost accidentally for the second case, by just not doing some work. Ideally we'd have both tools in our pocket, and the flexibility to select from them depending on the situation. However, this is a lot of complexity, and all code carries costs. So worse may be better here.\n\nThis situation is analogous to structured editing like in "
                            },
                            {
                                "type": "user",
                                "user_id": "UFEQUBNNT"
                            },
                            {
                                "type": "text",
                                "text": "'s recent submission "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1700405882617679"
                            },
                            {
                                "type": "text",
                                "text": ". It's easy for a structured editor to feel like an overbearing presence. The implementor has to juggle both technical complexity and UX nuance. Meanwhile plain text is often \"good enough\" and so we continue to muddle along.."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "bef29aac-bcec-4cc6-a01e-448b3f259caa",
        "type": "message",
        "text": "&gt; It\u2019s possible to do monitoring in your runtime.\nYeah, the key requirement is version-awareness - whether the endpoint name encodes the version or some introspection api returns the version of the service, any strategy needs a representation of the version of functions etc within the system itself, and should allow multiple versions to coexist. An interesting implementation here is gemstone smalltalk - it is a live system where you can evolve the schema by providing migration methods and the objects can be migrated to newer definitions either opportunistically or in batch.",
        "user": "U8A5MS6R1",
        "ts": "1700855159.746349",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JAmBB",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s possible to do monitoring in your runtime."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYeah, the key requirement is version-awareness - whether the endpoint name encodes the version or some introspection api returns the version of the service, any strategy needs a representation of the version of functions etc within the system itself, and should allow multiple versions to coexist. An interesting implementation here is gemstone smalltalk - it is a live system where you can evolve the schema by providing migration methods and the objects can be migrated to newer definitions either opportunistically or in batch."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "f7d48fc8-22ec-42b6-a9e9-4a4ac47f79a2",
        "type": "message",
        "text": "<@UCUSW7WVD>\n> Ideally we\u2019d have both tools in our pocket, and the flexibility to select from them depending on the situation. \n:100:\nI\u2019d even add that ideally these would not be two separate tools but a single model that can be applied in varying use cases - from \u201cearly bound, validated\u201d bundles of code to \u201clate bound, but also validated\u201d and in between.\n> However, this is a lot of complexity, and all code carries costs. So worse may be better here.\nWould this be more complexity than present day type checkers? :stuck_out_tongue_winking_eye:",
        "user": "U8A5MS6R1",
        "ts": "1700855176.236059",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rM1EW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ideally we\u2019d have both tools in our pocket, and the flexibility to select from them depending on the situation. "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "100",
                                "unicode": "1f4af"
                            },
                            {
                                "type": "text",
                                "text": "\nI\u2019d even add that ideally these would not be two separate tools but a single model that can be applied in varying use cases - from \u201cearly bound, validated\u201d bundles of code to \u201clate bound, but also validated\u201d and in between.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "However, this is a lot of complexity, and all code carries costs. So worse may be better here."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Would this be more complexity than present day type checkers? "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue_winking_eye",
                                "unicode": "1f61c"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1700855191.000000"
        },
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "e0690e18-93b0-4d14-8675-7f40fa02cf4e",
        "type": "message",
        "text": "I absolutely think so! You're adding a whole new dimension to the problem. What are you taking out?",
        "user": "UCUSW7WVD",
        "ts": "1700855665.687799",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RuEaS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I absolutely think so! You're adding a whole new dimension to the problem. What are you taking out?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "c45096d4-ba95-4947-9808-8e59709999f7",
        "type": "message",
        "text": "Ah good point. If we keep all the existing static lang ideas intact and then layer on dynamic bindings, yes it\u2019s a whole another dimension. However if we first reduce the language features (eg like the essay suggests, 2nd class functions only) and design the types and semantics of the language to be amenable to both static and dynamic bindings we want, then maybe we have a chance.",
        "user": "U8A5MS6R1",
        "ts": "1700856678.389159",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EfLx3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah good point. If we keep all the existing static lang ideas intact and then layer on dynamic bindings, yes it\u2019s a whole another dimension. However if we first reduce the language features (eg like the essay suggests, 2nd class functions only) and design the types and semantics of the language to be amenable to both static and dynamic bindings we want, then maybe we have a chance."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0a05a6fb-fcff-4cdc-b6cf-2e70532a467d",
        "type": "message",
        "text": "The problem as I see it is that dyanmic+live langs have typically not been designed to make validation or optimization easy, and static langs have not been designed to make late binding easy. I don\u2019t think we want to total freedom of dynamic+live langs. We want some snapshotting of state, we want visualization and provenance tracking of all dynamically generated code. Once we start adding these we can introduce ways to validate and optimize the slices of the live system that have stabilized.",
        "user": "U8A5MS6R1",
        "ts": "1700857043.244309",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5ptpy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The problem as I see it is that dyanmic+live langs have typically not been designed to make validation or optimization easy, and static langs have not been designed to make late binding easy. I don\u2019t think we want to total freedom of dynamic+live langs. We want some snapshotting of state, we want visualization and provenance tracking of all dynamically generated code. Once we start adding these we can introduce ways to validate and optimize the slices of the live system that have stabilized."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1700872513.000000"
        },
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "509baf8e-f453-406a-aeee-60a644be54a1",
        "type": "message",
        "text": "Throwing a somewhat related paper into the discussion: \"World Age in Julia\" <http://janvitek.org/pubs/oopsla20-j.pdf>\n\nMore about metaprogramming than live modification, but the issues are similar. Abstract:\n&gt; Dynamic programming languages face semantic and performance challenges in the presence of features, such\n&gt; as eval, that can inject new code into a running program. The Julia programming language introduces the\n&gt; novel concept of world age to insulate optimized code from one of the most disruptive side-effects of eval:\n&gt; changes to the definition of an existing function. This paper provides the first formal semantics of world age\n&gt; in a core calculus named Juliette, and shows how world age enables compiler optimizations, such as inlining,\n&gt; in the presence of eval. While Julia also provides programmers with the means to bypass world age, we found\n&gt; that this mechanism is not used extensively: a static analysis of over 4,000 registered Julia packages shows\n&gt; that only 4\u20139% of packages bypass world age. This suggests that Julia\u2019s semantics aligns with programmer\n&gt; expectations.",
        "user": "UJBAJNFLK",
        "ts": "1700931703.634839",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KzB5d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Throwing a somewhat related paper into the discussion: \"World Age in Julia\" "
                            },
                            {
                                "type": "link",
                                "url": "http://janvitek.org/pubs/oopsla20-j.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nMore about metaprogramming than live modification, but the issues are similar. Abstract:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Dynamic programming languages face semantic and performance challenges in the presence of features, such\nas eval, that can inject new code into a running program. The Julia programming language introduces the\nnovel concept of world age to insulate optimized code from one of the most disruptive side-effects of eval:\nchanges to the definition of an existing function. This paper provides the first formal semantics of world age\nin a core calculus named Juliette, and shows how world age enables compiler optimizations, such as inlining,\nin the presence of eval. While Julia also provides programmers with the means to bypass world age, we found\nthat this mechanism is not used extensively: a static analysis of over 4,000 registered Julia packages shows\nthat only 4\u20139% of packages bypass world age. This suggests that Julia\u2019s semantics aligns with programmer\nexpectations."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d0e43b43-9bb8-437b-aa84-102b69e7093e",
        "type": "message",
        "text": "Julia's behaviour around closures is among the nicest I've seen:\n\n```julia&gt; foo(x, y) = x + y\nfoo (generic function with 1 method)\n\njulia&gt; bar = x -&gt; foo(x, 1)\n#3 (generic function with 1 method)\n\njulia&gt; bar(1)\n2\n\njulia&gt; @code_llvm bar(1)\n;  @ REPL[1]:1 within `#3`\ndefine i64 @\"julia_#3_122\"(i64 signext %0) #0 {\ntop:\n; \u250c @ REPL[7]:1 within `foo`\n; \u2502\u250c @ int.jl:87 within `+`\n    %1 = add i64 %0, 1\n; \u2514\u2514\n  ret i64 %1\n}\n\njulia&gt; Base.delete_method(@which foo(1,1))\n\njulia&gt; bar(1)\nERROR: MethodError: no method matching foo(::Int64, ::Int64)\nStacktrace:\n [1] (::var\"#3#4\")(x::Int64)\n   @ Main ./REPL[1]:1\n [2] top-level scope\n   @ REPL[6]:1\n\njulia&gt; @code_llvm bar(1)\n;  @ REPL[1]:1 within `#3`\n; Function Attrs: noreturn\ndefine void @\"julia_#3_133\"(i64 signext %0) #0 {\ntop:\n  %1 = alloca [2 x {}*], align 8\n  %gcframe2 = alloca [3 x {}*], align 16\n  %gcframe2.sub = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 0\n  %.sub = getelementptr inbounds [2 x {}*], [2 x {}*]* %1, i64 0, i64 0\n  %2 = bitcast [3 x {}*]* %gcframe2 to i8*\n  call void @llvm.memset.p0i8.i32(i8* noundef nonnull align 16 dereferenceable(24) %2, i8 0, i32 24, i1 false)\n  %thread_ptr = call i8* asm \"movq %fs:0, $0\", \"=r\"() #6\n  %ppgcstack_i8 = getelementptr i8, i8* %thread_ptr, i64 -8\n  %ppgcstack = bitcast i8* %ppgcstack_i8 to {}****\n  %pgcstack = load {}***, {}**** %ppgcstack, align 8\n  %3 = bitcast [3 x {}*]* %gcframe2 to i64*\n  store i64 4, i64* %3, align 16\n  %4 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 1\n  %5 = bitcast {}** %4 to {}***\n  %6 = load {}**, {}*** %pgcstack, align 8\n  store {}** %6, {}*** %5, align 8\n  %7 = bitcast {}*** %pgcstack to {}***\n  store {}** %gcframe2.sub, {}*** %7, align 8\n  %8 = call nonnull {}* @ijl_box_int64(i64 signext %0)\n  %9 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 2\n  store {}* %8, {}** %9, align 16\n  store {}* %8, {}** %.sub, align 8\n  %10 = getelementptr inbounds [2 x {}*], [2 x {}*]* %1, i64 0, i64 1\n  store {}* inttoptr (i64 140053833609312 to {}*), {}** %10, align 8\n  %11 = call nonnull {}* @ijl_apply_generic({}* inttoptr (i64 140053835183152 to {}*), {}** nonnull %.sub, i32 2)\n  call void @llvm.trap()\n  unreachable\n}```",
        "user": "U71PMQ1V0",
        "ts": "1700958691.028079",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LEG9E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Julia's behaviour around closures is among the nicest I've seen:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "julia> foo(x, y) = x + y\nfoo (generic function with 1 method)\n\njulia> bar = x -> foo(x, 1)\n#3 (generic function with 1 method)\n\njulia> bar(1)\n2\n\njulia> @code_llvm bar(1)\n;  @ REPL[1]:1 within `#3`\ndefine i64 @\"julia_#3_122\"(i64 signext %0) #0 {\ntop:\n; \u250c @ REPL[7]:1 within `foo`\n; \u2502\u250c @ int.jl:87 within `+`\n    %1 = add i64 %0, 1\n; \u2514\u2514\n  ret i64 %1\n}\n\njulia> Base.delete_method(@which foo(1,1))\n\njulia> bar(1)\nERROR: MethodError: no method matching foo(::Int64, ::Int64)\nStacktrace:\n [1] (::var\"#3#4\")(x::Int64)\n   @ Main ./REPL[1]:1\n [2] top-level scope\n   @ REPL[6]:1\n\njulia> @code_llvm bar(1)\n;  @ REPL[1]:1 within `#3`\n; Function Attrs: noreturn\ndefine void @\"julia_#3_133\"(i64 signext %0) #0 {\ntop:\n  %1 = alloca [2 x {}*], align 8\n  %gcframe2 = alloca [3 x {}*], align 16\n  %gcframe2.sub = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 0\n  %.sub = getelementptr inbounds [2 x {}*], [2 x {}*]* %1, i64 0, i64 0\n  %2 = bitcast [3 x {}*]* %gcframe2 to i8*\n  call void @llvm.memset.p0i8.i32(i8* noundef nonnull align 16 dereferenceable(24) %2, i8 0, i32 24, i1 false)\n  %thread_ptr = call i8* asm \"movq %fs:0, $0\", \"=r\"() #6\n  %ppgcstack_i8 = getelementptr i8, i8* %thread_ptr, i64 -8\n  %ppgcstack = bitcast i8* %ppgcstack_i8 to {}****\n  %pgcstack = load {}***, {}**** %ppgcstack, align 8\n  %3 = bitcast [3 x {}*]* %gcframe2 to i64*\n  store i64 4, i64* %3, align 16\n  %4 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 1\n  %5 = bitcast {}** %4 to {}***\n  %6 = load {}**, {}*** %pgcstack, align 8\n  store {}** %6, {}*** %5, align 8\n  %7 = bitcast {}*** %pgcstack to {}***\n  store {}** %gcframe2.sub, {}*** %7, align 8\n  %8 = call nonnull {}* @ijl_box_int64(i64 signext %0)\n  %9 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 2\n  store {}* %8, {}** %9, align 16\n  store {}* %8, {}** %.sub, align 8\n  %10 = getelementptr inbounds [2 x {}*], [2 x {}*]* %1, i64 0, i64 1\n  store {}* inttoptr (i64 140053833609312 to {}*), {}** %10, align 8\n  %11 = call nonnull {}* @ijl_apply_generic({}* inttoptr (i64 140053835183152 to {}*), {}** nonnull %.sub, i32 2)\n  call void @llvm.trap()\n  unreachable\n}"
                            }
                        ],
                        "border": 0
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "1b7c8874-d219-4ced-a34f-fb138ce714fc",
        "type": "message",
        "text": "But it doesn't allow redefining types - you have to delete and recreate a module, which means that functions in the old module don't get redefined. And then you're back to having old closures hanging around.",
        "user": "U71PMQ1V0",
        "ts": "1700958904.417009",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZHxAK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But it doesn't allow redefining types - you have to delete and recreate a module, which means that functions in the old module don't get redefined. And then you're back to having old closures hanging around."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "0fa053fa-3bf9-492c-a914-5041e1401852",
        "type": "message",
        "text": "Yes, types are the hard part. They are not part of data and code, but live in the control layer that structures data and code. I doubt there can be a generic technique to update types in a live system in all circumstances. But perhaps there are ways to handle specific practically important cases.",
        "user": "UJBAJNFLK",
        "ts": "1700995927.204469",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rj9nL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, types are the hard part. They are not part of data and code, but live in the control layer that structures data and code. I doubt there can be a generic technique to update types in a live system in all circumstances. But perhaps there are ways to handle specific practically important cases."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    },
    {
        "client_msg_id": "c6054039-0c41-4349-8828-f4537ece0488",
        "type": "message",
        "text": "I agree with a lot of what <@U71PMQ1V0> says. I\u2019d also amplify some of the above comments: versioning is the key unsolved problem of image-based/live programming",
        "user": "U6KQ2S410",
        "ts": "1701030842.751999",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wum6J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with a lot of what "
                            },
                            {
                                "type": "user",
                                "user_id": "U71PMQ1V0"
                            },
                            {
                                "type": "text",
                                "text": " says. I\u2019d also amplify some of the above comments: versioning is the key unsolved problem of image-based/live programming"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1700747986.966939",
        "parent_user_id": "UKJGU23KP"
    }
]