[
    {
        "client_msg_id": "abbe418b-85ce-498d-b973-35c41c93a14c",
        "type": "message",
        "text": "Hi everyone, I\u2019ve been thinking about using hypertext instead of text files as the medium to represent programs _and their executions_.\nPrograms contain a lot of cross references that are resolved only after the parser/runtime have had a go. IDEs also redo this parsing work to simulate the same cross references for easy editing. The idea is to embed these references in the medium itself. So, get rid of import statements, file boundaries and such. Each textual reference - function name, type name, any identifier really - would be link to the object it references. Unlike strongly structured environments, this allows some flexibility in representing partial and possibly invalid structures. I\u2019m interested in implementations you know of that match this idea.",
        "user": "U8A5MS6R1",
        "ts": "1688176784.223859",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U4Yd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi everyone, I\u2019ve been thinking about using hypertext instead of text files as the medium to represent programs "
                            },
                            {
                                "type": "text",
                                "text": "and their executions",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\nPrograms contain a lot of cross references that are resolved only after the parser/runtime have had a go. IDEs also redo this parsing work to simulate the same cross references for easy editing. The idea is to embed these references in the medium itself. So, get rid of import statements, file boundaries and such. Each textual reference - function name, type name, any identifier really - would be link to the object it references. Unlike strongly structured environments, this allows some flexibility in representing partial and possibly invalid structures. I\u2019m interested in implementations you know of that match this idea."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "reply_count": 22,
        "reply_users_count": 6,
        "latest_reply": "1688325171.005499",
        "reply_users": [
            "U8A5MS6R1",
            "U01U19ECZTJ",
            "UCUSW7WVD",
            "UJBAJNFLK",
            "U05EREC3DCK",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heartbeat",
                "users": [
                    "UCUSW7WVD",
                    "USH01JEDQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "85ed7e16-0a40-4cf8-9206-27fb05788b26",
        "type": "message",
        "text": "About \u201cand their executions\u201d: after execution of a metaprogram, and during execution of the program, many references are resolved - perhaps this can also be represented in the same medium. The \u201cgenerated program\u201d or \u201cexecution trace\u201d could form new hypertext objects that reference the original or other new hypertext objects.",
        "user": "U8A5MS6R1",
        "ts": "1688177006.799399",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JhBQf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "About \u201cand their executions\u201d: after execution of a metaprogram, and during execution of the program, many references are resolved - perhaps this can also be represented in the same medium. The \u201cgenerated program\u201d or \u201cexecution trace\u201d could form new hypertext objects that reference the original or other new hypertext objects."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "9b80e3fc-541a-4df0-a36c-1f81cfb234af",
        "type": "message",
        "text": "Your idea reminds me of Jonathan Edwards' Subtext system: <https://www.subtext-lang.org/>",
        "user": "U01U19ECZTJ",
        "ts": "1688177431.749399",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R66W=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your idea reminds me of Jonathan Edwards' Subtext system: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.subtext-lang.org/"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "3a82ee08-ee56-4fd2-80a3-0d4e88893c57",
        "type": "message",
        "text": "Ah yes thanks for bringing that up. I\u2019m familiar with Subtext and in fact using the same structure for both the execution trace and the program is influenced by <https://vimeo.com/228372549/8f5e39658b|Reifying Programming>. The difference here is using hypertext objects as the underlying structure. Subtext tends to have more strict tree like editors.",
        "user": "U8A5MS6R1",
        "ts": "1688177695.357569",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+lPm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah yes thanks for bringing that up. I\u2019m familiar with Subtext and in fact using the same structure for both the execution trace and the program is influenced by "
                            },
                            {
                                "type": "link",
                                "url": "https://vimeo.com/228372549/8f5e39658b",
                                "text": "Reifying Programming"
                            },
                            {
                                "type": "text",
                                "text": ". The difference here is using hypertext objects as the underlying structure. Subtext tends to have more strict tree like editors."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "b2cd032f-2ede-4ca5-bae5-35459462d447",
        "type": "message",
        "text": "I assume hyperlinks here would be just a mechanism to construct trees?\n\nI've long thought there should be a dual of `link` called `inline`: you don't need to click, you just see the contents of the destination in place. A combination of `link` and `inline` might subsume lots of ideas like Subtext and Brief (<https://youtube.com/watch?v=R3MNcA2dpts|https://youtube.com/watch?v=R3MNcA2dpts>)",
        "user": "UCUSW7WVD",
        "ts": "1688179265.293859",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YB5a+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I assume hyperlinks here would be just a mechanism to construct trees?\n\nI've long thought there should be a dual of "
                            },
                            {
                                "type": "text",
                                "text": "link",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " called "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": you don't need to click, you just see the contents of the destination in place. A combination of "
                            },
                            {
                                "type": "text",
                                "text": "link",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " might subsume lots of ideas like Subtext and Brief ("
                            },
                            {
                                "type": "link",
                                "url": "https://youtube.com/watch?v=R3MNcA2dpts",
                                "text": "https://youtube.com/watch?v=R3MNcA2dpts"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://youtube.com/watch?v=R3MNcA2dpts",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/R3MNcA2dpts/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https://www.youtube.com/embed/R3MNcA2dpts?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"&quot;Brief&quot; Concatenative Programming Language Demo\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "id": 1,
                "original_url": "https://youtube.com/watch?v=R3MNcA2dpts",
                "fallback": "YouTube Video: \"Brief\" Concatenative Programming Language Demo",
                "title": "\"Brief\" Concatenative Programming Language Demo",
                "title_link": "https://youtube.com/watch?v=R3MNcA2dpts",
                "author_name": "Ashley Feniello",
                "author_link": "https://www.youtube.com/@AshLeaFen",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "9c069dea-fa9c-4963-a031-75d8d1f21e74",
        "type": "message",
        "text": "Thanks for the video - will check it out.\nHyperlinks are not mechanisms just to construct trees. Even in basic cases references form DAGs and even cycles. eg here\u2019s a trivial DAG:\n```class T: ...\ndef f1(a: T): ...\ndef f2(b: T):\n  f1(b)```\nThe `T` annotation in both function definitions link to the class definition. The `f1()` call links to the `f1` function definition.\nAny mutually recursive definition will form cycles.\nNote also the hypertext objects here are individual definitions and dont impose any language semantics.\n\nNot sure I understood the `inline` idea. Are you talking about transclusion?",
        "user": "U8A5MS6R1",
        "ts": "1688184545.967029",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OOdli",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the video - will check it out.\nHyperlinks are not mechanisms just to construct trees. Even in basic cases references form DAGs and even cycles. eg here\u2019s a trivial DAG:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "class T: ...\ndef f1(a: T): ...\ndef f2(b: T):\n  f1(b)"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The "
                            },
                            {
                                "type": "text",
                                "text": "T",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " annotation in both function definitions link to the class definition. The "
                            },
                            {
                                "type": "text",
                                "text": "f1()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " call links to the "
                            },
                            {
                                "type": "text",
                                "text": "f1",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " function definition.\nAny mutually recursive definition will form cycles.\nNote also the hypertext objects here are individual definitions and dont impose any language semantics.\n\nNot sure I understood the "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " idea. Are you talking about transclusion?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "880c3ab1-d808-4e48-b3aa-e868c8400d66",
        "type": "message",
        "text": "Yeah, everything is in Xanadu.",
        "user": "UCUSW7WVD",
        "ts": "1688184701.593059",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p4lHk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, everything is in Xanadu."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "218b2e41-ee43-47e6-bb88-618a7ad0d032",
        "type": "message",
        "text": "Indeed I think to `inline` any refererence makes sense. Any hard link should be inline-able by the reader. I don\u2019t think the writer has to decide if the link should be inlined or not.",
        "user": "U8A5MS6R1",
        "ts": "1688184839.712609",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zU8O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Indeed I think to "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " any refererence makes sense. Any hard link should be inline-able by the reader. I don\u2019t think the writer has to decide if the link should be inlined or not."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1688184857.000000"
        },
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "f08f2257-11a9-41b4-8fd4-3532200606e3",
        "type": "message",
        "text": "There's advantages both ways. Writer deciding can construct experiences.\n\nI mostly care about when writer == reader, so the question is moot.",
        "user": "UCUSW7WVD",
        "ts": "1688184952.214569",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VWqB0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's advantages both ways. Writer deciding can construct experiences.\n\nI mostly care about when writer == reader, so the question is moot."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "a3026d42-a7b0-4696-9a8a-4485ac912965",
        "type": "message",
        "text": "<@U8A5MS6R1> One ingredient of your idea is extreme late binding. That's one of the principles of Smalltalk, and Smalltalk IDEs implement some of what is being discussed here, though only within the universe of the image.\n\nExample: Glamorous Toolkit lets you see the definitions of methods you call inline, which is very convenient. Your outline of metaprograms defining programs which again contain dynamically resolved references is pretty much what people call metaprogramming in Smalltalk.\n\nPharo's relatively recent slot mechanism would allow implementing more general types of links, but I haven't seen this done.\n\nSmalltalk users wouldn't call their code \"hypertext\" but rather \"object graph\", as much of the code structure never gets expressed as text. But that seems a minor technical detail to me.",
        "user": "UJBAJNFLK",
        "ts": "1688193883.502389",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Lqk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " One ingredient of your idea is extreme late binding. That's one of the principles of Smalltalk, and Smalltalk IDEs implement some of what is being discussed here, though only within the universe of the image.\n\nExample: Glamorous Toolkit lets you see the definitions of methods you call inline, which is very convenient. Your outline of metaprograms defining programs which again contain dynamically resolved references is pretty much what people call metaprogramming in Smalltalk.\n\nPharo's relatively recent slot mechanism would allow implementing more general types of links, but I haven't seen this done.\n\nSmalltalk users wouldn't call their code \"hypertext\" but rather \"object graph\", as much of the code structure never gets expressed as text. But that seems a minor technical detail to me."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "6b4a5a94-1975-41e1-a98b-cc57f7b8631f",
        "type": "message",
        "text": "I very much like this idea, it's so intuitive that I just thought, geez why isn't it done like that already",
        "user": "U05EREC3DCK",
        "ts": "1688211948.038639",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HKz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I very much like this idea, it's so intuitive that I just thought, geez why isn't it done like that already"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "e29b6d2e-fa0f-4a89-826d-3c7ca5330e90",
        "type": "message",
        "text": "<@UJBAJNFLK> interestingly I was thinking one aspect of code-as-hypertext is _earlier_ than usual binding. References get bound to objects when written. This is even earlier than in plain text compiled languages (identifiers in a text file are not bound at all). However the bindings-as-written are not the final bindings. During the course of meta-program and program execution they get rebound. Eg a reference to an abstract type may get re-bound to a concrete version of that type. Evolution of these bindings can be represented in the same structure.\nSmalltalk / Newspeak etc are a key influence behind the above idea. In Smalltalk we write classes and their methods directly, not worrying about file boundaries. I was thinking why the method body is text and not hypertext? Maybe new versions of GT/Pharo do this better. GT still seems layered on rather than native.",
        "user": "U8A5MS6R1",
        "ts": "1688249425.972249",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e5/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " interestingly I was thinking one aspect of code-as-hypertext is "
                            },
                            {
                                "type": "text",
                                "text": "earlier",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " than usual binding. References get bound to objects when written. This is even earlier than in plain text compiled languages (identifiers in a text file are not bound at all). However the bindings-as-written are not the final bindings. During the course of meta-program and program execution they get rebound. Eg a reference to an abstract type may get re-bound to a concrete version of that type. Evolution of these bindings can be represented in the same structure.\nSmalltalk / Newspeak etc are a key influence behind the above idea. In Smalltalk we write classes and their methods directly, not worrying about file boundaries. I was thinking why the method body is text and not hypertext? Maybe new versions of GT/Pharo do this better. GT still seems layered on rather than native."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "ad28557b-c325-4a1b-9596-4881791b0b3c",
        "type": "message",
        "text": "Where do you imagine the hyperlinks going to, other definitions? Many of my apps have that ability, Teliva and some of the Freewheeling stuff, and I'm wondering if the ability to click on hyperlinks is all we're discussing.",
        "user": "UCUSW7WVD",
        "ts": "1688253408.334309",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a8O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where do you imagine the hyperlinks going to, other definitions? Many of my apps have that ability, Teliva and some of the Freewheeling stuff, and I'm wondering if the ability to click on hyperlinks is all we're discussing."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1688253643.000000"
        },
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "6edcf216-2f9c-49e9-83ca-68324449225f",
        "type": "message",
        "text": "Regarding the runtime execution of a program, the bottleneck is performance which feels orthogonal..",
        "user": "UCUSW7WVD",
        "ts": "1688253846.867889",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MgvR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Regarding the runtime execution of a program, the bottleneck is performance which feels orthogonal.."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1688254273.000000"
        },
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "cccc8c5e-e4e1-4ae5-9f32-8da75f73dec2",
        "type": "message",
        "text": "&gt; Where do you imagine the hyperlinks going to, other definitions?\nYes and also derived definitions (eg objects created via meta programming) and even runtime traces can link back to the definition objects.\n\n&gt; I\u2019m wondering if the ability to click on hyperlinks is all we\u2019re discussing.\nGood question. Clickable links between source definitions exist in many environments. Even vscode lets me do that with most of my programs. However this is typically implemented as a layer on top of the underlying media (text files). The links may not match always actual semantics, but more importantly they do not navigate to _derived_ definitions or connect runtime objects with definitions. In fact derived definitions are not typically available in the dev environment at all (smalltalk envs are the exception).\n\nThe idea is to use hypertext as a unifying interaction model between the person and the system - for hand written definitions, derived definitions as well as runtime traces. The hypertext ux would include clickable links and any other features we want to include eg inline content.",
        "user": "U8A5MS6R1",
        "ts": "1688258729.660449",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cnQLt",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where do you imagine the hyperlinks going to, other definitions?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes and also derived definitions (eg objects created via meta programming) and even runtime traces can link back to the definition objects.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m wondering if the ability to click on hyperlinks is all we\u2019re discussing."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good question. Clickable links between source definitions exist in many environments. Even vscode lets me do that with most of my programs. However this is typically implemented as a layer on top of the underlying media (text files). The links may not match always actual semantics, but more importantly they do not navigate to "
                            },
                            {
                                "type": "text",
                                "text": "derived",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " definitions or connect runtime objects with definitions. In fact derived definitions are not typically available in the dev environment at all (smalltalk envs are the exception).\n\nThe idea is to use hypertext as a unifying interaction model between the person and the system - for hand written definitions, derived definitions as well as runtime traces. The hypertext ux would include clickable links and any other features we want to include eg inline content."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "b5458dbd-f177-4561-ba90-e7c5e1cfaa23",
        "type": "message",
        "text": "I think I understand now. The runtime traces is hard to do performantly, but for everything else, yes this sounds like a nice reasonable goal. My stuff isn't it yet; you can't click on any function to go to its call, as a very basic example. The metaprogramming, I gather you want to be able to click on a macro call and see its expanded output. All this seems doable. I think I'm headed in a similar direction but wasn't aimed quite here. Now I might be. :thinking_face:",
        "user": "UCUSW7WVD",
        "ts": "1688260474.718849",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "198+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think I understand now. The runtime traces is hard to do performantly, but for everything else, yes this sounds like a nice reasonable goal. My stuff isn't it yet; you can't click on any function to go to its call, as a very basic example. The metaprogramming, I gather you want to be able to click on a macro call and see its expanded output. All this seems doable. I think I'm headed in a similar direction but wasn't aimed quite here. Now I might be. "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "5bb5728a-e502-47e3-bf55-27e786ab8dd1",
        "type": "message",
        "text": "FWIW: this idea fires a set of neurons in me, labelled \u201cGOTO\u201d.\n\n## Synopsis\nGOTO v1 - assembler GOTO\nGOTO v2 - message passing\nGOTO v3 - CPS - Continuation Passing Style\nGOTO v4 - URL\nAll versions of GOTO suffer from the problem of so-called \u201cstructured\u201d-ness.\n### Random Notes\n\u2022 Kinopio is GOTO v4\n\u2022 Message Passing is my current sweet spot.\n\u2022 most current *programming languages* are based on the Synchronous Pattern, i.e. they handle GOTO v1 and GOTO v3 but fumble GOTO v2 and GOTO v4.\n\u2022 \u201ccome from\u201d is just GOTO in reverse, i.e. *backlinks*\n### Lessons From Org Charts\n## Further Thoughts\n<https://publish.obsidian.md/programmingsimplicity/2023-07-01-GOTO>",
        "user": "UGWUJUZHT",
        "ts": "1688261232.042339",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IA7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW: this idea fires a set of neurons in me, labelled \u201cGOTO\u201d.\n\n## Synopsis\nGOTO v1 - assembler GOTO\nGOTO v2 - message passing\nGOTO v3 - CPS - Continuation Passing Style\nGOTO v4 - URL\nAll versions of GOTO suffer from the problem of so-called \u201cstructured\u201d-ness.\n### Random Notes\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Kinopio is GOTO v4"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Message Passing is my current sweet spot."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "most current "
                                    },
                                    {
                                        "type": "text",
                                        "text": "programming languages",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " are based on the Synchronous Pattern, i.e. they handle GOTO v1 and GOTO v3 but fumble GOTO v2 and GOTO v4."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201ccome from\u201d is just GOTO in reverse, i.e. "
                                    },
                                    {
                                        "type": "text",
                                        "text": "backlinks",
                                        "style": {
                                            "bold": true
                                        }
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "### Lessons From Org Charts\n## Further Thoughts\n"
                            },
                            {
                                "type": "link",
                                "url": "https://publish.obsidian.md/programmingsimplicity/2023-07-01-GOTO"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1688264067.000000"
        },
        "attachments": [
            {
                "from_url": "https://publish.obsidian.md/programmingsimplicity/2023-07-01-GOTO",
                "image_url": "https://ogimage.obsidian.md/og-image.png?title=2023-07-01-GOTO&description=%23+GOTO+GOTO+v1+-+assembler+GOTO+GOTO+v2+-+message+passing+GOTO+v3+-+CPS+-+Continuation+Passing+Style+GOTO+v4+-+URL+All+versions+of+GOTO+suffer+from+the+problem+of+so-called+%22structured%22-ness.++I+am+s%E2%80%A6",
                "image_width": 1200,
                "image_height": 630,
                "image_bytes": 48867,
                "id": 1,
                "original_url": "https://publish.obsidian.md/programmingsimplicity/2023-07-01-GOTO",
                "fallback": "2023-07-01-GOTO - Obsidian Publish",
                "text": "# GOTO GOTO v1 - assembler GOTO GOTO v2 - message passing GOTO v3 - CPS - Continuation Passing Style GOTO v4 - URL All versions of GOTO suffer from the problem of so-called \"structured\"-ness. I am s\u2026",
                "title": "2023-07-01-GOTO - Obsidian Publish",
                "title_link": "https://publish.obsidian.md/programmingsimplicity/2023-07-01-GOTO",
                "service_name": "publish.obsidian.md"
            }
        ],
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "8c0451d8-0350-43c7-8600-56235b5046ec",
        "type": "message",
        "text": "&gt; The runtime traces is hard to do performantly\nAgree. This could be opt-in via a debugging / \u201ccapture trace\u201d mode. Hypertext that links back to definitions seems better than explicit print style debugging.\n&gt; The metaprogramming, I gather you want to be able to click on a macro call and see its expanded output\nYes. I also think it would be nice to have the generated definitions available in searches. Derived definitions may also be produced from external schemas or import time execution.",
        "user": "U8A5MS6R1",
        "ts": "1688267306.869679",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fZbM8",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The runtime traces is hard to do performantly"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Agree. This could be opt-in via a debugging / \u201ccapture trace\u201d mode. Hypertext that links back to definitions seems better than explicit print style debugging.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The metaprogramming, I gather you want to be able to click on a macro call and see its expanded output"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes. I also think it would be nice to have the generated definitions available in searches. Derived definitions may also be produced from external schemas or import time execution."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "de070423-100a-483b-8a26-b2b0d051b05d",
        "type": "message",
        "text": "Paul - thanks for sharing. My initial thought is that what you are calling GOTOs I usually call forms of coupling. It\u2019s the essential quality of computers - specifically the couplings in the system simulate couplings in the real world or other models that we are trying to represent.\nI\u2019m not sure how URLs are v4 - I assume you mean some kind off identifier that represents a semantic concept (like in RDF?)",
        "user": "U8A5MS6R1",
        "ts": "1688268275.855239",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "12FPI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Paul - thanks for sharing. My initial thought is that what you are calling GOTOs I usually call forms of coupling. It\u2019s the essential quality of computers - specifically the couplings in the system simulate couplings in the real world or other models that we are trying to represent.\nI\u2019m not sure how URLs are v4 - I assume you mean some kind off identifier that represents a semantic concept (like in RDF?)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "63fb180a-4fef-41fd-a880-e839e622609b",
        "type": "message",
        "text": "&gt; I was thinking one aspect of code-as-hypertext is _earlier_ than usual binding.\nand then:\n&gt; However the bindings-as-written are not the final bindings.\nI am not sure I understand your bindings. Are they mutable or not? Or maybe mutable initially, then frozen?\n\nAs for GT, yes, it's a new tooling layer on top of a standard Pharo object graph. The bindings presented in the UI thus reflect the current state of the system, but everything can change at any time.\n\n&gt;  I was thinking why the method body is text and not hypertext?\nNames would then point to what? There is nothing but names and objects in the Smalltalk object graph (if you see literals as special names).\n\n&gt;  In fact derived definitions are not typically available in the dev environment at all (smalltalk envs are the exception).\nAnd the big practical issue in Smalltalk is that you get only the derived definitions, with no provenance tracking unless the metaprogramming framework has its own mechanism for that. But then, that's not a fundamental issue, it's part of the tooling layer.",
        "user": "UJBAJNFLK",
        "ts": "1688282392.993429",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gdNh",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was thinking one aspect of code-as-hypertext is "
                            },
                            {
                                "type": "text",
                                "text": "earlier",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " than usual binding."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and then:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "However the bindings-as-written are not the final bindings."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI am not sure I understand your bindings. Are they mutable or not? Or maybe mutable initially, then frozen?\n\nAs for GT, yes, it's a new tooling layer on top of a standard Pharo object graph. The bindings presented in the UI thus reflect the current state of the system, but everything can change at any time.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " I was thinking why the method body is text and not hypertext?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNames would then point to what? There is nothing but names and objects in the Smalltalk object graph (if you see literals as special names).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " In fact derived definitions are not typically available in the dev environment at all (smalltalk envs are the exception)."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAnd the big practical issue in Smalltalk is that you get only the derived definitions, with no provenance tracking unless the metaprogramming framework has its own mechanism for that. But then, that's not a fundamental issue, it's part of the tooling layer."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1688283446.000000"
        },
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "4e71e5d3-2766-4bbc-8663-9d3f4eb243ec",
        "type": "message",
        "text": "&gt; I am not sure I understand your bindings. Are they mutable or not? Or maybe mutable initially, then frozen?\nThis would be PL dependent but typically I imagine no in-place rebinding. However a form of rebinding happens by creating new versions of the hypertext objects. Eg the hand edited source objects could only be rebound by the user as part of editing. In the metaprogramming stage the system would create derived versions of these objects where some of the bindings have changed. For instance a binding to an abstract type in a source object may be resolved to a concrete subtype in the derived objects. So the PL semantics would also restrict what kinds of \u201crebindings\u201d happen. Eg \u201cconstants\u201d would be bindings that don\u2019t change in any derived objects.",
        "user": "U8A5MS6R1",
        "ts": "1688318668.116859",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pf8",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am not sure I understand your bindings. Are they mutable or not? Or maybe mutable initially, then frozen?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This would be PL dependent but typically I imagine no in-place rebinding. However a form of rebinding happens by creating new versions of the hypertext objects. Eg the hand edited source objects could only be rebound by the user as part of editing. In the metaprogramming stage the system would create derived versions of these objects where some of the bindings have changed. For instance a binding to an abstract type in a source object may be resolved to a concrete subtype in the derived objects. So the PL semantics would also restrict what kinds of \u201crebindings\u201d happen. Eg \u201cconstants\u201d would be bindings that don\u2019t change in any derived objects."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "496f3352-527a-4315-bf0c-783e8c1c8e94",
        "type": "message",
        "text": "I think you might run into situations where you want a thing to hyperlink to multiple possible targets. The current binding yes, but sometimes also the previous binding, or the previous edit. Or the edit history.\n\nDoes your point against `inline` apply also to the very idea of hypertext? Why does the writer need to create hyperlinks, can the reader just have tools for all these transforms? That's basically the world I live in today. My IDE takes me to a word's definition with F12, all its references with S-F12, all its callsites with C-k C-t. Perhaps we just need to do more of this?\n\nNow I want to link to an old thread of Lisp Machine screenshots, but it's sadly stuck in Twitter.",
        "user": "UCUSW7WVD",
        "ts": "1688319741.564619",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bWp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you might run into situations where you want a thing to hyperlink to multiple possible targets. The current binding yes, but sometimes also the previous binding, or the previous edit. Or the edit history.\n\nDoes your point against "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " apply also to the very idea of hypertext? Why does the writer need to create hyperlinks, can the reader just have tools for all these transforms? That's basically the world I live in today. My IDE takes me to a word's definition with F12, all its references with S-F12, all its callsites with C-k C-t. Perhaps we just need to do more of this?\n\nNow I want to link to an old thread of Lisp Machine screenshots, but it's sadly stuck in Twitter."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "db42c8a7-0b4c-4b9b-af6a-cc51f21e3ef9",
        "type": "message",
        "text": "&gt; I think you might run into situations where you want a thing to hyperlink to multiple possible targets.\nYes. I imagine viewing the source and various derived objects as distinct hypertext objects where you are able to go back and forth and follow the chain of provenance.\n\n&gt; Does your point against `inline` apply also to the very idea of hypertext? Why does the writer need to create hyperlinks, can the reader just have tools for all these transforms? That\u2019s basically the world I live in today.\nGood question. While it does bother me that the tooling overlaid links are an approximation (and poorer for dynamic langs generally), the bigger issue is the lack uniform navigation across derived definitions and source definitions.  I _want_ to see the rendered macro, the concretized generic method and so on. I want to deftly bounce between those and the original source definitions.\n\nBTW your earlier counterpoint of writer designed experience via `inline` is valid. I think the reader should still have the ability to customize it further (eg collapse an `inline`).\n\nA related point is that reader doesn\u2019t get to customize the text in text-file-as-code. For example if the writer chose to write `import pandas as pd`, the reader has no choice but to see `pd.foo` scattered across the file. If this was hypertext-as-code, it\u2019s easier for tools to offer customized rendering, eg \u201cshow the fully qualified name everywhere\u201d, or \u201cshow the short name, but blue for `pandas`\u201d and so on. In theory this is possible with text-file-as-code but more challenging, given that tooling is trying to simulate the PL semantics to extract high fidelity references.",
        "user": "U8A5MS6R1",
        "ts": "1688325171.005499",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I+p",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you might run into situations where you want a thing to hyperlink to multiple possible targets."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes. I imagine viewing the source and various derived objects as distinct hypertext objects where you are able to go back and forth and follow the chain of provenance.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does your point against "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " apply also to the very idea of hypertext? Why does the writer need to create hyperlinks, can the reader just have tools for all these transforms? That\u2019s basically the world I live in today."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good question. While it does bother me that the tooling overlaid links are an approximation (and poorer for dynamic langs generally), the bigger issue is the lack uniform navigation across derived definitions and source definitions.  I "
                            },
                            {
                                "type": "text",
                                "text": "want",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to see the rendered macro, the concretized generic method and so on. I want to deftly bounce between those and the original source definitions.\n\nBTW your earlier counterpoint of writer designed experience via "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is valid. I think the reader should still have the ability to customize it further (eg collapse an "
                            },
                            {
                                "type": "text",
                                "text": "inline",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ").\n\nA related point is that reader doesn\u2019t get to customize the text in text-file-as-code. For example if the writer chose to write "
                            },
                            {
                                "type": "text",
                                "text": "import pandas as pd",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the reader has no choice but to see "
                            },
                            {
                                "type": "text",
                                "text": "pd.foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " scattered across the file. If this was hypertext-as-code, it\u2019s easier for tools to offer customized rendering, eg \u201cshow the fully qualified name everywhere\u201d, or \u201cshow the short name, but blue for "
                            },
                            {
                                "type": "text",
                                "text": "pandas",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u201d and so on. In theory this is possible with text-file-as-code but more challenging, given that tooling is trying to simulate the PL semantics to extract high fidelity references."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1688325307.000000"
        },
        "thread_ts": "1688176784.223859",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]