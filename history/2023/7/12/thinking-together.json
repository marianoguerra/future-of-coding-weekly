[
    {
        "client_msg_id": "1c56843d-b019-4253-99f1-34e4e7ad47f9",
        "type": "message",
        "text": "*What we talk about when we talk about expressivity*\n\nI enjoyed the little tangent on expressivity in the latest episode. I've had thoughts on this recently and it prompted me to skim Felleisen's paper. I really resonated with the hosts' reframing of expressivity as being the part of the language that's oriented towards the programmer, not towards the machine.\n\nI currently think that most programmers, when talking about \"expressivity\", actually mean essentially two things:\n\n1. I can use my own words\n2. I am not restricted by grammar\nThese things are strongly tied to writing, as that's still how we do most of our coding.\n\n\"Using my own words\" is literally that - in any given chunk of source text, how many of the words were chosen by the programmer (e.g. to be particular to their domain or their theory of the program) and how many were specified by the language or environment? Punctuation, I think, also counts as words the programmer didn't get to choose. Random examples:\n\n\u2022 In Ruby, one can create little DSLs where almost all words in a specific part of the code are \"my own words\"\n\u2022 In assembly languages, the programmer can choose almost none of the words (except labels?)\n\u2022 Being able to rename imported symbols lets the programmer choose their own words in specific contexts (same goes for type aliases, etc.)\n\u2022 Languages with few keywords should tend to have more words chosen by the programmer... or at least, by the authors of the standard library?\nI equate being \"unrestricted by grammar\" roughly to whether a language is statement-oriented or expression-oriented. The Austral spec has a great section on why it chose to be statement-oriented, and concludes that \"a statement-oriented syntax is less simple, but it forces code to be structurally simple\": <https://austral-lang.org/spec/spec.html#stmt-orientation>\n\nIn Austral, it's an ideological choice to force programs into a certain shape. But in general, it seems to me that languages with less \"grammatical restrictions\" in their parser are described as more expressive. Maybe this is just correlation with other features of those languages.\n\nI'd love to know how everyone else understands \"expressivitiy\" when we talk about programming.",
        "user": "U05597GCDDK",
        "ts": "1689118227.745139",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FSLQV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What we talk about when we talk about expressivity",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nI enjoyed the little tangent on expressivity in the latest episode. I've had thoughts on this recently and it prompted me to skim Felleisen's paper. I really resonated with the hosts' reframing of expressivity as being the part of the language that's oriented towards the programmer, not towards the machine.\n\nI currently think that most programmers, when talking about \"expressivity\", actually mean essentially two things:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I can use my own words"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I am not restricted by grammar"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThese things are strongly tied to writing, as that's still how we do most of our coding.\n\n\"Using my own words\" is literally that - in any given chunk of source text, how many of the words were chosen by the programmer (e.g. to be particular to their domain or their theory of the program) and how many were specified by the language or environment? Punctuation, I think, also counts as words the programmer didn't get to choose. Random examples:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In Ruby, one can create little DSLs where almost all words in a specific part of the code are \"my own words\""
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In assembly languages, the programmer can choose almost none of the words (except labels?)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Being able to rename imported symbols lets the programmer choose their own words in specific contexts (same goes for type aliases, etc.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Languages with few keywords should tend to have more words chosen by the programmer... or at least, by the authors of the standard library?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI equate being \"unrestricted by grammar\" roughly to whether a language is statement-oriented or expression-oriented. The Austral spec has a great section on why it chose to be statement-oriented, and concludes that \"a statement-oriented syntax is less simple, but it forces code to be structurally simple\": "
                            },
                            {
                                "type": "link",
                                "url": "https://austral-lang.org/spec/spec.html#stmt-orientation"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIn Austral, it's an ideological choice to force programs into a certain shape. But in general, it seems to me that languages with less \"grammatical restrictions\" in their parser are described as more expressive. Maybe this is just correlation with other features of those languages.\n\nI'd love to know how everyone else understands \"expressivitiy\" when we talk about programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U05597GCDDK",
            "ts": "1689119389.000000"
        },
        "thread_ts": "1689118227.745139",
        "reply_count": 23,
        "reply_users_count": 7,
        "latest_reply": "1689427049.380399",
        "reply_users": [
            "U013WBS1B1C",
            "UE6EFEPTQ",
            "UJBAJNFLK",
            "UK3LH8CF5",
            "U016VUZGUUQ",
            "U04E5QAD6DD",
            "U03LJBR6THT"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "b7df254c-643d-4386-84e9-7427885f64a8",
        "type": "message",
        "text": "There's a risk I'll go on for a long time. :^)\n\nI work on Red (<http://red-lang.org|red-lang.org>), a descendant of Rebol, which was inspired by Lisp/Forth/Logo. A key point in Carl Sassenrath's design of Rebol was that it was first a messaging language; a data format. Secondarily, you could interpret it to make stuff happen.\n\nTo the first point, everything is data, so the number of lexical forms is very high compared to most langs. But the number of keywords is zero. Yes, in a standard environment there will be a lot of words you expect to be there, and work in a certain way. But you *can* break or enhance the system by altering them.\n\nAnother key feature in standard Red is the `parse` function, which makes it relatively easy to write BNF-like PEG grammars to build dialects (eDSLs). Not only at the string/char level, but at the value level, because everything is data once loaded from text.\n\nAll those lexical forms (and also standard types that don't have a literal syntax) can be used in your dialects. This makes for a very flexible and powerful \"language construction toolkit\", which is how I sometimes describe Red. And to bring it full meta-circle, `parse` and other features are dialects, as is the low level `Red/System` language, a C-level language that shares syntax, but not semantics, with Red and is used to write the runtime for performance reasons (it compiles to machine code). e.g. it's static and lacks most high level datatypes. Red also has a GUI dialect.\n\nNow, for how expressive this all is...I'm biased, but there *is* an aspect that *isn't* very flexible: lexical forms (literal syntax for values). You have to hack the lexer and add new types for that, which is by design. Why not make it easy? Back to Red being a messaging language. In the context of data exchange, you need to agree on the basic language elements.\n\nFormatting is another facet of expressivity. Consider poetry, free verse versus something like a pantoum or sestina, which are very rigid forms. This relates to both form and function for PLs. Whitespace, line breaks, statement-ending punctuation, all effect how you write for your readers, and perhaps how susceptible things are to (un)intentional corruption. e.g., you can't strip spaces and lines from a Python program. On the function side, we veer into static/dynamic aspects.\n\nThe less rules you have, the more expressive you can be. Consider art. What you gain in expressive freedom, you may give up in appreciation. Constraints are important, but also contextual. Can you have an effective fully expressive GPL? Or to get that (ASM) do you give up too much \"appreciation\", because we also *have to* share, communicate about, and understand these works we craft.\n\nPersonally, I think we have to balance things based on context. Be as flexible and expressive as possible, in the target domain, to the point where any more leads to less benefit and more cost for target users. Please some of the people, most of the time.",
        "user": "U013WBS1B1C",
        "ts": "1689127730.508099",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kaiV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's a risk I'll go on for a long time. :^)\n\nI work on Red ("
                            },
                            {
                                "type": "link",
                                "url": "http://red-lang.org",
                                "text": "red-lang.org"
                            },
                            {
                                "type": "text",
                                "text": "), a descendant of Rebol, which was inspired by Lisp/Forth/Logo. A key point in Carl Sassenrath's design of Rebol was that it was first a messaging language; a data format. Secondarily, you could interpret it to make stuff happen.\n\nTo the first point, everything is data, so the number of lexical forms is very high compared to most langs. But the number of keywords is zero. Yes, in a standard environment there will be a lot of words you expect to be there, and work in a certain way. But you "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " break or enhance the system by altering them.\n\nAnother key feature in standard Red is the "
                            },
                            {
                                "type": "text",
                                "text": "parse",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " function, which makes it relatively easy to write BNF-like PEG grammars to build dialects (eDSLs). Not only at the string/char level, but at the value level, because everything is data once loaded from text.\n\nAll those lexical forms (and also standard types that don't have a literal syntax) can be used in your dialects. This makes for a very flexible and powerful \"language construction toolkit\", which is how I sometimes describe Red. And to bring it full meta-circle, "
                            },
                            {
                                "type": "text",
                                "text": "parse",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and other features are dialects, as is the low level "
                            },
                            {
                                "type": "text",
                                "text": "Red/System",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " language, a C-level language that shares syntax, but not semantics, with Red and is used to write the runtime for performance reasons (it compiles to machine code). e.g. it's static and lacks most high level datatypes. Red also has a GUI dialect.\n\nNow, for how expressive this all is...I'm biased, but there "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " an aspect that "
                            },
                            {
                                "type": "text",
                                "text": "isn't",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " very flexible: lexical forms (literal syntax for values). You have to hack the lexer and add new types for that, which is by design. Why not make it easy? Back to Red being a messaging language. In the context of data exchange, you need to agree on the basic language elements.\n\nFormatting is another facet of expressivity. Consider poetry, free verse versus something like a pantoum or sestina, which are very rigid forms. This relates to both form and function for PLs. Whitespace, line breaks, statement-ending punctuation, all effect how you write for your readers, and perhaps how susceptible things are to (un)intentional corruption. e.g., you can't strip spaces and lines from a Python program. On the function side, we veer into static/dynamic aspects.\n\nThe less rules you have, the more expressive you can be. Consider art. What you gain in expressive freedom, you may give up in appreciation. Constraints are important, but also contextual. Can you have an effective fully expressive GPL? Or to get that (ASM) do you give up too much \"appreciation\", because we also "
                            },
                            {
                                "type": "text",
                                "text": "have to",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " share, communicate about, and understand these works we craft.\n\nPersonally, I think we have to balance things based on context. Be as flexible and expressive as possible, in the target domain, to the point where any more leads to less benefit and more cost for target users. Please some of the people, most of the time."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8aa4c62d-0e9b-417f-bbd9-686884cfd517",
        "type": "message",
        "text": "I warned you. :^)",
        "user": "U013WBS1B1C",
        "ts": "1689127787.195669",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5cDA8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I warned you. :^)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "boom",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "00df345a-6a65-4ba6-93d9-915f7f6fd354",
        "type": "message",
        "text": "I'll let everyone read both above long posts before adding my own take, but briefly, I'm a secret fan of Red/Rebol as my own lang shares much with it/them. I have type=grammar for both inline small types and whole objects.",
        "user": "UE6EFEPTQ",
        "ts": "1689148319.568939",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1LK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll let everyone read both above long posts before adding my own take, but briefly, I'm a secret fan of Red/Rebol as my own lang shares much with it/them. I have type=grammar for both inline small types and whole objects."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "2d86eadd-b607-45de-9af7-966155c570b3",
        "type": "message",
        "text": "Rebol and descendents are something I have been looking at as well every now and then. Red seems to be the most active project in this space right now. Another one that seems stuck in an early design phase is <https://altscript.com/>. But there is nothing I see as good enough for actually playing with at this time.",
        "user": "UJBAJNFLK",
        "ts": "1689151304.101499",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iZYC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rebol and descendents are something I have been looking at as well every now and then. Red seems to be the most active project in this space right now. Another one that seems stuck in an early design phase is "
                            },
                            {
                                "type": "link",
                                "url": "https://altscript.com/"
                            },
                            {
                                "type": "text",
                                "text": ". But there is nothing I see as good enough for actually playing with at this time."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "c4c464ab-8262-4793-9729-6b4185e2fcb5",
        "type": "message",
        "text": "<@U05597GCDDK> Glad you enjoyed the discussion. I definitely think you've hit on some really important aspects of expressivity.  I do think it is a complicated subject and hard to pin down exactly what we want to say it is.\n\nOn one hand expressivity is how we say something, your \"Using my own words\" on the other hand it is also about what can be said. A DSL would then be more expressive in the \"Using my own words\" sense, but less expressive in what can be said.\n\nTo me an expressive language works on both of these aspects. It allows me to express things the way I might want them to, but also allows me to express more kinds of things. Depending on my interests and contexts those kinds of things might change. So I don't think we can make a total order out of expressivity in languages.\n\nFor example, if we compare Haskell and Idris, I can express types in Idris that I can't (without contortions) in Haskell. I am able to represent the type of printf in the language itself in a very clear and concise way.\n\nBut when we compare lisp and Idris things are a bit confusing. Lisp does not have the kind of type system does. So for example, I can't express things things like \"this function is total\" in the way I can in Idris, but I also can express complex macros and have fewer limits on the kinds of things I can express because I lack that type system.\n\nC feels less expressive than Java say, but I can express things about memory layout and allocation that I can't (easily) in Java.\n\nI think this is what make expressivity so hard. Gaining to the ability to express something can restrict some other aspects.",
        "user": "UK3LH8CF5",
        "ts": "1689178546.327129",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wFMYi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U05597GCDDK"
                            },
                            {
                                "type": "text",
                                "text": " Glad you enjoyed the discussion. I definitely think you've hit on some really important aspects of expressivity.  I do think it is a complicated subject and hard to pin down exactly what we want to say it is.\n\nOn one hand expressivity is how we say something, your \"Using my own words\" on the other hand it is also about what can be said. A DSL would then be more expressive in the \"Using my own words\" sense, but less expressive in what can be said.\n\nTo me an expressive language works on both of these aspects. It allows me to express things the way I might want them to, but also allows me to express more kinds of things. Depending on my interests and contexts those kinds of things might change. So I don't think we can make a total order out of expressivity in languages.\n\nFor example, if we compare Haskell and Idris, I can express types in Idris that I can't (without contortions) in Haskell. I am able to represent the type of printf in the language itself in a very clear and concise way.\n\nBut when we compare lisp and Idris things are a bit confusing. Lisp does not have the kind of type system does. So for example, I can't express things things like \"this function is total\" in the way I can in Idris, but I also can express complex macros and have fewer limits on the kinds of things I can express because I lack that type system.\n\nC feels less expressive than Java say, but I can express things about memory layout and allocation that I can't (easily) in Java.\n\nI think this is what make expressivity so hard. Gaining to the ability to express something can restrict some other aspects."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U016VUZGUUQ",
                    "U013WBS1B1C"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f2bc14d2-5d6b-4d16-9303-d57b95ef16b9",
        "type": "message",
        "text": "<@U013WBS1B1C> Super interested in Red/Rebol. Though I haven't written much/any. It's definitely a tradition that doesn't get much attention.Any good texts on it that we should read?",
        "user": "UK3LH8CF5",
        "ts": "1689178590.934669",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5cl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013WBS1B1C"
                            },
                            {
                                "type": "text",
                                "text": " Super interested in Red/Rebol. Though I haven't written much/any. It's definitely a tradition that doesn't get much attention.Any good texts on it that we should read?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "90f13739-a24d-410b-a3cf-22c31eb2ea17",
        "type": "message",
        "text": "My best shot at defining expressivity is in terms of some abstract space of logical relations/structures. The elements to be related include types, machine details, phase distinctions, etc, as well as elements of your application domain.\n\nA more expressive language is one that can span more of this space. To the extent that languages cover (roughly) the same space, you can rank them by (roughly average) concision. We can recover notions like C being more expressive for machine details, or a DSL being more expressive for a given domain, by restricting the logical space we're considering.\n\nIt gets tricky, though, because you're probably talking about Turing complete languages that can all simulate each other, and just ranking by concision doesn't quite capture the notion that writing a simulator doesn't \"count\" as expressing it; even if you could write a logical inference engine in five lines of C, that doesn't change the intuitive notion that Prolog is more expressive for certain problems. You want a notion of \"direct expression\" that's not covered by concision. Maybe something to do with (cyclomatic?) complexity of the code to express a given thing?",
        "user": "U016VUZGUUQ",
        "ts": "1689181906.161099",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MK4V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My best shot at defining expressivity is in terms of some abstract space of logical relations/structures. The elements to be related include types, machine details, phase distinctions, etc, as well as elements of your application domain.\n\nA more expressive language is one that can span more of this space. To the extent that languages cover (roughly) the same space, you can rank them by (roughly average) concision. We can recover notions like C being more expressive for machine details, or a DSL being more expressive for a given domain, by restricting the logical space we're considering.\n\nIt gets tricky, though, because you're probably talking about Turing complete languages that can all simulate each other, and just ranking by concision doesn't quite capture the notion that writing a simulator doesn't \"count\" as expressing it; even if you could write a logical inference engine in five lines of C, that doesn't change the intuitive notion that Prolog is more expressive for certain problems. You want a notion of \"direct expression\" that's not covered by concision. Maybe something to do with (cyclomatic?) complexity of the code to express a given thing?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "06e21dea-63d3-4af7-b325-02d04442e691",
        "type": "message",
        "text": "The old Rebol core guide (<http://www.rebol.com/docs/core23/rebolcore.html>) is still a seminal reference for the language. <http://www.rebol.com/docs.html> links to some other primer bits. Red's reference docs are [here](<https://github.com/red/docs/tree/master/en>) but not in User Guide form for learning. A Red user has written <https://helpin.red/>. You can also scan the old blog entries at <https://www.red-lang.org/> for Red-specific features.\n\nThere are a few other langs out there with the same heritage, which we sometimes call Redbol as a \"genre\". :^)",
        "user": "U013WBS1B1C",
        "ts": "1689191089.737759",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V4SP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The old Rebol core guide ("
                            },
                            {
                                "type": "link",
                                "url": "http://www.rebol.com/docs/core23/rebolcore.html"
                            },
                            {
                                "type": "text",
                                "text": ") is still a seminal reference for the language. "
                            },
                            {
                                "type": "link",
                                "url": "http://www.rebol.com/docs.html"
                            },
                            {
                                "type": "text",
                                "text": " links to some other primer bits. Red's reference docs are [here]("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/red/docs/tree/master/en"
                            },
                            {
                                "type": "text",
                                "text": ") but not in User Guide form for learning. A Red user has written "
                            },
                            {
                                "type": "link",
                                "url": "https://helpin.red/"
                            },
                            {
                                "type": "text",
                                "text": ". You can also scan the old blog entries at "
                            },
                            {
                                "type": "link",
                                "url": "https://www.red-lang.org/"
                            },
                            {
                                "type": "text",
                                "text": " for Red-specific features.\n\nThere are a few other langs out there with the same heritage, which we sometimes call Redbol as a \"genre\". :^)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "http://www.rebol.com/docs.html",
                "service_icon": "http://www.rebol.com/favicon.ico",
                "id": 1,
                "original_url": "http://www.rebol.com/docs.html",
                "fallback": "REBOL Documentation",
                "text": "Links to all documentation, including tutorials, examples, manuals, and references.",
                "title": "REBOL Documentation",
                "title_link": "http://www.rebol.com/docs.html",
                "service_name": "rebol.com"
            }
        ],
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U04E5QAD6DD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6d6849ad-c7c9-4434-ab25-110218e2b33d",
        "type": "message",
        "text": "Thanks definitely helpful. I'm mostly interesting in something a bit more meta/philosophical on the perspective. Like a paper giving the why of Rebol like languages.",
        "user": "UK3LH8CF5",
        "ts": "1689191258.868469",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YmAw=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks definitely helpful. I'm mostly interesting in something a bit more meta/philosophical on the perspective. Like a paper giving the why of Rebol like languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "17108742-9287-4f36-bb5e-dabf057bada3",
        "type": "message",
        "text": "<@UJBAJNFLK> we don't know if Carl will continue with AltScript or not. He tends to disappear into his cave for long stretches. :^) Rebol2 (R2) was closed source, but Rebol3 (R3) was done quickly by Carl and a few others to make a FOSS version. It's still alive as well. Where Rebol is written in C at the low level, Red was bootstrapped on R2 and is designed to be self-hosted, hence the need for Red/System.",
        "user": "U013WBS1B1C",
        "ts": "1689191376.962689",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V=Ao",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " we don't know if Carl will continue with AltScript or not. He tends to disappear into his cave for long stretches. :^) Rebol2 (R2) was closed source, but Rebol3 (R3) was done quickly by Carl and a few others to make a FOSS version. It's still alive as well. Where Rebol is written in C at the low level, Red was bootstrapped on R2 and is designed to be self-hosted, hence the need for Red/System."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "ee5d79fb-9956-4d08-b780-e07585eb85bd",
        "type": "message",
        "text": "If we go Rich Hickey on this: *expressive* - Effectively conveying thought or feeling.\n\nTo <@UK3LH8CF5>\u2019s point, a language might be expressive in terms of type systems, but not at all able to express a GUI.\n\nWe also have limits, which tooling can help us overcome. For example, in a low level language, you may want/need to express multiple integer types by size and signing ability, but no strings. In an HLL, you just need `number` but have many types of strings (plain, filename, email address, url, tag, etc.). Maybe you justify a Cartesian coordinate type, but not UTM coordinates for mapping projections. How do we keep from being overwhelmed, while being able to express things (thinking text here) as we do with natural language?",
        "user": "U013WBS1B1C",
        "ts": "1689192276.153629",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=rl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If we go Rich Hickey on this: "
                            },
                            {
                                "type": "text",
                                "text": "expressive",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - Effectively conveying thought or feeling.\n\nTo "
                            },
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": "\u2019s point, a language might be expressive in terms of type systems, but not at all able to express a GUI.\n\nWe also have limits, which tooling can help us overcome. For example, in a low level language, you may want/need to express multiple integer types by size and signing ability, but no strings. In an HLL, you just need "
                            },
                            {
                                "type": "text",
                                "text": "number",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but have many types of strings (plain, filename, email address, url, tag, etc.). Maybe you justify a Cartesian coordinate type, but not UTM coordinates for mapping projections. How do we keep from being overwhelmed, while being able to express things (thinking text here) as we do with natural language?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "d307b878-a1cf-4317-b35d-26c59f59fb23",
        "type": "message",
        "text": "The why: Rebol was designed for the semantic exchange of information between people and machines.\n\nThat's why there are so many datatypes with literal forms. Because we need them to talk about things easily, both on the human and the machine side.\n\nOn the philosophy of Redbol, that's quite unfortunately strewn throughout time and space. I can say that Carl spent 20 years *designing* Rebol, after deep study of denotational semantics, before building and releasing it. The first version was done in Scheme, but was too slow. He had built things using many paradigms, and rejected OO as the answer after trying it. I can't speak for him, but his designs say he values simplicity and will give up other things for that. He also values the human side which is why while Rebol is a totally wacky language internally, when compared to how other langs work, there is this lovely, simple fa\u00e7ade that lets you wade in comfortably for a while (or forever) before you fall off the edge and into the deep.\n\nFor this chat, Red is expressive in different ways to different people. To a high level user, it's a single EXE with a built-in GUI system, compiles standalone EXEs without any external tools, and is easy to learn. To a PL enthusiast, it's Logo (Lisp without parens) that uses definitional scoping, f-exprs, and free ranging evaluation. Each word is bound to a context and there is really no such thing as \"code\". There is only data that is evaluated. See: [this](<https://github.com/red/red/wiki/%5BDOC%5D-Why-you-have-to-copy-series-values#a-designers-view>)\n\nI could say it's a contradiction in terms, but it's probably just as accurate to say \"Old School\". :^)",
        "user": "U013WBS1B1C",
        "ts": "1689193594.843739",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lCmL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The why: Rebol was designed for the semantic exchange of information between people and machines.\n\nThat's why there are so many datatypes with literal forms. Because we need them to talk about things easily, both on the human and the machine side.\n\nOn the philosophy of Redbol, that's quite unfortunately strewn throughout time and space. I can say that Carl spent 20 years "
                            },
                            {
                                "type": "text",
                                "text": "designing",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Rebol, after deep study of denotational semantics, before building and releasing it. The first version was done in Scheme, but was too slow. He had built things using many paradigms, and rejected OO as the answer after trying it. I can't speak for him, but his designs say he values simplicity and will give up other things for that. He also values the human side which is why while Rebol is a totally wacky language internally, when compared to how other langs work, there is this lovely, simple fa\u00e7ade that lets you wade in comfortably for a while (or forever) before you fall off the edge and into the deep.\n\nFor this chat, Red is expressive in different ways to different people. To a high level user, it's a single EXE with a built-in GUI system, compiles standalone EXEs without any external tools, and is easy to learn. To a PL enthusiast, it's Logo (Lisp without parens) that uses definitional scoping, f-exprs, and free ranging evaluation. Each word is bound to a context and there is really no such thing as \"code\". There is only data that is evaluated. See: [this]("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/red/red/wiki/%5BDOC%5D-Why-you-have-to-copy-series-values#a-designers-view"
                            },
                            {
                                "type": "text",
                                "text": ")\n\nI could say it's a contradiction in terms, but it's probably just as accurate to say \"Old School\". :^)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U04E5QAD6DD"
                ],
                "count": 1
            },
            {
                "name": "beers",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5312c0da-8adc-43c7-aecb-fb4a89a110ab",
        "type": "message",
        "text": "<@U013WBS1B1C> What's the best way to try Red on Apple Silicon? I tried the macOS download on the website, but I got \"\u201c<http://red-view-12jul23-aea09888d.app|red-view-12jul23-aea09888d.app>\u201d needs to be updated.\". Maybe I should just pull out a Raspberry Pi\u2026",
        "user": "U04E5QAD6DD",
        "ts": "1689210689.961569",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hp8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013WBS1B1C"
                            },
                            {
                                "type": "text",
                                "text": " What's the best way to try Red on Apple Silicon? I tried the macOS download on the website, but I got \"\u201cred-view-12jul23-aea09888d.app\u201d needs to be updated.\". Maybe I should just pull out a Raspberry Pi\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "a5acd5bd-6f80-497a-a612-c4b0a9f14802",
        "type": "message",
        "text": "Red is currently 32-bit only, so no latest MacOS, and also no Apple silicon support. The downside of being your own toolchain.",
        "user": "U013WBS1B1C",
        "ts": "1689225498.782189",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O2h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Red is currently 32-bit only, so no latest MacOS, and also no Apple silicon support. The downside of being your own toolchain."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013WBS1B1C",
            "ts": "1689225517.000000"
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "e0c68c7b-a5e8-4b91-95b5-24dfbe829bd5",
        "type": "message",
        "text": "Darn. But makes sense. Thanks!",
        "user": "U04E5QAD6DD",
        "ts": "1689252225.662369",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+zk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Darn. But makes sense. Thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "29642566-253b-4186-b21e-6bf2fcdc9552",
        "type": "message",
        "text": "&gt; I enjoyed the little tangent on expressivity in the latest episode. I've had thoughts on this recently and it prompted me to skim Felleisen's paper. I really resonated with the hosts' reframing of expressivity as being the part of the language that's oriented towards the programmer, not towards the machine.\nMany decades ago I coined the acronym \"DTIL\" or Domain and Target Independent Language, to clarify what I was seeking in my Perfect Programming Language. Meaning: a language that's not in any way constrained by the machine (the Target) OR the Domain of application. A pure language of thought. A language that allows expression by humans in their most intuitive way of what they wanted the computer to manifest for them. So a cognitive-oriented programming language, but I was only allowing a formalism or symbolic mechanism, rather than in any way a natural language, which I saw as redundancy-heavy and fuzzy.\n\nDeclarative languages immediately stood out and wiped out Imperative languages for me, as these had too much Target (machine) orientation. The Declarative mantra \"What not How\" gives it away: just say What you want, don't tell the machine laboriously How to do it.\n\n&gt; I currently think that most programmers, when talking about \"expressivity\", actually mean essentially two things:\n&gt; 1. I can use my own words\n&gt; 2. I am not restricted by grammar\n&gt; \n&gt; These things are strongly tied to writing, as that's still how we do most of our coding.\nHmm, then that's \"just\" asking ChatGPT!\n\n&gt; \"Using my own words\" is literally that - in any given chunk of source text, how many of the words were chosen by the programmer (e.g. to be particular to their domain or their theory of the program) and how many were specified by the language or environment? Punctuation, I think, also counts as words the programmer didn't get to choose. Random examples:\n&gt; \u2022 In Ruby, one can create little DSLs where almost all words in a specific part of the code are \"my own words\"\n&gt; \u2022 In assembly languages, the programmer can choose almost none of the words (except labels?)\n&gt; \u2022 Being able to rename imported symbols lets the programmer choose their own words in specific contexts (same goes for type aliases, etc.)\n&gt; \u2022 Languages with few keywords should tend to have more words chosen by the programmer... or at least, by the authors of the standard library?\nIt's important in a DTIL that the mechanisms available are pure and singular: there should be only one language representation of each cognitive entity and nothing that biases the language to either a machine or a domain. Ideally the whole base syntax should be just half a dozen unique things (like symbol, sequence, structure, consequence).\n\nAn important aspect of this whole conception is that data should be simply strings or text and structures of that. If you have a \"double\" - rather than a \"float\" or \"int\"- you're immediately binding yourself to machine concepts, as provided to you by the FPU. In reality, humans don't think like that, we simply write our \"data\" in text. So spreadsheets and Awk have some precedent there.\n\nThis leads to the (apparently radical) concept of type being simply syntax: if you parse a string or structure in a way that's meaningful to you, you've made your own type matcher and thus your own type. You don't have to be bound by the types in the mind of the originator of some data, or by the types the machine supports best.\n\n&gt; I equate being \"unrestricted by grammar\" roughly to whether a language is statement-oriented or expression-oriented. The Austral spec has a great section on why it chose to be statement-oriented, and concludes that \"a statement-oriented syntax is less simple, but it forces code to be structurally simple\": <https://austral-lang.org/spec/spec.html#stmt-orientation>\n&gt; \n&gt; In Austral, it's an ideological choice to force programs into a certain shape. But in general, it seems to me that languages with less \"grammatical restrictions\" in their parser are described as more expressive. Maybe this is just correlation with other features of those languages.\nNot sure about the statement- vs expression-oriented thing, but again, simplicity and power are key to maximising human expression of virtual stuff and their desired behaviours.",
        "user": "UE6EFEPTQ",
        "ts": "1689286791.149829",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a21",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I enjoyed the little tangent on expressivity in the latest episode. I've had thoughts on this recently and it prompted me to skim Felleisen's paper. I really resonated with the hosts' reframing of expressivity as being the part of the language that's oriented towards the programmer, not towards the machine."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nMany decades ago I coined the acronym \"DTIL\" or Domain and Target Independent Language, to clarify what I was seeking in my Perfect Programming Language. Meaning: a language that's not in any way constrained by the machine (the Target) OR the Domain of application. A pure language of thought. A language that allows expression by humans in their most intuitive way of what they wanted the computer to manifest for them. So a cognitive-oriented programming language, but I was only allowing a formalism or symbolic mechanism, rather than in any way a natural language, which I saw as redundancy-heavy and fuzzy.\n\nDeclarative languages immediately stood out and wiped out Imperative languages for me, as these had too much Target (machine) orientation. The Declarative mantra \"What not How\" gives it away: just say What you want, don't tell the machine laboriously How to do it.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I currently think that most programmers, when talking about \"expressivity\", actually mean essentially two things:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I can use my own words"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I am not restricted by grammar"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThese things are strongly tied to writing, as that's still how we do most of our coding."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nHmm, then that's \"just\" asking ChatGPT!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Using my own words\" is literally that - in any given chunk of source text, how many of the words were chosen by the programmer (e.g. to be particular to their domain or their theory of the program) and how many were specified by the language or environment? Punctuation, I think, also counts as words the programmer didn't get to choose. Random examples:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In Ruby, one can create little DSLs where almost all words in a specific part of the code are \"my own words\""
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In assembly languages, the programmer can choose almost none of the words (except labels?)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Being able to rename imported symbols lets the programmer choose their own words in specific contexts (same goes for type aliases, etc.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Languages with few keywords should tend to have more words chosen by the programmer... or at least, by the authors of the standard library?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt's important in a DTIL that the mechanisms available are pure and singular: there should be only one language representation of each cognitive entity and nothing that biases the language to either a machine or a domain. Ideally the whole base syntax should be just half a dozen unique things (like symbol, sequence, structure, consequence).\n\nAn important aspect of this whole conception is that data should be simply strings or text and structures of that. If you have a \"double\" - rather than a \"float\" or \"int\"- you're immediately binding yourself to machine concepts, as provided to you by the FPU. In reality, humans don't think like that, we simply write our \"data\" in text. So spreadsheets and Awk have some precedent there.\n\nThis leads to the (apparently radical) concept of type being simply syntax: if you parse a string or structure in a way that's meaningful to you, you've made your own type matcher and thus your own type. You don't have to be bound by the types in the mind of the originator of some data, or by the types the machine supports best.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I equate being \"unrestricted by grammar\" roughly to whether a language is statement-oriented or expression-oriented. The Austral spec has a great section on why it chose to be statement-oriented, and concludes that \"a statement-oriented syntax is less simple, but it forces code to be structurally simple\": "
                            },
                            {
                                "type": "link",
                                "url": "https://austral-lang.org/spec/spec.html#stmt-orientation"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIn Austral, it's an ideological choice to force programs into a certain shape. But in general, it seems to me that languages with less \"grammatical restrictions\" in their parser are described as more expressive. Maybe this is just correlation with other features of those languages."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNot sure about the statement- vs expression-oriented thing, but again, simplicity and power are key to maximising human expression of virtual stuff and their desired behaviours."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1689286841.000000"
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "ee7fd4bb-093a-4904-93e3-00757bc05cd6",
        "type": "message",
        "text": "Grand Plans, but over 4 decades later I'm still working on it! :smile:",
        "user": "UE6EFEPTQ",
        "ts": "1689286973.508699",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rs1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Grand Plans, but over 4 decades later I'm still working on it! "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "e85e8344-b8c7-488e-9c3b-4dabcf4704bc",
        "type": "message",
        "text": "It was kinda spooky when the phrase \"DSL\" appeared, and of course I immediately knew it would be anything I wanted!",
        "user": "UE6EFEPTQ",
        "ts": "1689287064.559459",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gq3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It was kinda spooky when the phrase \"DSL\" appeared, and of course I immediately knew it would be anything I wanted!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "901e93f3-f942-443e-890e-6b3998b051b3",
        "type": "message",
        "text": "Thanks <@U013WBS1B1C> for the links to and the background of Rebol/Red!\n\n&gt; How do we keep from being overwhelmed, while being able to express things (thinking text here) as we do with natural language?\nThe comparison with natural language is difficult. Natural language serves for informal, i.e. context-dependent, reasoning. It's OK to have the same terms refer to different meanings in different contexts. In a formal language, everything needs to be explicit and non-ambiguous. So I guess different but similar-in-spirit and interoperable languages are probably our best bet. That's something I think Red got right. As did Racket (although it lacks the system layer for now).",
        "user": "UJBAJNFLK",
        "ts": "1689326858.826909",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ASG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "U013WBS1B1C"
                            },
                            {
                                "type": "text",
                                "text": " for the links to and the background of Rebol/Red!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How do we keep from being overwhelmed, while being able to express things (thinking text here) as we do with natural language?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The comparison with natural language is difficult. Natural language serves for informal, i.e. context-dependent, reasoning. It's OK to have the same terms refer to different meanings in different contexts. In a formal language, everything needs to be explicit and non-ambiguous. So I guess different but similar-in-spirit and interoperable languages are probably our best bet. That's something I think Red got right. As did Racket (although it lacks the system layer for now)."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1689326901.000000"
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "16C91914-D694-48B2-84FC-6C6B398CDA43",
        "type": "message",
        "text": "Im starting to think that expressiveness is not a solvable problem at least directly \n\nAny representation will have downsides, so we need multiple representations.\n\nWhen im glancing over my code, id prefer to look at the lines of regex in text because its terse and can be readable enough to know \u201cthis is a phone number validator\u201d\n\nBut when im writing regex, or testing it, i want a UI - i use <http://regex101.com|regex101.com>\n\nI think there are many things like this, where if we try to tackle the expressiveness problem directly with text we may fall into problems of performance, optimization, terse vs readable. \n\nIf we have ways to easily swap out parts of our code with different representations, it may make the language &amp; the specific expression less important. \n\nLibraries can expose their API as a verbose yet clear data format, while providing plugins to swap between representations of it. - calendar plugin allows you to manipulate a calendar to set hardcoded holidays for your system, etc.",
        "user": "U03LJBR6THT",
        "ts": "1689351631.644589",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SBC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Im starting to think that expressiveness is not a solvable problem at least directly \n\nAny representation will have downsides, so we need multiple representations.\n\nWhen im glancing over my code, id prefer to look at the lines of regex in text because its terse and can be readable enough to know \u201cthis is a phone number validator\u201d\n\nBut when im writing regex, or testing it, i want a UI - i use "
                            },
                            {
                                "type": "link",
                                "url": "http://regex101.com",
                                "text": "regex101.com"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI think there are many things like this, where if we try to tackle the expressiveness problem directly with text we may fall into problems of performance, optimization"
                            },
                            {
                                "type": "text",
                                "text": ","
                            },
                            {
                                "type": "text",
                                "text": " terse vs readable. \n\nIf we have ways to easily swap out parts of our code with different representations, it may make the language & the specific expression less important. \n\nLibraries can expose their API as a verbose yet clear data format, while providing plugins to swap between representations of it. - calendar plugin allows you to manipulate a calendar to set hardcoded holidays for your system, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9ddb6e4e-ce7a-4103-8e7e-51606d2536b6",
        "type": "message",
        "text": "I think regex is a good example of why grammar/representation are a red herring. No matter the syntax, the underlying formalism of regex cannot _express_ a language with matching brackets, or HTML. This is, if not the only, then the most important aspect of expressivity.\n\nWithin the domain of regular languages, or perhaps the extended domain of PCRE, I would suggest that grades of expressivity come in the form of primitives and compositions that let the abstract structure of your \"program\" correspond more directly to the structure of the problem in your mind. Maybe combinator-based APIs are nicer, for instance, and I'm sure we could define less-expressive languages with the same power if we wanted...\n\nLooking back at what I've written, I wonder if I'm stretching the meaning of \"expressive\" too far to include formal power. But I do feel it's part of the intuitive idea of \"expressivity\", and I stand by the idea that trivially isomorphic representations of the same formalism can only have minor differences in expressivity.",
        "user": "U016VUZGUUQ",
        "ts": "1689357166.933889",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a7E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think regex is a good example of why grammar/representation are a red herring. No matter the syntax, the underlying formalism of regex cannot "
                            },
                            {
                                "type": "text",
                                "text": "express",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a language with matching brackets, or HTML. This is, if not the only, then the most important aspect of expressivity.\n\nWithin the domain of regular languages, or perhaps the extended domain of PCRE, I would suggest that grades of expressivity come in the form of primitives and compositions that let the abstract structure of your \"program\" correspond more directly to the structure of the problem in your mind. Maybe combinator-based APIs are nicer, for instance, and I'm sure we could define less-expressive languages with the same power if we wanted...\n\nLooking back at what I've written, I wonder if I'm stretching the meaning of \"expressive\" too far to include formal power. But I do feel it's part of the intuitive idea of \"expressivity\", and I stand by the idea that trivially isomorphic representations of the same formalism can only have minor differences in expressivity."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U016VUZGUUQ",
            "ts": "1689357205.000000"
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "reactions": [
            {
                "name": "expressionless",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "82361e81-ce8d-46f4-8a42-6f1015bdc82b",
        "type": "message",
        "text": "&gt;  Natural language serves for informal, i.e. context-dependent, reasoning. It's OK to have the same terms refer to different meanings in different contexts. In a formal language, everything needs to be explicit and non-ambiguous.\n<@UJBAJNFLK> context is the very thing I meant. The question is, can we have both context and unambiguous use in a proglang? Red tries. For some people it's a reason to never consider using it, and they run screaming in terror. For others it's \"I can use that to do this really wacky thing.\". For most I believe it's \"Oh, I have no idea what's going on under the hood. It just works.\"  Finally, a few deep divers will say \"It makes this edge/exception case impossible to handle in all cases, so it's a bad design.\" Maybe prompt-based development will lead us to new approaches where, like with human dialogue, the system can say \"Did you mean A or B here?\"",
        "user": "U013WBS1B1C",
        "ts": "1689359668.018179",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QvmhU",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Natural language serves for informal, i.e. context-dependent, reasoning. It's OK to have the same terms refer to different meanings in different contexts. In a formal language, everything needs to be explicit and non-ambiguous."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " context is the very thing I meant. The question is, can we have both context and unambiguous use in a proglang? Red tries. For some people it's a reason to never consider using it, and they run screaming in terror. For others it's \"I can use that to do this really wacky thing.\". For most I believe it's \"Oh, I have no idea what's going on under the hood. It just works.\"  Finally, a few deep divers will say \"It makes this edge/exception case impossible to handle in all cases, so it's a bad design.\" Maybe prompt-based development will lead us to new approaches where, like with human dialogue, the system can say \"Did you mean A or B here?\""
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    },
    {
        "client_msg_id": "9874156b-b1b4-4d9e-8e05-ffbeef04b047",
        "type": "message",
        "text": "<@U013WBS1B1C> Making context explicit is indeed one way to handle this problem, and if Red is working towards that goal, that's a reason for me to take a closer look. There is some tradition of this kind in Lisp/Scheme, but it's a bit fringe.\n\nPrompt-based development is perhaps a solution at the IDE-level, but not at the language level. The IDE must store the developer's answers in some way that makes the code usable without prompts later and elsewhere. That some way would then have to be part of the language.",
        "user": "UJBAJNFLK",
        "ts": "1689427049.380399",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "17ZY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013WBS1B1C"
                            },
                            {
                                "type": "text",
                                "text": " Making context explicit is indeed one way to handle this problem, and if Red is working towards that goal, that's a reason for me to take a closer look. There is some tradition of this kind in Lisp/Scheme, but it's a bit fringe.\n\nPrompt-based development is perhaps a solution at the IDE-level, but not at the language level. The IDE must store the developer's answers in some way that makes the code usable without prompts later and elsewhere. That some way would then have to be part of the language."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK"
    }
]