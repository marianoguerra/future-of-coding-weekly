[
    {
        "client_msg_id": "39162155-4139-4668-9a61-3eb0bb847030",
        "type": "message",
        "text": "A large codebase is a realm ruled by the iron fist of legalism. In addition, it is a patchwork of many different jurisdictions, each with their own overlapping but subtly different laws. And it's incredibly easy to spawn a new jurisdiction!",
        "user": "UCUSW7WVD",
        "ts": "1703016259.139779",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mLEnK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A large codebase is a realm ruled by the iron fist of legalism. In addition, it is a patchwork of many different jurisdictions, each with their own overlapping but subtly different laws. And it's incredibly easy to spawn a new jurisdiction!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1703016259.139779",
        "reply_count": 8,
        "reply_users_count": 4,
        "latest_reply": "1703488872.508029",
        "reply_users": [
            "U01AD80KMLK",
            "U02QC0PPER3",
            "UCUSW7WVD",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT",
                    "U0625T25APL",
                    "UJBAJNFLK",
                    "U01AF83HSE4"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "ffd4e7e4-c092-4d0f-8db8-468508099edb",
        "type": "message",
        "text": "It is easy because the terrain is often only vast and multidimensional. And instead of tending to existing areas, people love to conquer new terrain.",
        "user": "U01AD80KMLK",
        "ts": "1703092698.645919",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jBhKY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is easy because the terrain is often only vast and multidimensional. And instead of tending to existing areas, people love to conquer new terrain."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3ffd67f0-5461-42c8-9d95-479d60ac9c7f",
        "type": "message",
        "text": "To a programmer, sure, a small intimately familiar codebase offers much escape from legalism, by making it realistically achievable to change the rules.\n\nBut it's also an interesting question what can we do for \"end users\", or even other programmers who are reluctant to invest in learning our piece of the terrain.\nDo you think for a _given user task,_ building it with less legalism for users correlates with smaller codebases? :thinking_face:\n\n[The question is unfair, because achieving same \"functionality\" with less legalism is actually very valuable and should count as \"more functionality\"...  Very hard to quantify.]",
        "user": "U02QC0PPER3",
        "ts": "1703416084.404329",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yMh98",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To a programmer, sure, a small intimately familiar codebase offers much escape from legalism, by making it realistically achievable to change the rules.\n\nBut it's also an interesting question what can we do for \"end users\", or even other programmers who are reluctant to invest in learning our piece of the terrain.\nDo you think for a "
                            },
                            {
                                "type": "text",
                                "text": "given user task,",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " building it with less legalism for users correlates with smaller codebases? "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": "\n\n[The question is unfair, because achieving same \"functionality\" with less legalism is actually very valuable and should count as \"more functionality\"...  Very hard to quantify.]"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "d21c7eb9-6284-4dbb-be80-7b07c549390e",
        "type": "message",
        "text": "The \"conquer new terrain\" metaphor is apt.  People don't go off merely because we're too selfish to \"tend to existing areas\"; to some degree we enjoy it _because_ it lets us make our own jurisdiction!  Whereas putting up with other people's rules (and being careful not to break their use cases) is genuinely hard.\n\n=> Conjecture: any techniques for building less legalistic software might benefit programming itself by reducing NIH tendencies and encouraging positive-sum code reuse??",
        "user": "U02QC0PPER3",
        "ts": "1703416464.236579",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BX8Y6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The \"conquer new terrain\" metaphor is apt.  People don't go off merely because we're too selfish to \"tend to existing areas\"; to some degree we enjoy it "
                            },
                            {
                                "type": "text",
                                "text": "because ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "it lets us make our own jurisdiction!  Whereas putting up with other people's rules (and being careful not to break their use cases) is genuinely hard.\n\n=> Conjecture: any techniques for building less legalistic software might benefit programming itself by reducing NIH tendencies and encouraging positive-sum code reuse??"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U02QC0PPER3",
            "ts": "1703416501.000000"
        },
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "6f93498d-3b4c-4a26-9689-b7ba165ac3f0",
        "type": "message",
        "text": "> Do you think for a given user task, building it with less legalism for users correlates with smaller codebases? :thinking_face:\n> \nProprietary programs and websites tend towards power for the authors, laws for users. Open source programs tend towards power for insiders (who can modify them), laws for outsiders. I want my small, open source Freewheeling programs to provide power for people, laws for the computer.",
        "user": "UCUSW7WVD",
        "ts": "1703441961.690709",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rsYip",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Do you think for a given user task, building it with less legalism for users correlates with smaller codebases? "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nProprietary programs and websites tend towards power for the authors, laws for users. Open source programs tend towards power for insiders (who can modify them), laws for outsiders. I want my small, open source Freewheeling programs to provide power for people, laws for the computer."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1703442189.000000"
        },
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ec5a30a5-1f13-4fc7-9880-43fab2fecbe7",
        "type": "message",
        "text": "... (yet again, sorry) my deep belief is: insiders and authors (and researchers and assembler programmers) think that \"programming\" MUST consist of step-wise sequencing of electronic machines, whereas people don't want to know about programming and think in terms of free will (aka true asynchronousity, not step-wise simultaneity) .  Any UX that presents tools that need to be sequenced in a step-wise (synchronous) manner will not be understood by people, and will remain in the domain of the ivory towerists. The trains will run on time, but, the tools will not be appreciated by the majority ...",
        "user": "UGWUJUZHT",
        "ts": "1703449853.202439",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/L175",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... (yet again, sorry) my deep belief is: insiders and authors (and researchers and assembler programmers) think that \"programming\" MUST consist of step-wise sequencing of electronic machines, whereas people don't want to know about programming and think in terms of free will (aka true asynchronousity, not step-wise simultaneity) .  Any UX that presents tools that need to be sequenced in a step-wise (synchronous) manner will not be understood by people, and will remain in the domain of the ivory towerists. The trains will run on time, but, the tools will not be appreciated by the majority ..."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9fddc670-2308-4692-a557-ef9862a8255d",
        "type": "message",
        "text": "Isn't lots of asynchronous orchestration also too complex for people? Orchestration is just inherently difficult to model in one's head.\n\nConversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.\n\nSo there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.",
        "user": "UCUSW7WVD",
        "ts": "1703452575.783849",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fag2Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Isn't lots of asynchronous orchestration also too complex for people? Orchestration is just inherently difficult to model in one's head.\n\nConversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.\n\nSo there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1703452629.000000"
        },
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "e1d516bd-0f03-41ca-a257-f3e8bfdc3e47",
        "type": "message",
        "text": "> Isn't lots of asynchronous orchestration also too complex for people? \nLots yes.  Some no.\n\nLet's take away the big words and observe what remains.\n\nPeople - Western, English speaking people - draw diagrams on whiteboards and flip charts.  The diagrams read from left to right, top to bottom.  Usually the diagrams consist of boxes with some words on them, and arrows with some words on them.\n\n> Orchestration is just inherently difficult to model in one's head.\nFor programmers, yes, for people, not so much.  As long as the result is not \"too busy\".  I.E. diagrams cannot contain too much detail. If they want to express more detail, they flip to the next blank page and draw another not-so-busy diagram. And so on.  Drawing *everything* on a single diagram is anathema.  Good powerpoint slide decks are like that.  One point per slide, advance to next slide if more detail is required.\n\n> \n> Conversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.\nYes.  And your kids have no problem saying \"while the potatoes cook, cut up the carrots\". They don't invoke monads or futures or awaits to say this, they just say it.  When they draw it on a whiteboard, it's pretty clear - one box branches out to two boxes.  Left to right.  Then, the two branches join back together into a single box.  No rules. The person drawing the branches gets to say when the branches join. The toolmaker doesn't get to dictate. The toolmaker provides a recursive canvas (a flip-chart, or an erasable whiteboard) and provides the dry-erase markers. The person doing the drawing uses the tools to say what they mean.\n\nNot everyone expresses what they mean in a good way. The people who do this well are promoted to \"Architect\" status, the rest don't get promoted.\n\n> So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.\nIn a way, yes, in a way, no. My feeling is that this is quite simple and doesn't need to be complicated further.  Encapsulate units, make the units be totally independent. Function-based programming  languages do only half of the job.  It is trivial to do the rest of the job.  Preserve time-ordering and left-to-rightness and top-to-downness. Allow composition of such units (aka LEGO-ification).  Current programming languages lean solely on the LIFO meme (stack).  Simply adding a LIFO meme (queue) can break out of the step-wise (synchronous) paradigm. This is nothing new - networking protocols already do this kind of thing.  I think that we can push network protocol-ization down to the programming level.  Easily.\n\nDon't use one at the exclusion of the other. Use both. LIFO and FIFO. CALL/RETURN and SEND.\n\nLIFO is good for expressing the innards of components, FIFO is good for expressing inter-component communication.\n\nInput and output queues are good for preserving time-ordering of data arrival and data generation.\n\n\"Programming\" is the whole enchilada. Innards and inter-component communication.",
        "user": "UGWUJUZHT",
        "ts": "1703477203.470019",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qtobn",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Isn't lots of asynchronous orchestration also too complex for people? "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nLots yes.  Some no.\n\nLet's take away the big words and observe what remains.\n\nPeople - Western, English speaking people - draw diagrams on whiteboards and flip charts.  The diagrams read from left to right, top to bottom.  Usually the diagrams consist of boxes with some words on them, and arrows with some words on them.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Orchestration is just inherently difficult to model in one's head."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFor programmers, yes, for people, not so much.  As long as the result is not \"too busy\".  I.E. diagrams cannot contain too much detail. If they want to express more detail, they flip to the next blank page and draw another not-so-busy diagram. And so on.  Drawing "
                            },
                            {
                                "type": "text",
                                "text": "everything",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " on a single diagram is anathema.  Good powerpoint slide decks are like that.  One point per slide, advance to next slide if more detail is required.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nConversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYes.  And your kids have no problem saying \"while the potatoes cook, cut up the carrots\". They don't invoke monads or futures or awaits to say this, they just say it.  When they draw it on a whiteboard, it's pretty clear - one box branches out to two boxes.  Left to right.  Then, the two branches join back together into a single box.  No rules. The person drawing the branches gets to say when the branches join. The toolmaker doesn't get to dictate. The toolmaker provides a recursive canvas (a flip-chart, or an erasable whiteboard) and provides the dry-erase markers. The person doing the drawing uses the tools to say what they mean.\n\nNot everyone expresses what they mean in a good way. The people who do this well are promoted to \"Architect\" status, the rest don't get promoted.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIn a way, yes, in a way, no. My feeling is that this is quite simple and doesn't need to be complicated further.  Encapsulate units, make the units be totally independent. Function-based programming  languages do only half of the job.  It is trivial to do the rest of the job.  Preserve time-ordering and left-to-rightness and top-to-downness. Allow composition of such units (aka LEGO-ification).  Current programming languages lean solely on the LIFO meme (stack).  Simply adding a LIFO meme (queue) can break out of the step-wise (synchronous) paradigm. This is nothing new - networking protocols already do this kind of thing.  I think that we can push network protocol-ization down to the programming level.  Easily.\n\nDon't use one at the exclusion of the other. Use both. LIFO and FIFO. CALL/RETURN and SEND.\n\nLIFO is good for expressing the innards of components, FIFO is good for expressing inter-component communication.\n\nInput and output queues are good for preserving time-ordering of data arrival and data generation.\n\n\"Programming\" is the whole enchilada. Innards and inter-component communication."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1703478512.000000"
        },
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "29576c62-afe1-4523-a6a0-6d5d740368ea",
        "type": "message",
        "text": "The question of \"why not use both?\" makes sense to me. But I don't think things will be any better if we start using both. I think architects will still continue to make the same sorts of messes they do today. I think you're comparing apples and oranges, the current messy state of the status quo vs the idealized pristine state of your idea. But people will start making a mess with it one microsecond after they adopt it.",
        "user": "UCUSW7WVD",
        "ts": "1703488872.508029",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zfMct",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The question of \"why not use both?\" makes sense to me. But I don't think things will be any better if we start using both. I think architects will still continue to make the same sorts of messes they do today. I think you're comparing apples and oranges, the current messy state of the status quo vs the idealized pristine state of your idea. But people will start making a mess with it one microsecond after they adopt it."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1703016259.139779",
        "parent_user_id": "UCUSW7WVD"
    }
]