[
    {
        "client_msg_id": "cb692f94-eaa8-474c-9912-c43eac3baa17",
        "type": "message",
        "text": "<https://lukeplant.me.uk/blog/posts/no-one-actually-wants-simplicity/|No one actually wants simplicity>\n\n&gt; The reason that modern web development is swamped with complexity is that no one really wants things to be simple. We just think we do, while our choices prove otherwise.\nlater, continuing\u2026\n\n&gt; The same is often true of complexity. The real test is the question \u201cwhat are you willing to sacrifice to achieve simplicity?\u201d If the answer is \u201cnothing\u201d, then you don\u2019t actually love simplicity at all, it\u2019s your lowest priority.\n&gt; When I say \u201csacrifice\u201d, I don\u2019t mean that choosing simplicity will mean you are worse off overall \u2013 simplicity brings massive benefits. But it does mean that there will be some things that tempt you to believe you are missing out.\nLooking beyond the inflammatory fun title, how do ya\u2019ll think this relates to the future of coding? Is a reason that visual programming is often just around the corner because folks aren\u2019t willing to shed some of the complexity (read also as \u201cpower\u201d or \u201cflexibility\u201d) of existing programming systems?",
        "user": "UMQ6LR9NZ",
        "ts": "1692800156.581119",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZtNF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://lukeplant.me.uk/blog/posts/no-one-actually-wants-simplicity/",
                                "text": "No one actually wants simplicity"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason that modern web development is "
                            },
                            {
                                "type": "text",
                                "text": "swamped with complexity",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is that no one really wants things to be simple. We just think we do, while our choices prove otherwise."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nlater, continuing\u2026\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The same is often true of complexity. The real test is the question \u201cwhat are you willing to sacrifice to achieve simplicity?\u201d If the answer is \u201cnothing\u201d, then you don\u2019t actually love simplicity at all, it\u2019s your lowest priority.\nWhen I say \u201csacrifice\u201d, I don\u2019t mean that choosing simplicity will mean you are worse off overall \u2013 simplicity brings massive benefits. But it does mean that there will be some things that tempt you to believe you are missing out."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nLooking beyond the inflammatory fun title, how do ya\u2019ll think this relates to the future of coding? Is a reason that visual programming is often just around the corner because folks aren\u2019t willing to shed some of the complexity (read also as \u201cpower\u201d or \u201cflexibility\u201d) of existing programming systems?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UMQ6LR9NZ",
            "ts": "1692800192.000000"
        },
        "thread_ts": "1692800156.581119",
        "reply_count": 6,
        "reply_users_count": 5,
        "latest_reply": "1692858793.513629",
        "reply_users": [
            "UGWUJUZHT",
            "U03LJBR6THT",
            "UA14TGLTC",
            "U5STGTB3J",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "9aeb88a1-168a-47f1-a12c-eb4022565b04",
        "type": "message",
        "text": "IMO, you can have both.  It\u2019s not either/or.  You need the complexity of full solutions, you just don\u2019t want to ingest all of the complexity in one big gulp.  UNIX\u2019 hierarchical file systems overcame the complexity issues of DOS\u2019 flat file system.  Lisp overcame the complexity issues of very long lists (lists are defined recursively).  Hardware people learned early on that PIC - relative addressing - was a better way to express branching.  Much of what we see in modern PLs inhibits layering, eg. inheritance with method overriding, functions that name other functions, etc., etc.",
        "user": "UGWUJUZHT",
        "ts": "1692801665.877149",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GJwKk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IMO, you can have both.  It\u2019s not either/or.  You need the complexity of full solutions, you just don\u2019t want to ingest all of the complexity in one big gulp.  UNIX\u2019 hierarchical file systems overcame the complexity issues of DOS\u2019 flat file system.  Lisp overcame the complexity issues of very long lists (lists are defined recursively).  Hardware people learned early on that PIC - relative addressing - was a better way to express branching.  Much of what we see in modern PLs inhibits layering, eg. inheritance with method overriding, functions that name other functions, etc., etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03LJBR6THT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0E59BE67-60E6-4649-824A-87CE48545FC7",
        "type": "message",
        "text": "There was an alan kay quote something along the lines of \u201csimplicity\u201d can arise from slightly more sophisticated building blocks. \n\nI see a lot of replies to this article advocating for absolute simplicity - simpler building blocks, and less code etc. \n\nBut we don\u2019t have many great examples of good building blocks in mainstream application development. Designing good building blocks is very hard, so many people reject them all together.\n\nI think this is a marketing issue, better building blocks obviously exist given the examples Paul gave. \n\nBut FoC projects need to effectively show how your new building blocks are 1 - simple to understand, implement &amp; use, &amp; 2 - implications on existing hard problems and how classes of complexity just disappear from the POV of the new building blocks.\n\nMost people just see a structural editor and think \u201cthat must be super complex\u201d and don\u2019t see the beautiful simple underlying abstraction &amp; implications on simpler plugin development &amp; tooling. ",
        "user": "U03LJBR6THT",
        "ts": "1692802245.033379",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UnVJ7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There was an alan kay quote something along the lines of \u201csimplicity\u201d can arise from slightly more sophisticated building blocks. \n\nI see a lot of replies to this article advocating for absolute simplicity - simpler building blocks, and less code etc. \n\nBut we "
                            },
                            {
                                "type": "text",
                                "text": "don\u2019t"
                            },
                            {
                                "type": "text",
                                "text": " have many great examples of good building blocks in mainstream application development"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Designing good building blocks is very hard, so many people reject them all together.\n\nI think this is a marketing issue, better building blocks obviously exist given the examples Paul gave. \n\nBut FoC projects need to effectively show how your new building blocks are 1 - simple to understand, implement & use, & 2 - implications on existing hard problems and how classes of complexity just disappear from the POV of the new building blocks.\n\nMost people just see a structural editor and think \u201cthat must be super complex\u201d and "
                            },
                            {
                                "type": "text",
                                "text": "don\u2019t"
                            },
                            {
                                "type": "text",
                                "text": " see the beautiful simple underlying abstraction & implications on simpler plugin development & tooling. "
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U05NLFQQ5MJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c1c0abff-99e4-493c-bd23-345d3fa9e6bb",
        "type": "message",
        "text": "The idea of snapping building blocks together is easier when only one simple type is used.\n\nLEGO == \u201cround peg\u201d into \u201cround hole\u201d.\n\nThe UNIX idea of a simple inter-command type - characters delimited by newlines - is already too complicated (!).  Workarounds to handle binary data instead of 7-bit ASCII bytes were invented, and, then, came Unicode.\n\nIt is possible to build up more complex types using layers of types.\n\nTypes in networks are layered this way.  Types in PLs are not layered in the same manner.  IMO, the concepts espoused in something like the OSI 7-layer model need to be applied to programming.\n\nMy feeling at this time, is that a software Message for coupling software components is (1) a Tag and (2) Data.  One can complexify on the way up and simplify on the way down.  Type checking and type stripping can be done by software components, but, the components need to be isolated from one another, e.g. free from hidden and visible dependencies (aka \u201c0D\u201d, anti-CALL/RETURN).  The premature-optimization crowd can be mollified by allowing some components to be optimized out at \u201ccompile time\u201d.\n\n\nWe have all of the tools, we just don\u2019t bother to organize this way.  In the same way that we wrote spaghetti code when everything looked like a GOTO.",
        "user": "UGWUJUZHT",
        "ts": "1692804230.135229",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q5CNs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The idea of snapping building blocks together is easier when only one simple type is used.\n\nLEGO == \u201cround peg\u201d into \u201cround hole\u201d.\n\nThe UNIX idea of a simple inter-command type - characters delimited by newlines - is already too complicated (!).  Workarounds to handle binary data instead of 7-bit ASCII bytes were invented, and, then, came Unicode.\n\nIt is possible to build up more complex types using layers of types.\n\nTypes in networks are layered this way.  Types in PLs are not layered in the same manner.  IMO, the concepts espoused in something like the OSI 7-layer model need to be applied to programming.\n\nMy feeling at this time, is that a software Message for coupling software components is (1) a Tag and (2) Data.  One can complexify on the way up and simplify on the way down.  Type checking and type stripping can be done by software components, but, the components need to be isolated from one another, e.g. free from hidden and visible dependencies (aka \u201c0D\u201d, anti-CALL/RETURN).  The premature-optimization crowd can be mollified by allowing some components to be optimized out at \u201ccompile time\u201d.\n\n\nWe have all of the tools, we just don\u2019t bother to organize this way.  In the same way that we wrote spaghetti code when everything looked like a GOTO."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "6ef30380-d3d8-4b4e-9da8-6f3375feed77",
        "type": "message",
        "text": "Speaking of spaghetti...  As tangled cords prove, simple doesn't not mean easy or natural.",
        "user": "UA14TGLTC",
        "ts": "1692851733.402009",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DO5K8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Speaking of spaghetti...  As tangled cords prove, simple doesn't not mean easy or natural."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "25988E2F-937E-4D88-A005-D3FB2B234574",
        "type": "message",
        "text": "Is simplicity an objective property of a system that is just hard to define? Or is simplicity somehow wrapped up \u2014 at least partially \u2014 with our subjective experience of it and is that why we have a hard time agreeing on it?\n\nThe article picks up on this issue, but then concludes that if it is partially subjective, we still just have to agree on how to deal with it \u2014 but that is the problem, not the solution.\n\nThere is an aspect of legibility to a system where different people might fundamentally disagree and no agreement seems possible (Emacs vs. Vim, Lisp vs. Forth, tabs vs. spaces, etc.). It often looks like it\u2019s just an agreement issue and one side (of course, usually the other) is somehow confused and can\u2019t see the \u201ctruth\u201d.\n\nBut what if that is a flawed perspective to begin with?\nWhat if there are emergent properties that are only ever clearly defined by their current context and not fully generalizable? \n\nSimilar to how many organisms are well adapted to their environment, but it means different things for different organisms in different environments. If you drop a shark, a well adapted deadly predator at a fairly high spot in the aquatic food chain, into the middle of Sahara desert, it\u2019ll be dead within seconds.\n\nMaybe when a system appears simple to us, we are just like a shark in water. Everything looks just fine over here. But try to teach that to a camel in the desert\u2026",
        "user": "U5STGTB3J",
        "ts": "1692857571.904069",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NtJc7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is simplicity an objective property of a system that is just hard to define? Or is simplicity somehow wrapped up \u2014 at least partially \u2014 with our subjective experience of it and is that why we have a hard time agreeing on it?\n\nThe article picks up on this issue, but then concludes that if it is partially subjective, we still just have to agree on how to deal with it \u2014 but that is the problem, not the solution.\n\nThere is an aspect of legibility to a system where different people might fundamentally disagree and no agreement seems possible (Emacs vs. Vim, Lisp vs. Forth, tabs vs. spaces, etc.). It often looks like it\u2019s just an agreement issue and one side (of course, usually the other) is somehow confused and can\u2019t see the \u201ctruth\u201d.\n\nBut what if that is a flawed perspective to begin with?\nWhat if there are emergent properties that are only ever clearly defined by their current context and not fully generalizable? \n\nSimilar to how many organisms are well adapted to their environment, but it means different things for different organisms in different environments. If you drop a shark, a well adapted deadly predator at a fairly high spot in the aquatic food chain, into the middle of Sahara desert, it\u2019ll be dead within seconds.\n\nMaybe when a system appears simple to us, we are just like a shark in water. Everything looks just fine over here"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " But try to teach that to a camel in the desert\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5523b0b9-7929-40b2-9852-031b2ad27abf",
        "type": "message",
        "text": "My unproven and probably unprovable hypothesis is that much of complexity in software comes from believing that \"software\" is a useful category to think about, independent of context. From an engineering (as opposed to philosophical-mathematical) point of view, an embedded computer in a washing machine has pretty much nothing in common with a Web browser, and a climate simulation has nothing in common with Dungeons &amp; Dragons.",
        "user": "UJBAJNFLK",
        "ts": "1692858793.513629",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vQ=32",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My unproven and probably unprovable hypothesis is that much of complexity in software comes from believing that \"software\" is a useful category to think about, independent of context. From an engineering (as opposed to philosophical-mathematical) point of view, an embedded computer in a washing machine has pretty much nothing in common with a Web browser, and a climate simulation has nothing in common with Dungeons & Dragons."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692800156.581119",
        "parent_user_id": "UMQ6LR9NZ",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UMQ6LR9NZ",
                    "UA14TGLTC",
                    "U0245E9RB2B",
                    "UML4ZEKDK",
                    "U05NLFQQ5MJ"
                ],
                "count": 6
            }
        ]
    }
]