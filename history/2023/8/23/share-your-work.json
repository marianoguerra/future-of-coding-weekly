[
    {
        "client_msg_id": "0eb0df69-c9f6-4a5c-9238-41dffc3671c4",
        "type": "message",
        "text": "Future of Coding \u2022 Episode 66\nBonnie Nardi \u2022 A Small Matter of Programming\n\ud808\udcb6 <https://futureofcoding.org/episodes/066>\n\nThis community is a big tent. We welcome folks from all backgrounds, and all levels of experience with computers. Heck, on our last episode, we celebrated an article written by someone who is, rounding down, a lawyer! A constant question I ponder is: what's the best way to introduce someone to the world of FoC? If someone is a workaday programmer, or a non-programmer, what can we share with them to help them understand our area of interest?\n\nA personal favourite is the <https://mitpress.mit.edu/9780262232272/|New Media Reader>, but it's long and dense. An obvious crowd-pleaser is <https://www.youtube.com/watch?v=PUv66718DII|Inventing on Principle>.\n\n<https://en.wikipedia.org/wiki/Bonnie_Nardi|Bonnie Nardi>'s <https://mitpress.mit.edu/9780262292368/a-small-matter-of-programming/|A Small Matter of Programming> deserves a place on the list, especially if the reader is already an avid programmer who doesn't yet understand the point of _end-user programming_. They might ask, \"Why should typical computer users bother learning to program?\" Well, that's the wrong question! Instead, we should start broader. Why do we use computers? What do we use them to do? What happens when they don't do what we want? Who controls what they do? Will this ever change? What change do we want? Nardi challenges us to explore these questions, and gives the reader a gentle but definitive push in a positive direction.\n\nAlso of note \u2014 we've launched a <http://patreon.com/futureofcoding|Patreon>! If you enjoy the show, please consider supporting it with a small (or not-so-small) monthly contribution. You'll get bonus episodes and a warm feeling in your heart (disclaimer: warm feeling is a metaphor; if you actually feel an increase of body heat please do not discontinue support but do talk to a doctor)",
        "user": "UC2A2ARPT",
        "ts": "1692759278.355689",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OXuB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Future of Coding \u2022 Episode 66\nBonnie Nardi \u2022 A Small Matter of Programming\n\ud808\udcb6 "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.org/episodes/066"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThis community is a big tent. We welcome folks from all backgrounds, and all levels of experience with computers. Heck, on our last episode, we celebrated an article written by someone who is, rounding down, a lawyer! A constant question I ponder is: what's the best way to introduce someone to the world of FoC? If someone is a workaday programmer, or a non-programmer, what can we share with them to help them understand our area of interest?\n\nA personal favourite is the "
                            },
                            {
                                "type": "link",
                                "url": "https://mitpress.mit.edu/9780262232272/",
                                "text": "New Media Reader"
                            },
                            {
                                "type": "text",
                                "text": ", but it's long and dense. An obvious crowd-pleaser is "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=PUv66718DII",
                                "text": "Inventing on Principle"
                            },
                            {
                                "type": "text",
                                "text": ".\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Bonnie_Nardi",
                                "text": "Bonnie Nardi"
                            },
                            {
                                "type": "text",
                                "text": "'s "
                            },
                            {
                                "type": "link",
                                "url": "https://mitpress.mit.edu/9780262292368/a-small-matter-of-programming/",
                                "text": "A Small Matter of Programming"
                            },
                            {
                                "type": "text",
                                "text": " deserves a place on the list, especially if the reader is already an avid programmer who doesn't yet understand the point of "
                            },
                            {
                                "type": "text",
                                "text": "end-user programming",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". They might ask, \"Why should typical computer users bother learning to program?\" Well, that's the wrong question! Instead, we should start broader. Why do we use computers? What do we use them to do? What happens when they don't do what we want? Who controls what they do? Will this ever change? What change do we want? Nardi challenges us to explore these questions, and gives the reader a gentle but definitive push in a positive direction.\n\nAlso of note \u2014 we've launched a "
                            },
                            {
                                "type": "link",
                                "url": "http://patreon.com/futureofcoding",
                                "text": "Patreon"
                            },
                            {
                                "type": "text",
                                "text": "! If you enjoy the show, please consider supporting it with a small (or not-so-small) monthly contribution. You'll get bonus episodes and a warm feeling in your heart (disclaimer: warm feeling is a metaphor; if you actually feel an increase of body heat please do not discontinue support but do talk to a doctor)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692759278.355689",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1692897050.327209",
        "reply_users": [
            "UC2A2ARPT",
            "U03CEGR3HSL"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "star",
                "users": [
                    "U03R0B9U1GD",
                    "UMV4B97GT",
                    "UMQ6LR9NZ"
                ],
                "count": 3
            },
            {
                "name": "tada",
                "users": [
                    "U02B6FQKZK8",
                    "UA14TGLTC",
                    "UMQ6LR9NZ",
                    "U02U0AS3J49",
                    "U03CEGR3HSL",
                    "UF6RLAL7J",
                    "UML4ZEKDK",
                    "UCUSW7WVD"
                ],
                "count": 8
            },
            {
                "name": "cake",
                "users": [
                    "U013ZLJARC7",
                    "UMQ6LR9NZ",
                    "U0378MDUG1Y",
                    "U05597GCDDK"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "16a36723-c30b-42bf-9b79-224fa77fc4ef",
        "type": "message",
        "text": "In the game of FoC Patreon Tiers, Visual Programming is in the lead. Type System purists, where you at!?",
        "user": "UC2A2ARPT",
        "ts": "1692821273.206939",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qoY=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the game of FoC Patreon Tiers, Visual Programming is in the lead. Type System purists, where you at!?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692759278.355689",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "raised_hands",
                "users": [
                    "U03R0B9U1GD",
                    "UMQ6LR9NZ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "33c1e3ca-118b-4ef3-b3ff-357674e4ced8",
        "type": "message",
        "text": "Thanks for another fun episode! Here are my notes.\n\nAlan Kay's vision is focused on communicating by giving other people an executable simulation of your idea, not just figuring things out for yourself. His work on \"active essays\" is all about embedding simulations within a document for the purpose of improving communication.\n\nWith respect to programs that write programs, Andrew Hume supposedly said \"Programs that write programs are the happiest programs in the world.\"\n\nRegarding \"The computer is the fake bit and the program is the real part,\" though I cannot find a primary source, Dijkstra is sometimes quoted as saying \"Computer Science is no more about computers than astronomy is about telescopes.\"\n\nAlso, from SICP (<https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-7.html|https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-7.html>), \"First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute.\"\n\nIf Dijkstra the Formal AND the freewheeling MIT crowd BOTH agree with you, Jimmy, then you might be onto something.\n\nOn the subject of modifying existing programs, one outstanding success story is Emacs. Emacs is really easy to customize in little and big ways because it was designed to be customized, with extensive support for custom key mapping, configuration, and the ability to install hooks before and after almost every important action. The result Is that it takes very little code to insert a little tweak in behavior wherever you want to. This wasn't an inevitable consequence of the language or the development environment, although they were a tremendous help. It came from a steadfast commitment to customizability at every stage of the design and implementation.\n\nIt also offers a gentle on-ramp to programming because the user can start with small customizations and gradually ramp up to more intricate ones. There is no point in the journey where you need to stop playing and go learn how to program all at once.\n\nI especially love section \"8.3 Blue Sky\" in the original Emacs paper. \n<https://dspace.mit.edu/handle/1721.1/5736|https://dspace.mit.edu/handle/1721.1/5736>\n\nI think Peter Naur's paper Diminishing Returns of User Programming (1978) is relevant to this whole conversation. As languages become higher and higher level, they tend to either become specialized and limited, or to have an explosion in vocabulary. Some people think that domain-specific languages are a way to escape this trap, but somehow this dichotomy must be addressed if we want to create a form of programming that is easy, high level, and general purpose.",
        "user": "U03CEGR3HSL",
        "ts": "1692897050.327209",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vlr17",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for another fun episode! Here are my notes.\n\nAlan Kay's vision is focused on communicating by giving other people an executable simulation of your idea, not just figuring things out for yourself. His work on \"active essays\" is all about embedding simulations within a document for the purpose of improving communication.\n\nWith respect to programs that write programs, Andrew Hume supposedly said \"Programs that write programs are the happiest programs in the world.\"\n\nRegarding \"The computer is the fake bit and the program is the real part,\" though I cannot find a primary source, Dijkstra is sometimes quoted as saying \"Computer Science is no more about computers than astronomy is about telescopes.\"\n\nAlso, from SICP ("
                            },
                            {
                                "type": "link",
                                "url": "https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-7.html",
                                "text": "https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-7.html"
                            },
                            {
                                "type": "text",
                                "text": "), \"First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute.\"\n\nIf Dijkstra the Formal AND the freewheeling MIT crowd BOTH agree with you, Jimmy, then you might be onto something.\n\nOn the subject of modifying existing programs, one outstanding success story is Emacs. Emacs is really easy to customize in little and big ways because it was designed to be customized, with extensive support for custom key mapping, configuration, and the ability to install hooks before and after almost every important action. The result Is that it takes very little code to insert a little tweak in behavior wherever you want to. This wasn't an inevitable consequence of the language or the development environment, although they were a tremendous help. It came from a steadfast commitment to customizability at every stage of the design and implementation.\n\nIt also offers a gentle on-ramp to programming because the user can start with small customizations and gradually ramp up to more intricate ones. There is no point in the journey where you need to stop playing and go learn how to program all at once.\n\nI especially love section \"8.3 Blue Sky\" in the original Emacs paper. \n"
                            },
                            {
                                "type": "link",
                                "url": "https://dspace.mit.edu/handle/1721.1/5736",
                                "text": "https://dspace.mit.edu/handle/1721.1/5736"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI think Peter Naur's paper Diminishing Returns of User Programming (1978) is relevant to this whole conversation. As languages become higher and higher level, they tend to either become specialized and limited, or to have an explosion in vocabulary. Some people think that domain-specific languages are a way to escape this trap, but somehow this dichotomy must be addressed if we want to create a form of programming that is easy, high level, and general purpose."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03CEGR3HSL",
            "ts": "1692899896.000000"
        },
        "thread_ts": "1692759278.355689",
        "parent_user_id": "UC2A2ARPT"
    }
]