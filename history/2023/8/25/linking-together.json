[
    {
        "client_msg_id": "e543c989-0598-41e7-b707-4f0fab198800",
        "type": "message",
        "text": "A nice essay on programming languages, but with a message that is much more general: <https://journal.infinitenegativeutility.com/leaving-haskell-behind>\n\nIt's about the tension between \"make better technology\", \"use start-of-the-art technology\", and \"use boring (but stable and well understood) technology\". Different goals, different tools.\n\nAnother example I have experienced a lot: mathematics and physics. Mathematicians work on new mathematics, mathematical physicists introduce state-of-the-art mathematics into physics, and all other physicists use 100-year-old mathematics from textbooks. And each group complains about the attitude of the two others.",
        "user": "UJBAJNFLK",
        "ts": "1692947456.279949",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RuC1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A nice essay on programming languages, but with a message that is much more general: "
                            },
                            {
                                "type": "link",
                                "url": "https://journal.infinitenegativeutility.com/leaving-haskell-behind"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt's about the tension between \"make better technology\", \"use start-of-the-art technology\", and \"use boring (but stable and well understood) technology\". Different goals, different tools.\n\nAnother example I have experienced a lot: mathematics and physics. Mathematicians work on new mathematics, mathematical physicists introduce state-of-the-art mathematics into physics, and all other physicists use 100-year-old mathematics from textbooks. And each group complains about the attitude of the two others."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://journal.infinitenegativeutility.com/leaving-haskell-behind",
                "service_icon": "https://journal.infinitenegativeutility.com/favicon.ico",
                "ts": 1692739673,
                "id": 1,
                "original_url": "https://journal.infinitenegativeutility.com/leaving-haskell-behind",
                "fallback": "Infinite Negative Utility: Leaving Haskell behind \u2014 Infinite Negative Utility",
                "text": "For almost a complete decade\u2014starting with discovering Haskell in about 2009 and right up until switching to a job where I used primarily...",
                "title": "Leaving Haskell behind \u2014 Infinite Negative Utility",
                "title_link": "https://journal.infinitenegativeutility.com/leaving-haskell-behind",
                "service_name": "Infinite Negative Utility",
                "fields": [
                    {
                        "value": "65,134",
                        "title": "Views",
                        "short": true
                    }
                ]
            }
        ],
        "thread_ts": "1692947456.279949",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1693073043.323009",
        "reply_users": [
            "UA14TGLTC",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03LJBR6THT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d0435a8d-0a94-4000-8eea-8bc04639a8bd",
        "type": "message",
        "text": "Has anyone spent time with <https://github.com/kspalaiologos/kamilalisp|kamilalisp>?\n\nI've spent the last week or so exploring it, and it keeps blowing my mind.",
        "user": "UMQ6LR9NZ",
        "ts": "1692965730.536949",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DrJ+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Has anyone spent time with "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/kspalaiologos/kamilalisp",
                                "text": "kamilalisp"
                            },
                            {
                                "type": "text",
                                "text": "?\n\nI've spent the last week or so exploring it, and it keeps blowing my mind."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "reply_count": 5,
        "reply_users_count": 3,
        "latest_reply": "1693025799.955969",
        "reply_users": [
            "UMQ6LR9NZ",
            "UC2A2ARPT",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dc4b0eeb-d0f8-4e93-a3a8-10aa8116d272",
        "type": "message",
        "text": "At first I thought it was a joke, because maybe IMTA?\n\nBut, I saw this snippet from its README and was like, so _everything_?\n\n&gt; KamilaLisp allows for actor programming, concurrent programming, imperative programming, functional programming, array programming, pure functional programming, object-oriented programming, rudimentary logic programming, mathematical programming, backend development, numerical and scientific computation, scripting and system administration, symbolic computation (real and complex analysis), tacit (point-free) programming, concurrent programming and event-driven programming. \nBut...like...yeah.",
        "user": "UMQ6LR9NZ",
        "ts": "1692965777.533289",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DeO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At first I thought it was a joke, because maybe IMTA?\n\nBut, I saw this snippet from its README and was like, so "
                            },
                            {
                                "type": "text",
                                "text": "everything",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "KamilaLisp allows for actor programming, concurrent programming, imperative programming, functional programming, array programming, pure functional programming, object-oriented programming, rudimentary logic programming, mathematical programming, backend development, numerical and scientific computation, scripting and system administration, symbolic computation (real and complex analysis), tacit (point-free) programming, concurrent programming and event-driven programming. "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nBut...like...yeah."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "9BF70F5D-D4A8-4745-B7E4-F21337C99B1A",
        "type": "message",
        "text": "Created by a 19 year old!?",
        "user": "UC2A2ARPT",
        "ts": "1692977168.253659",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3Z+P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Created by a 19 year old!?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "b85da410-0fb8-44b2-b066-6c77cef4ece9",
        "type": "message",
        "text": "right!? everything about this makes me feel totally inept.",
        "user": "UMQ6LR9NZ",
        "ts": "1692977190.006729",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wuNdl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "right!? everything about this makes me feel totally inept."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "09dd58c3-1adf-4b24-abb8-445eb8ae8fca",
        "type": "message",
        "text": "but also in awe \u2014 I love how it empowers you to think for a problem space, so, rather than \u201csolve this the APL way,\u201d vs \u201csolve this the functional way\u201d or \u201csolve this the OO way\u201d you can ask \u201cwhat way of the ways at hand makes most sense for this bit?\u201d \u2014 I\u2019m used to making those choices at the language-level, e.g. \u201cgiven this problem, I reach for X language\u201d but here I can hand a tacit function working on a matrix off to an object!? :male-cook:",
        "user": "UMQ6LR9NZ",
        "ts": "1692982478.975529",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y97E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but also in awe \u2014 I love how it empowers you to think for a problem space, so, rather than \u201csolve this the APL way,\u201d vs \u201csolve this the functional way\u201d or \u201csolve this the OO way\u201d you can ask \u201cwhat way of the ways at hand makes most sense for this bit?\u201d \u2014 I\u2019m used to making those choices at the language-level, e.g. \u201cgiven this problem, I reach for X language\u201d but here I can hand a tacit function working on a matrix off to an object!? "
                            },
                            {
                                "type": "emoji",
                                "name": "male-cook",
                                "unicode": "1f468-200d-1f373"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "cfbfd826-dc05-427c-b374-c9eab39cdf69",
        "type": "message",
        "text": "Some excellent quotes:\n&gt; I would describe good Haskell code as \u201cbrittle\u201d, and I mean that as a compliment. People tend to casually use \u201cbrittle\u201d to mean \u201cprone to breakage\u201d, but in materials science what \u201cbrittle\u201d means is that something breaks without bending: when a brittle material reaches the limits of its strength, it fractures instead of deforming. Haskell is a language where abstractions do not \u201cbend\u201d (or permit invalid programs) but rather \u201cbreak\u201d (fail to compile) in the face of problems.\nAnd another:\n&gt; I once heard it said that Haskell lets you work with functions the way Perl lets you work with strings. Lots of Haskell idioms, like monads, are perfectly expressible in other languages: Haskell just makes them feel natural, while writing a monad in many other languages feels like you have to do lots of busy-work.\nI wish the critique of Haskell was as good as the love expressed for it.\n\nFor my part, I just find that most attempts write Haskell programs ends up down theoretical rabbit holes.\n\nHere's a tiny, silly example.  For illustration purposes, I wanted to write `take 25 (map (^2) [0..])` as:\n```do\n  i &lt;- [0..]\n  let ii = i * i\n  guard (i &lt; 25)\n  return ii```\nThis is, of course, bad because it loops after producing the 25 squares.  You keep pulling off `i`s and keep fining that they are not longer less than 25.  It would be \"neat\" if we could replace `guard` with some sort of `until`.  But what sort?  Could get lost for hours.",
        "user": "UA14TGLTC",
        "ts": "1693025682.673339",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GYjRV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some excellent quotes:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would describe good Haskell code as \u201cbrittle\u201d, and I mean that as a compliment. People tend to casually use \u201cbrittle\u201d to mean \u201cprone to breakage\u201d, but in materials science what \u201cbrittle\u201d means is that something breaks without bending: when a brittle material reaches the limits of its strength, it fractures instead of deforming. Haskell is a language where abstractions do not \u201cbend\u201d (or permit invalid programs) but rather \u201cbreak\u201d (fail to compile) in the face of problems."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And another:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I once heard it said that Haskell lets you work with functions the way Perl lets you work with strings. Lots of Haskell idioms, like monads, are perfectly expressible in other languages: Haskell just makes them feel natural, while writing a monad in many other languages feels like you have to do lots of busy-work."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wish the critique of Haskell was as good as the love expressed for it.\n\nFor my part, I just find that most attempts write Haskell programs ends up down theoretical rabbit holes.\n\nHere's a tiny, silly example.  For illustration purposes, I wanted to write "
                            },
                            {
                                "type": "text",
                                "text": "take 25 (map (^2) [0..])",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "do\n  i <- [0..]\n  let ii = i * i\n  guard (i < 25)\n  return ii"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is, of course, bad because it loops after producing the 25 squares.  You keep pulling off "
                            },
                            {
                                "type": "text",
                                "text": "i",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "s and keep fining that they are not longer less than 25.  It would be \"neat\" if we could replace "
                            },
                            {
                                "type": "text",
                                "text": "guard",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with some sort of "
                            },
                            {
                                "type": "text",
                                "text": "until",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  But what sort?  Could get lost for hours."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692947456.279949",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9eb071e0-891c-482e-ab4a-c9ff65b98962",
        "type": "message",
        "text": "Looks like someone is having fun.",
        "user": "UA14TGLTC",
        "ts": "1693025799.955969",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iRY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Looks like someone is having fun."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692965730.536949",
        "parent_user_id": "UMQ6LR9NZ"
    },
    {
        "client_msg_id": "4667f1dd-7de6-4e2f-b029-7f47164eedf8",
        "type": "message",
        "text": "Haskell is the formal systems lover's dream (unless they have already moved on to something more sophisticated, such as dependent types). All code defines a formal system, but Haskell programmers love to make formal systems that are _about_ the code (types etc.) Formal systems are very precise, which is great when you can certain that they match your problem. If they don't match, or if you don't know, they are an endless source of frustration. Which means that Haskell is great language if and only if your problem has already been formlized, e.g. in mathematics.",
        "user": "UJBAJNFLK",
        "ts": "1693073043.323009",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L=PR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Haskell is the formal systems lover's dream (unless they have already moved on to something more sophisticated, such as dependent types). All code defines a formal system, but Haskell programmers love to make formal systems that are "
                            },
                            {
                                "type": "text",
                                "text": "about",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the code (types etc.) Formal systems are very precise, which is great when you can certain that they match your problem. If they don't match, or if you don't know, they are an endless source of frustration. Which means that Haskell is great language if and only if your problem has already been formlized, e.g. in mathematics."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1692947456.279949",
        "parent_user_id": "UJBAJNFLK"
    }
]