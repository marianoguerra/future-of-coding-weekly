
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-07-31T02:49:17.118Z" class="post"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T02:49:17.118Z" class="date">2024-07-31 02:49:17</a> <div class="message"><p>I‚Äôm in the process of writing a transpiler that spits out Drawware 0D kernel code in various languages (like Python, Lisp, JS, WASM, etc.) from a higher-than-HLL. I‚Äôm using a very simple ‚Äúcircuit‚Äù to regression test (Larson Scanner, as seen on T.V. Knight Rider). Current status and ‚Äúworking paper‚Äù: <a href="https://programmingsimplicity.substack.com/p/2024-07-30-diagram-compiler-status?r=1egdky">programmingsimplicity.substack.com/p/2024-07-30-diagram-compiler-status?r=1egdky</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://programmingsimplicity.substack.com/p/2024-07-30-diagram-compiler-status?r=1egdky">2024-07-30-Diagram Compiler Status</a></p>
<p>This project creates a working ‚ÄúLarson scanner‚Äù (seen on the T.V.</p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2024-07-31T03:22:21.376Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T03:22:21.376Z" class="date">2024-07-31 03:22:21</a> <div class="message"><p>I  <em>think</em>  that this might be interesting to FoC‚Äôers because: it demonstrates various techniques (t2t, 0D, feedback with queues, etc.) that aren‚Äôt common in Functional Programming. These  <em>techniques</em>  might inspire ideas of what is possible in the FoC realm, beyond the usual more-programming-using-only-the-function-based-paradigm. I, also, believe that VPLs and DPLs are ignored for at least 2 reasons: (1) it‚Äôs believed to be very hard to parse diagrams, and, (2) text says it all, what more could there be???. This progress report quietly attacks both mis-beliefs. (1) Parsing diagrams - in 2024 - is sooo easy that even someone like me can do it. (2) Feedback loops and structured message-passing produce efficient ways to express certain idioms that can‚Äôt be expressed - easily - in textual form, hence, are roundly avoided, hence, causing inadequate simplicity of design in certain problem domains.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T18:17:12.884Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T18:17:12.884Z" class="date">2024-07-31 18:17:12</a> <div class="message"><p>One thing that I keep forgetting to mention, is that even though I appear to be drawing node-and-arrow diagrams, nodes contain input and output ports. Possibly many of each. In contrast, functions in FP, have exactly 1 input port and exactly 1 output port (modulo the wart called ‚Äúexceptions‚Äù. So-called ‚Äúmultiple parameters‚Äù to functions are but an optical illusion supported by destructuring operations (it‚Äôs all just one block of data that all comes at the same time, regardless of how you want to slice-and-dice the block)). Arrows can only be drawn from port to port, not from node to node. This simple concept of ports provides high levels of encapsulation of data /and/ encapsulation of control flow. Nodes are akin to Actors, except that Container nodes can be recursively defined to contain other Container nodes. Akin to the idea of Lisp lists containing atoms or, recursively, lists.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-31T16:20:52.630Z" class="post"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T16:20:52.630Z" class="date">2024-07-31 16:20:52</a> <div class="message"><p>My basement flooded this week. So that's going to set me back a bit. But, hey, here's a quick update on the two FoC-relevant things I'm floating.</p>
<ul><li>DANK WIKI ‚Ä¢ At the last FoC virtual meetup, we talked about setting up a super lo-fi, friendly-to-nontechnical-folks, hackable community wiki. I've got a repo all set up for that locally, and just have a tiny bit more experimentation to do before it's ready to share. All the pages are just simple HTML or MD. There is a build step ‚Äî wait, stop, don't run away ‚Äî it's a build step, but it's cool and different!! There's a really simple spec and a short reference implementation. Zero dependencies, less than 100 loc. Everyone is encouraged to port the script into their language of choice and commit that. That way, other people can check out the repo, add some pages, and build it locally without having to conform to whatever ecosystem the build script requires. I'd ideally like to have impls in each of the most common ecosystems right away (JS, Python, Ruby, maybe bash, etc). Finally, the wiki is (for now) going to be hosted on Github, with an action that runs the reference build script on commit, so if people want to edit it via the Github web interface they can. (I'll be liberal with handing out the commit bit). This is going to be a social experiment as much as a technical one. Excited to see how it goes. Hoping to have the initial version of this go live this weekend.</li></ul><ul><li>LIFE RAFT ‚Ä¢ I'm itching to get cracking on a Slack successor. I'm thinking I'll spin up a dedicated channel, and solicit people to drop in whatever random wishes / ideas / requests / suggestions / advice they feel like offering, so that these can filter in to the design process. I'm also hoping to put together goals for an MVP. This will need to include several things, including but not limited to: visual mockups for the GUI on desktop and mobile, technical architecture, priority features, estimated timeline. I intend to be quite restrained here ‚Äî I want to make the smallest possible  <em>good enough</em>  thing.</li></ul></div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-31T17:22:36.714Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T17:22:36.714Z" class="date">2024-07-31 17:22:36</a> <div class="message"><p>It's been on my mind to come up with a schema for this. You've mentioned channel -&gt; post -&gt; comment before, and cerca has post -&gt; comment. I feel we need something slightly richer that allows wiki-like workflows as well. Revisions. The ability to summarize a thread in a wiki page while maintaining provenance to the original thread (so another kind of revision?) The ability to create multiple views of a thing,  <em>qua</em>  Glamorous Toolkit. Maybe that's also another kind of revision?</p>
<p>One challenge in combining markdown with an easy build script: markdown is notoriously hard to parse. Do you have thoughts on how to slice that tension? My thought so far has been to just restrict ourselves to a subset of html. Many forums and blog platforms allow html in comments but only a short list of permitted tags they can just mention below every textarea. That feels like one reasonable approach.</p>
<p>(I'm so sorry to hear about your basement!)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T17:43:08.934Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T17:43:08.934Z" class="date">2024-07-31 17:43:08</a> <div class="message"><p>I'm thinking we can get pretty far with a subset of markdown, parsed using a series of not-awful regexes. Here's what I currently have ‚Äî cobbled together from a few different sources online, not well tested yet.</p>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07EHF7257Z.png" alt="Screenshot 2024-07-31 at 11.41.26‚ÄØAM.png"></p>
</div></div><div id="2024-07-31T18:25:30.146Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T18:25:30.146Z" class="date">2024-07-31 18:25:30</a> <div class="message"><p>FWIW: I strongly favour the use of OhmJS (PEG) over the use of REGEXs... REGEXs fool you into thinking that they work, until you hit some edge-case that doesn't work. Unlike CFGs, PEGs can be used for simple parsing tasks instead of mega-project full-blown compilers. I would immediately jump to using OhmJS for parsing something like markdown.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T19:10:47.857Z" class="reply"><span class="user">Jamie Brandon</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T19:10:47.857Z" class="date">2024-07-31 19:10:47</a> <div class="message"><p><a href="https://djot.net/">djot.net</a> is mostly markdown but is significantly easier to parse. You probably don't want all of djot, but studying what they changed to make markdown easier to parse seems worthwhile.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T19:43:29.631Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T19:43:29.631Z" class="date">2024-07-31 19:43:29</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> I'm generally inclined to agree. Humblebrag: I work on a three-person team at my job, and Alex Warth is one of those three people. But in this case, I value the code being dependency-free and trivial to rewrite in other languages, so Ohm is probably out. So if we figured out a way to parse this subset of md syntax that satisfied the goals of this project, that'd be awesome. Would be happy to switch to that once it's figured out.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:08:19.123Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:08:19.123Z" class="date">2024-07-31 20:08:19</a> <div class="message">
<blockquote><p>dependency-free and trivial to rewrite in other languages</p>
</blockquote>
<p>Translation: only languages with built-in regex support are allowed, and let's hope that their notions of regex are sufficiently similar (probably not an issue unless you need advanced regexes, but... we will see).</p>
<p>Just to point out the can of worms hidden behind any idea in the space of "let's keep data transformations simple".</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:21:20.291Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:21:20.291Z" class="date">2024-07-31 20:21:20</a> <div class="message"><p>This is strengthening my preference for "html (subset) all the way". Consistently across both wiki and life raft.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:22:34.726Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:22:34.726Z" class="date">2024-07-31 20:22:34</a> <div class="message"><p>OhmJS (unlike Ohm?) is portable to every browser of note.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:25:46.004Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:25:46.004Z" class="date">2024-07-31 20:25:46</a> <div class="message"><p>Reminder that the build script is a sideshow. The main attraction is authoring content for the wiki. That experience should be made as good as possible for as many folks as possible. This goal is in tension with the goal of making the build script stupid-simple and portable (in several senses ‚Äî don't want to be tied to any particular host platform either).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:27:30.012Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:27:30.012Z" class="date">2024-07-31 20:27:30</a> <div class="message"><p>To the extent that we have a build script at all, the reason to have multiple impls is to allow people to run it locally without prescribing a single ecosystem (eg: npm). But that's not the same goal as "support every language in existence".</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:28:50.026Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:28:50.026Z" class="date">2024-07-31 20:28:50</a> <div class="message"><p>Yeah, fair. I can live with a markdown subset. We just need to be able to clearly communicate what subset it is, that'll be part of the authoring experience.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T20:28:51.078Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T20:28:51.078Z" class="date">2024-07-31 20:28:51</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> I meant OhmJS, sorry.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-31T21:17:19.418Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-28&amp;toDate=2024-08-03&amp;channel=devlog-together&amp;filter=#2024-07-31T21:17:19.418Z" class="date">2024-07-31 21:17:19</a> <div class="message"><p><a href="http://ivanish.ca/">Ivan Reese</a> In your defence, a bird in the hand is worth two in the bush. And, my opinion is highly polluted by the notion that most existing 3GLs (Python, Haskell, WASM, etc.) are just assemblers and that OhmJS is the vehicle for making zillions of little DSLs using these assemblers.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T06:20:51.838Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T06:20:51.838Z" class="date">2024-08-01 06:20:51</a> <div class="message"><p>We are re-enacting "worse is better" here: go for a simple solution that does 90% of the job and leaves the remaining 10% to the user to deal with? Or go for the Right Thing with a proper parser and proper error messages, at the cost of more code and some dependencies?</p>
<p>The relevant question then is: will our users (present and future community members) be able to deal with the 10%, or will they give up when they can't get their contribution to render correctly?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T14:19:13.367Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T14:19:13.367Z" class="date">2024-08-01 14:19:13</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> But what different set of tradeoffs would you make? Can you find one that might better satisfy more people?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T14:36:56.473Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T14:36:56.473Z" class="date">2024-08-01 14:36:56</a> <div class="message"><p>Not to ignore your question, though it seemed a bit rhetorical: I don't think the regex will produce an unsatisfying result 10% of the time ‚Äî not to take the idiom literally, but we're engineers, so let's try to work with realistic numbers. I think it'd be more like 0.01% or 0.001%, and the failure mode would be rendered text that visibly doesn't match your intent, not a silent failure. The ultimate fallback in that case is likely "just write that bit in html". My hunch is that people will generally prefer writing in the subset of md, and would more often hit a case where plain html fails them (they miss a closing tag, say) than where the md regex fails them.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T14:39:34.482Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T14:39:34.482Z" class="date">2024-08-01 14:39:34</a> <div class="message"><p>Shipping a bigger, more complex build script will make it harder to port and maintain the build script in multiple ecosystems. That'll mean fewer people use the build script locally, relying on the build step that runs on push. That's a much longer feedback loop.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T19:09:41.509Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T19:09:41.509Z" class="date">2024-08-01 19:09:41</a> <div class="message"><p>I think we have something similar to <a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zookoo's triangle</a>: out of three desirable characteristics, we can pick any two. The three are:</p>
<ul><li>Simple build system</li><li>User-friendly input syntax (Markdown)</li><li>Well-specficied build system (meaning an input format specification that actually corresponds to what the parser takes)</li></ul><p>If we give up 1, we use a Markdown-to-HTML compiler with a parser for something well-defined (Commonmark, djot, etc.).</p>
<p>If we give up 2, we use HTML as our direct input format.</p>
<p>If we give up 3, we use some regexp-munging for transforming something Markdown-like to something HTML-like.</p>
<p>My personal order of preference is 2, 1, 3 (the number being the feature I am willing to give up). I am not going to give any arguments, because I can easily give arguments for any of the three choices. It really comes down to weighing them against each other.</p>
<p>If everyone agrees that these are the trade-offs, we could do a poll to see what we mostly care about.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-01T20:09:43.612Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-29&amp;toDate=2024-08-04&amp;channel=devlog-together&amp;filter=#2024-08-01T20:09:43.612Z" class="date">2024-08-01 20:09:43</a> <div class="message"><p>I appreciate the effort to find a framing that helps us think about this issue. But I disagree with the premise behind this particular framing. I think all 3 are achievable, and are already sufficiently achieved for the immediate needs of this project. The parsing worries expressed in this thread are missing the point of markdown. (For those who know their markdown history ‚Äî I side solidly with Gruber, and solidly against Atwood.)</p>
<p>I'm going to go ahead and ship what I've got. That's the spirit I'd like to engender with this project ‚Äî just get something out there, it doesn't have to be perfect. If people try to use it and find that something about the setup impedes their desire or ability to contribute to the wiki, we can work on that concrete problem. I don't expect that what I have will work perfectly, especially not at first. That's a non-goal. The goal is to get people writing wiki entries.</p>
<p>(And because I love a framing, even one I disagree with: 3, ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶  1, 2)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-08-02T07:41:11.469Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-30&amp;toDate=2024-08-05&amp;channel=devlog-together&amp;filter=#2024-08-02T07:41:11.469Z" class="date">2024-08-02 07:41:11</a> <div class="message"><p>My point 3 indeed assumes Atwood's perspective on Markdown ("Markdown is a formal language"). I have a lot of sympathy for Gruber's view ("Markdown is a notation") but judging from the Markdown use cases I have experience with, it has failed in practice. It could perhaps be implemented robustly using AI, but there isn't much money to be made there so it won't happen.</p>
<p>Side note: Markdown history deserves being studied in detail because it showcases many general issues with human-computer interfaces.</p>
<p>That said, please go on with your project. "We believe in rough consensus and running code."</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-08-04T20:03:05.237Z" class="post"><span class="user">Maikel van de Lisdonk</span> <a href="https://history.futureofcoding.org/?fromDate=2024-08-01&amp;toDate=2024-08-07&amp;channel=devlog-together&amp;filter=#2024-08-04T20:03:05.237Z" class="date">2024-08-04 20:03:05</a> <div class="message"><p>Hi, Because I want to understand better how neural networks work and can be trained, the best way to do is, is by building a small one from scratch myself and training it.</p>
<p>In this video <a href="https://youtu.be/TG9TGqM9HCs">youtu.be/TG9TGqM9HCs</a> I show creating and connecting a few neural-nodes together and a show a very small prebuilt neural network.</p>
<p>To be able to do this, I've created 4 new node-types in my visual programming system: neural-input-node, neural-bias-node, neural-node and neural-output-node.. the first 3 output weighted connections. This means that a weight property is attached to the connection and can be changed.. the neural-node and neural-output-node use these weights in there respective calculations.</p>
<p>The neural-node currently uses sigmoid as its activation function.</p>
<p>The neural-bias-node only outputs a value of 1 and the output value of a neural-input-node can be changed. When any of these values are changed, they propagate forward through the network.</p>
<p>In the current example flow, an error is also calculated using an expression node-type depending on the output and expected value.</p>
<p>The white object-node is also a new node-type and can be used to obtain multiple values and output them in a single object.</p>
<p>In the near future I hope to implement a neural network that can be trained with the mnist digit dataset, but I have to do a lot more work before I am at that stage I think.</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://youtu.be/TG9TGqM9HCs">work in progress: building a neural network using code-flow-canvas</a></p>
<p><img src="https://i.ytimg.com/vi/TG9TGqM9HCs/hqdefault.jpg" alt="work in progress: building a neural network using code-flow-canvas"></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div>
    </div>
  </body>
</html>
