
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-09-30T11:13:09.803Z" class="post"><span class="user">Andreas S.</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-27&amp;toDate=2024-10-03&amp;channel=thinking-together&amp;filter=#2024-09-30T11:13:09.803Z" class="date">2024-09-30 11:13:09</a> <div class="message"><p>Hey üëã  I was recently searching again how "usable"  "AI" became. So I stumbled on this tool: <a href="https://pinokio.computer/">pinokio</a> . Its all just JSON. Before just evalutating the tool I might describe the criteria I would be interested in. Broadly speaking I would like to have tool similar to what we see in this clip: <a href="https://www.youtube.com/watch?v=HGYFEI6uLy0">youtube.com/watch?v=HGYFEI6uLy0</a></p>
<p>Consider The following more specific scenario:</p>
<p>I have a PKM Zettelkasten and I have some friends. Now my workflow is to write and then to publish. I want to provide for them a Voice assistant that can summarize contents based on various parameters: By time e.g. topics of last 3 months, last week. But I also want to provide overviews on specific topics as well as interesting interconnections.</p>
<p>Do you know of any tools that could help with creating such use cases?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2024-10-01T23:59:57.316Z" class="post"><span class="user">Tomas Petricek</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-28&amp;toDate=2024-10-04&amp;channel=thinking-together&amp;filter=#2024-10-01T23:59:57.316Z" class="date">2024-10-01 23:59:57</a> <div class="message"><p>This is a very random thought - but something that I've been occasionally wondering for some time now. If we have lambda calculus as a model of functional languages and Turing machines as a model of imperative languages, what would be a good model for programming systems that have "document" as the basic underlying structure (Subtext is an example of this) - i.e., you have some tree structure and the program evaluates by modifying this document - appending new things or rewriting evaluated bits. (Lambda calculus itself is basically a tree, but what if this also allows imperative document edits?)</p>
<p>Could this be something like a "Turing machine" that works on trees rather than tapes? There would be "current location" which can move in various ways around the tree and modify it. If your document has references (perhaps you can have  <code>../../foo</code>  to refer to  <code>foo</code>  of a parent of a parent), the machine would have to somehow walk up the tree, remembering that it wants to copy a value back to the original location - and then walk over the tree back to put the value in place of the reference).</p>
<p>Is this something completely silly or something that lots of people have already done but under different names?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-10-02T03:30:27.395Z" class="reply"><span class="user">Jimmy Miller</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T03:30:27.395Z" class="date">2024-10-02 03:30:27</a> <div class="message"><p>I might be missing some nuance here. But what you are describing sounds to me pretty similar to term or graph rewriting systems. <a href="https://en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems">en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems</a> They are Turing complete formalism. And there has been plenty of working using them for transforming documents, but also general evaluation. They do work exactly as you described. You have a tree structure and you modify it by rewriting things. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T05:32:27.660Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T05:32:27.660Z" class="date">2024-10-02 05:32:27</a> <div class="message"><p>Supporting <a href="https://jimmyhmiller.github.io/">Jimmy Miller</a>'s suggestion because that's exactly how my <a href="https://leibniz.khinsen.net/">Digital Scientific Notation</a> works. It's a term rewriting system embedded in a Wiki-like graph of cross-linked pages.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T06:04:05.817Z" class="reply"><span class="user">Jack Rusher</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T06:04:05.817Z" class="date">2024-10-02 06:04:05</a> <div class="message"><p>Note also that Lisp was originally conceived of as an automated form of term rewriting, the keyword ‚Äúlambda‚Äù having been borrowed based on an incomplete understanding of Church‚Äôs paper. The first Lisp that was actually based on the lambda calculus was scheme.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T08:23:56.296Z" class="reply"><span class="user">Duncan Cragg</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T08:23:56.296Z" class="date">2024-10-02 08:23:56</a> <div class="message"><p>you're getting some "already done under different names", so I'll add mine! my PL is really just a graph rewriter.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T14:35:46.740Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T14:35:46.740Z" class="date">2024-10-02 14:35:46</a> <div class="message"><p><strong>@Robin Allison</strong>'s <a href="https://history.futureofcoding.org/?fromDate=2024-09-22&amp;toDate=2024-09-28&amp;channel=linking-together&amp;filter=#2024-09-25T06:54:58.811Z">üí¨ #linking-together@2024-09-25</a> seems tantalizingly related, but breaks my brain to think about..</p>
</div> <div class="attachments"><blockquote><p>[September 24th, 2024 11:54 PM] robinps2: Hey future of coding folks,</p>
<p>I want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.</p>
<p>Picture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.</p>
<p>If you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.</p>
<p>A key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.</p>
<p>Another key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.</p>
<p>We can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.</p>
<p>A reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.</p>
<p>I'll leave it at that.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-10-02T21:59:51.078Z" class="reply"><span class="user">Tomas Petricek</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T21:59:51.078Z" class="date">2024-10-02 21:59:51</a> <div class="message"><p>Term rewriting is a nice reference I did not think of! I guess one difference between those and what I've been thinking about is that I imagined that you'd have a special "current" location in the tree (like instruction pointer...).</p>
<p>You can certainly do this with term rewriting systems too though, if you just have a special term like  <code>[X]</code>   that marks the term/tree node  <code>X</code>   as being the current one.</p>
<p>I guess term rewriting systems are basically how people define operational semantics of programming languages. It's strange people do not talk more about the connection between the two!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T22:04:17.735Z" class="reply"><span class="user">Tomas Petricek</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T22:04:17.735Z" class="date">2024-10-02 22:04:17</a> <div class="message"><p><strong>@Robin Allison</strong>'s idea reminded me of something I wrote about in a post inspired by spaces in cities (see <a href="https://tomasp.net/blog/2023/vague-spaces/">tomasp.net/blog/2023/vague-spaces</a>) There are some thoughts about how programs live in a different kind of space than cities (which have fixed space they have to fit into, whereas program spaces can expand - but spreadsheet space expands in only limited ways - you cannot create arbitrary amount of space in any particular location - which I guess this idea was getting at?).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-02T22:11:13.490Z" class="reply"><span class="user">Tomas Petricek</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-29&amp;toDate=2024-10-05&amp;channel=thinking-together&amp;filter=#2024-10-02T22:11:13.490Z" class="date">2024-10-02 22:11:13</a> <div class="message"><p>... but using some kind of term rewriting system as the basis for document-like programming systems seems like a nice way of doing things - and it looks like there's lots of (some, at least) people here thinking in this direction!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T06:14:47.586Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T06:14:47.586Z" class="date">2024-10-03 06:14:47</a> <div class="message"><p>Maybe term rewriting systems  <em>should</em>  have something like a "current node". Rule application order is something usually swept under the rug. It's there, but everybody hopes it doesn't matter, and it's usually implicit (part of the rewriting engine) rather than explicit (part of the rule set).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T06:22:00.898Z" class="reply"><span class="user">Robin Allison</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T06:22:00.898Z" class="date">2024-10-03 06:22:00</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> I think there might be a connection here too. I don‚Äôt know if I can speak to document-based languages in general, but at least for subtext, there is the loose connection in that both are based on spreadsheets. Beyond that non-abelian spreadsheets serve as mathematical models, although they aren‚Äôt models of computation specifically. They actually take computation mostly for granted, although I think that can be an interesting perspective too. When I was first reading Tomas‚Äô question it occurred to me that non-abelian spreadsheets could be thought of as a model of the ‚Äòdocument‚Äô part of ‚Äòdocument-based programs‚Äô.</p>
<p><strong>@Tomas Petricek</strong> Part of the point is absolutely that the space these things is is fixed, has particular characteristics, and is not created arbitrarily. I‚Äôm not sure if this makes them less like regular programs though. Generally the space of a non-abelian spreadsheet is far more expansive than the two dimensional space of a spreadsheet or paper or city. For one the ‚Äútwo dimensional‚Äù non-abelian spreadsheet has uncountably many cells, whereas a normal spreadsheet has countably many cells. And this only gets worse in the countably infinite dimensional case you need to account for syntax trees.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T11:21:27.856Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T11:21:27.856Z" class="date">2024-10-03 11:21:27</a> <div class="message"><p><strong>@Tomas Petricek</strong></p>
<p>1) WRT to "current node", we already know how to do this using textual code and have many programming languages for this purpose. So, divide-and-conquer says that all you need to do is to map "trees" onto textual code, then you're done.</p>
<p>2) Here is my (probably over-simplified) understanding of term rewriting augmented by the concept of "current node":</p>
<ul><li>Programmer writes an AST (the "inhaler AST")</li><li>Programmer writes a 1:1 corresponding rewrite AST that dove-tails with the inhaler AST. (Or, programmer annotates the above inhaler AST (this, though, violates the principles of KISS and human-readability))</li><li>Term rewriter app inhales linear text and makes a CST (concrete parse tree) by culling the AST driven by the inhaled text (commonly known as "parsing")</li><li>Term rewriter app walks the rewrite AST using the newly-created CST.</li><li>Term rewriter app unparses the rewritten walked-tree into (new) linear text ("code").</li><li>Run the generated code.</li></ul><p>If that's even close to what you're imagining, then I contend that this is "easily possible" to do using modern technology whilst loosening the thumbscrews, i.e. using OhmJS plus a nano-DSL written in OhmJS. I call it "t2t" (text-to-text transpilation) and am actively experimenting with it and its implications (meta-syntaxes, metaprogramming, etc.). More info/blather/discussion if interested.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T13:14:03.777Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T13:14:03.777Z" class="date">2024-10-03 13:14:03</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> The problem with your proposal is that it doesn't fit the way rewriting-based documents are used in practice. They are more like spreadsheets. The fundamental action of the computer is not "run a program" but "update everything after the user has made a change to the document". The point of a "current node", as I see it, would be to make it clearer to the user what exactly happens during such an update. It's more of a user interface than a programming issue.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-04T09:45:42.700Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-01&amp;toDate=2024-10-07&amp;channel=thinking-together&amp;filter=#2024-10-04T09:45:42.700Z" class="date">2024-10-04 09:45:42</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> Continuing to ponder, some half-baked thoughts:</p>
<p>1) "run a program" and "update everything after the user has made a change to the document" are the same thing, except maybe differing in speed ; if your machine is fast enough, there is no point in trying to optimize the update by keeping update pointers, just re-do the whole thing in one fell swoop so fast that a human user perceives them to both be the same ; you want the action(s) to "feel" like a REPL</p>
<p>2) possible relationship: "... current node ... a user interface than a programming issue ..." ; Lisp lists are "trees". I use a Lisp debugger (Lispworks) that lets me single step through Lisp code ("trees") in the same way that an assembler debugger lets me step through lines of code ; does this sound like "current node"-iness?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-05T12:45:31.851Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-02&amp;toDate=2024-10-08&amp;channel=thinking-together&amp;filter=#2024-10-05T12:45:31.851Z" class="date">2024-10-05 12:45:31</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> I guess we first have to agree on what we mean by "program", in particular if and how it is distinct from "input data". At the bit level, there is no such distinction. Both program and input data are bit patterns in memory that the computer acts on. But in what I see as the most common usage of the term, a "program" is something long-lived that reads "input data" for one of its many execution phases. With that distinction in place, it's the rewriting engine that is the program, and all the rules and terms/graphs to be rewritten are input data. Just like Excel is the program and all of the spreadsheet, including the formulas, is input data. But if you look at it from the point of view of semantics, it's the rewrite rules that are the program. Which are changed all the time in a computational document. Describing the interaction between a human and a computer via a rewriting-based document is running generated code is not wrong, but it's not helpful either unless you are thinking about writing a rewrite rule compiler.</p>
<p>As for 2), that's a very nice example. But I haven't seen anything similar for rewriting. I tried building my own, but gave up because it turned out not to be that useful. I came up with different debugging tools, none of which traces the work done by the computer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-06T01:09:06.384Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-03&amp;toDate=2024-10-09&amp;channel=thinking-together&amp;filter=#2024-10-06T01:09:06.384Z" class="date">2024-10-06 01:09:06</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a>, You touch upon a good point. My feeling about "what is a program" is somehow different and I'm struggling to put it into words.</p>
<p>Observation / pondering: control flow is not data. Smalltalk's encapsulation of data is not sufficient to isolate control flow, like how Unix pipelines isolate control flow.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-06T08:38:38.216Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-03&amp;toDate=2024-10-09&amp;channel=thinking-together&amp;filter=#2024-10-06T08:38:38.216Z" class="date">2024-10-06 08:38:38</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> Smalltalk is an interesting case. Control flow in Smalltalk is entirely implemented in terms of the method dispatch algorithm. That's similar to rewrite engines in that it's hidden from view. All you see in the code is messages sent around.</p>
<p>That's somewhat unrelated to your observation that data encapsulation doesn't imply control flow encapsulation. Or maybe it is related. I am decided for now.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-06T10:29:39.504Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-03&amp;toDate=2024-10-09&amp;channel=thinking-together&amp;filter=#2024-10-06T10:29:39.504Z" class="date">2024-10-06 10:29:39</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> Aye, and there's the rub. In my books, Smalltalk does not do message-passing (!). Smalltalk does method-calling. Method-calling involves blocking. Blocking is usually implemented as a state machine that performs low-level synchronization. In my mind, message-passing is "fire and forget".</p>
<p>Blocking mixed with FTL (faster-than-light) rewriting ("referential transparency") works when your medium is paper, but, is overly-restrictive when your medium is reprogrammable electronic machines (aka "computers").</p>
<p>Continued...<a href="https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky">programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky">Control Flow is Not Data</a></p>
<p>2024-10-06</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-10-06T14:06:13.895Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-10-03&amp;toDate=2024-10-09&amp;channel=thinking-together&amp;filter=#2024-10-06T14:06:13.895Z" class="date">2024-10-06 14:06:13</a> <div class="message"><p>FWIW, some brainstorming, trying to get back to the original question <a href="https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky">programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky">Tree Current Node Brainstorming</a></p>
<p>2024-10-06</p>
</blockquote>
</div> <div class="files"></div></div></div></div><div id="2024-10-03T00:52:53.338Z" class="post"><span class="user">Rafi Khan</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T00:52:53.338Z" class="date">2024-10-03 00:52:53</a> <div class="message"><p>Would anyone be interested in a browser based smalltalk environment that tries to simplify the task of building software?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-10-03T00:53:55.330Z" class="reply"><span class="user">Rafi Khan</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T00:53:55.330Z" class="date">2024-10-03 00:53:55</a> <div class="message"><p>The idea of the product is to have an all in one software development tool that let's you write code, run tests, deploy etc. </p>
<p>It will also be backed by a github like social coding repo system so you can easily import code that others have written</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T00:55:13.521Z" class="reply"><span class="user">Rafi Khan</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T00:55:13.521Z" class="date">2024-10-03 00:55:13</a> <div class="message"><p>The main reason I think this would be neat is to get more people into programming or solving problems with computers. </p>
<p>They can mostly fork/remix existing code and only a portion of the users are likely to be professional developers who may be maintaining some of the libraries</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T00:56:44.621Z" class="reply"><span class="user">Rafi Khan</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T00:56:44.621Z" class="date">2024-10-03 00:56:44</a> <div class="message"><p>I'm not sure it solves any real problems. Yes it aims to make software easier and cheaper to write, but maybe businesses aren't too worried about optimising software development? </p>
<p>It would be a new language and completely foreign tool, and i think this has already held back lisp and smalltalk before</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T00:57:44.723Z" class="reply"><span class="user">Rafi Khan</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T00:57:44.723Z" class="date">2024-10-03 00:57:44</a> <div class="message"><p>I was thinking if the entire system was essentially source available, and you can hook in a small llm agent that can generate and run code, we might get a slightly more general ai assistant</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T06:19:39.258Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T06:19:39.258Z" class="date">2024-10-03 06:19:39</a> <div class="message"><p>You mean something like <a href="https://amber-lang.net/">Amber Smalltalk</a>, which is an actual Smalltalk environment running in the browser? Or something like <a href="https://lively-kernel.org/">Lively Kernel</a>, the same overall idea but in JavaScript?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-10-03T13:10:15.855Z" class="reply"><span class="user">Erik Stel</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-30&amp;toDate=2024-10-06&amp;channel=thinking-together&amp;filter=#2024-10-03T13:10:15.855Z" class="date">2024-10-03 13:10:15</a> <div class="message"><p>[Shameless plug approaching] Or using something like CodeParadise to run Smalltalk in the browser as well as on the server. <a href="https://github.com/ErikOnBike/CodeParadise">github.com/ErikOnBike/CodeParadise</a></p>
<p><strong>@Rafi Khan</strong> I'm also interested in this topic. (The start of CodeParadise was to create a development environment for kids.). My current idea (only in thought, nothing tried out yet) is to have a language like Smalltalk, but without the static class hierarchy. Somewhere between Self and Smalltalk. Allowing the addition and removal of behaviour to/from objects. Using the Smalltalk syntax. The static class hierarchy sometimes feels as a hindrance. Only if you're already comfortable with such a structure and/or can do the 'abstraction thing' you're able to create class hierarchies that actually work/are beneficial (even in the long(er) run).</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
