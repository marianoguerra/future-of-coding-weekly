
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-03-04T03:11:45.644Z" class="post"><span class="user">Ivan Reese</span> <a href="./?fromDate=2024-03-01&amp;toDate=2024-03-07&amp;channel=share-your-work&amp;filter=#2024-03-04T03:11:45.644Z" class="date">2024-03-04 03:11:45</a> <div class="message"><p><a href="https://futureofcoding.org/episodes/070">Future of Coding 70 ‚Ä¢ Beyond Efficiency</a> by <strong>@Dave Ackley</strong></p>
<p>Dave Ackley‚Äôs paper Beyond Efficiency is three pages long. With just these three pages, he mounts a compelling argument against the conventional way we engineer software. Instead of inflexibly insisting upon correctness, maybe allow a lil slop? Instead of chasing peak performance with cache and clever tricks, maybe measure many times before you cut. So in this episode, we‚Äôre putting every CEO in the guillotine‚Ä¶ (oh, that stands for ‚Äúcorrectness and efficiency only‚Äù, don‚Äôt put us on a list)‚Ä¶ and considering when, where, and how to do the robust thing.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-04T19:41:03.015Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2024-03-01&amp;toDate=2024-03-07&amp;channel=share-your-work&amp;filter=#2024-03-04T19:41:03.015Z" class="date">2024-03-04 19:41:03</a> <div class="message"><p>I was unaware of the Knuth response to Naur. Thanks for mentioning it! I found a copy at</p>
<p><a href="https://tug.org/TUGboat/tb10-4/tb26complete.pdf">tug.org/TUGboat/tb10-4/tb26complete.pdf</a></p>
<p>Knuth invented a new kind of documentation, one that hardly anyone uses, but that is specifically designed for communicating how a program works to other human beings.</p>
<p>Knuth has also expended great effort in the study of other people's code and programs, including code written in long dead programming languages.</p>
<p>If there is anyone in the world capable of transcending the limits described by Peter Naur, both by transmitting the theory of a program and by recreating it, it would be Donald Knuth. I see no reason to doubt the truth of Knuth's claims, but I also don't see them as contradicting Naur.</p>
<p>Naur does not claim it is impossible to revive a program in practical terms, only that it is difficult, frustrating, and time-consuming, and "may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text." I believe his point is that you cannot be certain the revived theory is the same as the original theory, however I do not have enough experience with literate programming to judge Knuth's claim that a well-written literate program might have a good chance of being accurately revived.</p>
<p>Calling the stored program computer a "von Neumann model" does a tremendous disservice to J. Presper Eckert who invented and wrote up the idea around 6 months before von Neumann joined the ENIAC project. See the book A History of Computing in the
Twentieth Century for a copy of the original memo.</p>
<p>von Neumann wrote a draft report that was widely shared informally (<a href="https://en.m.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC">en.m.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC</a>), but to the best of my knowledge he never claimed the ideas were his. He was writing up the ENIAC team's plans for the EDVAC.</p>
<p>Y'all may also enjoy von Neumann's paper "PROBABILISTIC LOGICS AND THE SYNTHESIS OF RELIABLE</p>
<p>ORGANISMS FROM UNRELIABLE COMPONENTS." <a href="https://static.ias.edu/pitp/archive/2012files/Probabilistic_Logics.pdf">static.ias.edu/pitp/archive/2012files/Probabilistic_Logics.pdf</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-04T21:10:00.804Z" class="reply"><span class="user">Daniel Buckmaster</span> <a href="./?fromDate=2024-03-01&amp;toDate=2024-03-07&amp;channel=share-your-work&amp;filter=#2024-03-04T21:10:00.804Z" class="date">2024-03-04 21:10:00</a> <div class="message"><p>I was glad to hear the new discussion generated by Programming as Theory Building - both the episode and the paper. It is my favourite episode and was very influential on me!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-05T02:38:37.008Z" class="reply"><span class="user">Tom Lieber</span> <a href="./?fromDate=2024-03-02&amp;toDate=2024-03-08&amp;channel=share-your-work&amp;filter=#2024-03-05T02:38:37.008Z" class="date">2024-03-05 02:38:37</a> <div class="message"><p>I appreciated the examples of non-distributed systems that benefit from robustness that had to do with being robust to  ~<em><em>programmer error</em></em>~ . That type of error is harder to characterize than the random bit-flipping of cosmic rays because it‚Äôs so human, but it‚Äôs the type of error that I most often think of robustness in terms of.</p>
<p>I didn‚Äôt have as good a word for it before. ‚ÄúDefensive programming‚Äù doesn‚Äôt really capture it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-05T02:48:36.754Z" class="reply"><span class="user">Tom Lieber</span> <a href="./?fromDate=2024-03-02&amp;toDate=2024-03-08&amp;channel=share-your-work&amp;filter=#2024-03-05T02:48:36.754Z" class="date">2024-03-05 02:48:36</a> <div class="message"><p>Implementing invariants directly like Jimmy mentioned. Sort the thing every time if it‚Äôs supposed to be sorted, rather than trying to maintain that property indirectly. It‚Äôs not just about doing the easiest thing first, or avoiding premature optimization. It‚Äôs like, when I mess up code elsewhere, how do I make sure that this part won‚Äôt make it worse.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-05T02:48:54.486Z" class="reply"><span class="user">Tom Lieber</span> <a href="./?fromDate=2024-03-02&amp;toDate=2024-03-08&amp;channel=share-your-work&amp;filter=#2024-03-05T02:48:54.486Z" class="date">2024-03-05 02:48:54</a> <div class="message"><p>I dunno, good episode.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T05:13:12.163Z" class="reply"><span class="user">Alexander Bandukwala</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T05:13:12.163Z" class="date">2024-03-06 05:13:12</a> <div class="message"><p>I still haven‚Äôt read the paper but one aspect of the episode I found interesting was that having simpler software avoids bugs. It seems like this is being conflated with the idea of sacrificing efficiency for robustness. Where sometimes the simpler code/algorithm is in fact less robust and the more robust implementation requires more code (and potentially more bugs).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T05:18:54.819Z" class="reply"><span class="user">Alexander Bandukwala</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T05:18:54.819Z" class="date">2024-03-06 05:18:54</a> <div class="message"><p>I‚Äôd be interested in trying to disentangle the robustness from the simplicity dimensions when making tradeoffs. So finding new ways to structure software to be inherently more robust to bugs seems compelling yet difficult.</p>
<p>Overall the contention between correctness, efficiency, and robustness seems to arise from the viewpoint that correctness is a binary proposition rather than a probabilistic measurement of the values we want our software to achieve. If we have a myopic view of correctness we‚Äôre leaving all the tradeoffs off the table.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T05:20:51.625Z" class="reply"><span class="user">Ivan Reese</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T05:20:51.625Z" class="date">2024-03-06 05:20:51</a> <div class="message"><p>Something we ought to consider ‚Äî was <a href="https://en.m.wikipedia.org/wiki/Stuxnet">stuxnet</a> robust-first?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T05:22:07.989Z" class="reply"><span class="user">Ivan Reese</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T05:22:07.989Z" class="date">2024-03-06 05:22:07</a> <div class="message"><p>And yeah ‚Äî I'm no friend to binary views of correctness! Glad to be reminded of that.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T08:18:07.015Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T08:18:07.015Z" class="date">2024-03-06 08:18:07</a> <div class="message"><p><a href="http://ivanish.ca/">Ivan Reese</a> loved the musical interlude and the mix on the quotation effect seemed perfectly dialed in.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-08T02:45:40.709Z" class="reply"><span class="user">Scott Antipa</span> <a href="./?fromDate=2024-03-05&amp;toDate=2024-03-11&amp;channel=share-your-work&amp;filter=#2024-03-08T02:45:40.709Z" class="date">2024-03-08 02:45:40</a> <div class="message"><p>Reminds me of how analog computers can be more robust because they arent susceptible to things like accidental, cosmic ray style, bit flips causing a major change in the value of the computation. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-08T03:07:58.877Z" class="reply"><span class="user">Ivan Reese</span> <a href="./?fromDate=2024-03-05&amp;toDate=2024-03-11&amp;channel=share-your-work&amp;filter=#2024-03-08T03:07:58.877Z" class="date">2024-03-08 03:07:58</a> <div class="message"><p>Right. Though they then need to be robust against, say, results being influenced by ambient temperature :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-08T03:15:04.323Z" class="reply"><span class="user">Daniel Buckmaster</span> <a href="./?fromDate=2024-03-05&amp;toDate=2024-03-11&amp;channel=share-your-work&amp;filter=#2024-03-08T03:15:04.323Z" class="date">2024-03-08 03:15:04</a> <div class="message"><p>Deutsch discusses digital versus analogue at length in  <em>The Beginning Of Infinity</em> , here's a bit from that chapter-</p>
<blockquote><p>... during lengthy computations, the accumulation of errors due to things like imperfectly constructed components, thermal fluctuations, and random outside influences makes analogue computers wander off the intended computational path. This may sound like a minor or parochial consideration. But it is quite the opposite. Without error-correction all information processing, and hence all knowledge-creation, is necessarily bounded. ... So all universal computers are digital; and all use error-correction with the same basic logic that I have just described, though with many different implementations. Thus Babbage‚Äôs computers assigned only ten different meanings to the whole continuum of angles at which a cogwheel might be oriented. Making the representation digital in that way allowed the cogs to carry out error-correction automatically: after each step, any slight drift in the orientation of the wheel away from its ten ideal positions would immediately be corrected back to the nearest one as it clicked into place. Assigning meanings to the whole continuum of angles would nominally have allowed each wheel to carry (infinitely) more information; but, in reality, information that cannot be reliably retrieved is not really being stored.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-08T09:09:15.862Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2024-03-05&amp;toDate=2024-03-11&amp;channel=share-your-work&amp;filter=#2024-03-08T09:09:15.862Z" class="date">2024-03-08 09:09:15</a> <div class="message"><p>An analog virtue / limitation is that you cannot have a huge tower of abstraction because noise accumulates: indirection has a direct cost!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-08T14:20:17.349Z" class="reply"><span class="user">Ivan Reese</span> <a href="./?fromDate=2024-03-05&amp;toDate=2024-03-11&amp;channel=share-your-work&amp;filter=#2024-03-08T14:20:17.349Z" class="date">2024-03-08 14:20:17</a> <div class="message"><p>Relevant reading folks might enjoy: <a href="https://arxiv.org/pdf/1811.09989.pdf">The dry history of liquid computers</a> </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-11T01:31:25.544Z" class="reply"><span class="user">Tony Fader</span> <a href="./?fromDate=2024-03-08&amp;toDate=2024-03-14&amp;channel=share-your-work&amp;filter=#2024-03-11T01:31:25.544Z" class="date">2024-03-11 01:31:25</a> <div class="message"><p>Thanks for the great episode. "The Fiverr Vaccine" was super funny. And I loved reading the paper.</p>
<p>I started out robustbrained. I was ready to salute the robustness flag. I started memorizing the robustness national anthem (which is twice as long as it needs to be).</p>
<p>But now it feels like that's missing the point...</p>
<p>I should be saluting the local first flag! I should sing the permacomputing national anthem and get my hair done at the convivial computing salon! These are actual value systems that imagine a different world and say "this would be better". Robustness is a means to an end, just like efficiency.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-01-06T19:02:44.240Z" class="post"><span class="user"></span> <a href="./?fromDate=2024-01-03&amp;toDate=2024-01-09&amp;channel=share-your-work&amp;filter=#2024-01-06T19:02:44.240Z" class="date">üï∞Ô∏è 2024-01-06 19:02:44</a> <div class="message"><p>...</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-04T15:14:25.469Z" class="reply"><span class="user">Stefan Lesser</span> <a href="./?fromDate=2024-03-01&amp;toDate=2024-03-07&amp;channel=share-your-work&amp;filter=#2024-03-04T15:14:25.469Z" class="date">2024-03-04 15:14:25</a> <div class="message"><p>As I keep writing my article series <a href="https://stefanlesser.substack.com">On Simplicity‚Ä¶</a> I‚Äôd like to further improve it with feedback and have now set up a first online discussion for it.</p>
<p>On  <em>Thursday, March 14th</em>  we‚Äôll start with discussing the first post in the series. You don‚Äôt need to be familiar with the whole series; just reading the first post is recommended but not required. Have a look at the <a href="https://lu.ma/p1p4b52k">Luma invite</a> for the exact time in your time zone and to sign up (it‚Äôs a free event via Zoom).</p>
<p>Would be great to have some of you there!</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-03-05T18:31:27.346Z" class="post"><span class="user">Luifer De Pombo</span> <a href="./?fromDate=2024-03-02&amp;toDate=2024-03-08&amp;channel=share-your-work&amp;filter=#2024-03-05T18:31:27.346Z" class="date">2024-03-05 18:31:27</a> <div class="message"><p>sharing some recent thoughts I have had about verifying LLM-generated bugfixes automatically with cloud infrastructure: <a href="https://lfdepombo.com/cloudbugfix">lfdepombo.com/cloudbugfix</a>. Today we validate LLM-generated code by looking at it or manually running it within our codebase. However if the expected behavior of the code is verifiable, there is a less painful workflow where the mistakes made by the LLM are not visible to us.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2024-03-06T13:13:49.580Z" class="post"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:13:49.580Z" class="date">2024-03-06 13:13:49</a> <div class="message"><p>Alrighty, here's the post I mentioned I'd make in <strong>#introduce-yourself</strong>:</p>
<p>I want to create a computing ecosystem that solves most of the problems in what I call 'unregulated I/O'.</p>
<p>It is quite possibly mad. Or it might work, and I will be surprised.</p>
<p>It takes design cues from <a href="https://en.wikipedia.org/wiki/Oberon_(operating_system)">Oberon</a>, <a href="https://github.com/google/flatbuffers">FlatBuffers</a>, <a href="https://ipfs.tech/">IPFS</a>, <a href="https://git-scm.com/">Git</a>, <a href="https://www.rust-lang.org/">Rust</a>.</p>
<p>It also sounds dangerously close to the kind of "great idea" a compsci undergrad would come out with. Yet, I am running out of reasons why this isn't possible (at the very least). This is why I want your opinions üòÖ</p>
<p>That's all I'll say here - rest is in the üßµ</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-06T13:14:33.830Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:14:33.830Z" class="date">2024-03-06 13:14:33</a> <div class="message"><p>So, I've got a problem with this thing I called 'unregulated I/O'. Here's what I mean by this:</p>
<ul><li>Unix set the standard of modelling files as byte arrays in the 70s.</li><li>Likewise, storage I/O, IPC and RPC is mostly done via byte array. There are some exceptions - for example:</li></ul><ul><li>The OS normally abstracts away most packet handling up to the transport layer.</li><li>Windows has dabbled with wacky ports (COM1 et al.)</li></ul><ul><li>This means that application programs have the responsibility of validating the binary data loaded via I/O.</li></ul><ul><li>Improper validation accounts for the vast majority of attack vectors (especially if we include memory management bugs).</li><li>Most modern applications employ widely-used libraries to minimise the amount of custom validation they have to perform, which is fair, because more eyes are on the libraries.</li></ul><p>Nevertheless, SQL injection and buffer overflows still happen in 2024. Exploit accessibility seems (to me) likely to increase with the employment of LLMs.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T13:14:48.708Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:14:48.708Z" class="date">2024-03-06 13:14:48</a> <div class="message"><p>I'm proposing that the Unix model should be replaced with something more secure by design:</p>
<ul><li>An abstract data model should be established for I/O:</li></ul><ul><li>The OS should abstract away a reasonable amount of validation.</li></ul><ul><li>Syscalls in applications would be typed. For Rustaceans, I/O calls would yield something like a  <code>std::io::Result&lt;T&gt;</code> .</li></ul><ul><li>The available types should include those that application programmers want to get I/O'd data into ASAP: scalars, arrays, maps, tuples/structs/enums (the latter of which should be <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Rusty</a>).</li><li>We would certainly require encapsulation, and (possibly) higher-kinded facilities like mixins.</li><li><em>All</em>  data in this system should be represented this way, including programs themselves.</li></ul><ul><li>This means that program source code is "already an AST".</li><li>Plain text would not be used for source code.</li><li>UI development for these 'structured languages' must be improved. (maybe I should've said Scratch was an influence? üòè)</li><li>These ASTs should be transformed by the OS into machine code (which can also be represented with this model: a  <code>.s</code>  file becomes an array of instruction enums).</li><li>Eventually, the OS running this should be able to self-host in this way.</li></ul><ul><li>Applications should barely ever concern themselves with any kind of binary data, though this is of course impossible to prevent in a Turing-complete environment.</li></ul><ul><li>Data, as stored, should be content-addressable:</li></ul><ul><li><a href="https://www.youtube.com/watch?v=lKXe3HUG2l4">Joe Armstrong</a> has plenty of reasons why this is a good idea (especially for greenfield).</li><li>The equivalent of a 'filesystem' for this ecosystem would instead be what is effectively a hashmap with wear leveling.</li></ul><ul><li>Or, <a href="https://www.theregister.com/2022/08/01/optane_intel_cancellation/">Optane</a> could be revived (some hope). Would be nice to design around this possibility.</li></ul><ul><li>'Files', now more accurately 'objects', are stored by a hash of their contents.</li></ul><ul><li>Important note: this is  <em>not</em>  object-oriented computing. We don't want to be piping vtables.</li></ul><ul><li>The need for encapsulation means that our 'filesystem' effectively becomes a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>.</li><li>In order to prevent massive hash cascades when writing to storage, we would need to employ mutable references (in a similar manner to symlinks).</li><li>Fast random-access updates to very large objects could be achieved with a hasher suited to incremental verification, such as <a href="https://github.com/BLAKE3-team/BLAKE3">BLAKE3</a>.</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T13:15:14.140Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:15:14.140Z" class="date">2024-03-06 13:15:14</a> <div class="message"><p>Here are some fun implications of such a design:</p>
<ul><li>New programming languages would be required.</li><li>Deduplication of data becomes trivial.</li></ul><ul><li>On the subject, we'd need to be mindful of granular we are with the storage of heavily-encapsulated objects.</li><li>Denormalisation should probably happen when eg. objects' raw data is less than the size of a hash digest (at the very least).</li></ul><ul><li>Transfer of large objects over a network can be heavily optimised. Downloads effectively become a  <code>git pull</code> .</li><li>Core web technologies such as HTTP, HTML, CSS &amp; JavaScript are no longer kosher, because they are based on plaintext.</li></ul><ul><li>"This obsoletes the web" is a silly thing to say, but could be fun in the pitch.</li><li>All of these formats  <em>could</em>  be transformed into the strongly-typed model presented above, though.</li></ul><ul><li>Tabs vs spaces is no longer a concern, because formatting is no longer a concern for plaintext. That's now the UI's responsibility.</li><li>Entire classes of attack should be all but eliminated (eg. injection).</li><li>The types used in the data model can themselves be represented in the data model, and we can relatively easily implement internationalisation for code:</li></ul><ul><li>Here's a horrible illustration:  <code>Enum Type { i8, i16, i32, i64, u8, u16, u32, u64, Array&lt;Type&gt;, Map&lt;Type, Type&gt;, Tuple&lt;Type, ...&gt;, Enum&lt;Array&lt;Type&gt;&gt; }</code></li><li>These types don't have canon names, and I don't think they should.</li><li>They do have hashes, though. So we can refer to types by their hash.</li><li>We can then map human translations for these types and their encapsulated members in any number of natural languages:  <code>Map Translations&lt;Tuple&lt;[Locale, Type]&gt;, Array&lt;String&gt;&gt;</code></li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T13:15:39.830Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:15:39.830Z" class="date">2024-03-06 13:15:39</a> <div class="message"><p>I appreciate this is a lot, so if you've taken the time to read this, thank you ‚ù§</p>
<p>Please shoot with your questions and comments. I've got some visual explainers for this stuff lying around which I'll probably add too.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T13:19:26.131Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T13:19:26.131Z" class="date">2024-03-06 13:19:26</a> <div class="message"><p>...oh, and: much as I've searched, I can't find a project that's attempting to create an entire ecosystem out of these principles (even if it's just using VMs rather than an entire OS). If you know of any project doing this, please let me know, because I suspect they're probably doing a better job.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:40:06.845Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:40:06.845Z" class="date">2024-03-06 17:40:06</a> <div class="message"><p>I see the main problem of your project in the wish to design a complex system from scratch. Such projects have basically always failed, for running out of steam before accomplishing anything useful.</p>
<p>One of the insights from John Gall's "Systems Bible" (highly recommended!) is (chapter 11):  "A complex system that works is invariably found to have evolved from a simple system that worked" with the corollary that "A complex system designed from scratch never works and cannot be made to work. you have to start over, beginning with a working simple system."</p>
<p>That's in fact how today's computing systems evolved over a few decades. The result is a bit of a mess, but it works. And it's so big by now that it cannot be replaced, only evolved.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-10T02:41:58.826Z" class="reply"><span class="user">Daniel Garcia</span> <a href="./?fromDate=2024-03-07&amp;toDate=2024-03-13&amp;channel=share-your-work&amp;filter=#2024-03-10T02:41:58.826Z" class="date">2024-03-10 02:41:58</a> <div class="message"><p>Are you familiar with <a href="https://www.unison-lang.org">unison lang</a> ? As you mentioned they aren‚Äôt attempting to create an entire ecosystem, but I think has a lot of overlap with your ideas</p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://www.unison-lang.org/">Unison | A friendly, statically-typed, functional programming language from the future ¬∑ Unison programming language</a></p>
<p>A friendly programming language from the future.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-03-10T07:56:15.774Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2024-03-07&amp;toDate=2024-03-13&amp;channel=share-your-work&amp;filter=#2024-03-10T07:56:15.774Z" class="date">2024-03-10 07:56:15</a> <div class="message"><p>Unison and IPFS are indeed the two main existing projects that have the most overlap. Neither tries a from-scratch approach. But unfortunately, the two don't really coexist well either, having their own content-addressing scheme each.</p>
<p>Another language in that space is <a href="https://scrapscript.org/">scrapscript</a>.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-11T09:46:00.473Z" class="reply"><span class="user">Doug Thompson</span> <a href="./?fromDate=2024-03-08&amp;toDate=2024-03-14&amp;channel=share-your-work&amp;filter=#2024-03-11T09:46:00.473Z" class="date">2024-03-11 09:46:00</a> <div class="message"><p>Thanks <a href="https://khinsen.net/">Konrad Hinsen</a> <a href="https://pel-daniel.github.io/cv/">Daniel Garcia</a> - those are exactly what I'm looking for üôè</p>
<p>I actually don't want to have to "make something big", because yeah, I've also seen countless examples of things of this scale failing (or worse, leaving a stain on its surroundings... (cough) Windows Registry). I don't want to have to make an OS, but having the entire software ecosystem playing to the same conceptual tune is going to make things all the more sound - if that makes sense.</p>
<p>Making a VM of it, in the same way as Unison or Scrapscript are doing (if I'm understanding them correctly), is where I'd want to start too. So I think I'm going to reach out to the authors of both and ask what they think about scaling them up.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-03-06T16:50:34.765Z" class="post"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T16:50:34.765Z" class="date">2024-03-06 16:50:34</a> <div class="message"><p>If you‚Äôve wondered:</p>
<ul><li>why the only copilot we have is for VSCode</li><li>why not every app is end-user programmable</li></ul><p>I wondered the same thing, and I‚Äôve built (<a href="https://omnipilot.ai">omnipilot.ai</a>), an AI copilot that works everywhere on macOS.</p>
<p>Specifically it lets you invoke GPT to type into any app ( <em>particularly interesting to me is it works great in Xcode</em> ), can also autocomplete text in any app, and lets you chat with GPT-4 with context from your recent apps. I‚Äôd really appreciate any feedback or first impressions!</p>
<p>Re end-user programmability I‚Äôm also working on making it more possible for people to make little ‚Äúautomations‚Äù on their computer, whether it‚Äôs adding buttons to Finder to convert files or recording little AI-enhanced macros.</p>
<p>Some specific questions I‚Äôd love feedback:</p>
<ul><li>How often do you find yourself wanting help editing code outside of a Github Copilot-enabled environment? What are those situations or apps?</li><li>What about text, do you wish you had a copilot for text too?</li><li>What do you think of the ‚Äúworks everywhere‚Äù approach vs. a dedicated app?</li><li>Do the AI-macros sound appealing or meh?</li><li>Any thoughts on the landing page copy/design?</li></ul><p>I‚Äôm also happy to answer any other questions. Thanks in advance for sharing your thoughts, it‚Äôs super helpful in shaping the product!</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-06T17:09:58.875Z" class="reply"><span class="user">Daniel Sosebee</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:09:58.875Z" class="date">2024-03-06 17:09:58</a> <div class="message"><p>Does it work in the terminal? That‚Äôs a big place I want autocomplete that I don‚Äôt currently have it.</p>
<p>edit: I have now checked out the landing page and see that it does üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:12:26.128Z" class="reply"><span class="user">Daniel Sosebee</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:12:26.128Z" class="date">2024-03-06 17:12:26</a> <div class="message"><p>Super cool. How do you build context? is it always based on the current text buffer?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:18:25.757Z" class="reply"><span class="user">Daniel Sosebee</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:18:25.757Z" class="date">2024-03-06 17:18:25</a> <div class="message"><p>It would be super cool if the clipboard contents were always appended to context. That way you could google/chatgpt a question, highlight and copy the answer, and then focus in your code editor etc. and get more relevant completions. In general I‚Äôm interested in UI that allows people to manage context more explicitly</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:29:47.658Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:29:47.658Z" class="date">2024-03-06 17:29:47</a> <div class="message"><p>Yes! Builds context based on what‚Äôs in the current app</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:30:01.668Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:30:01.668Z" class="date">2024-03-06 17:30:01</a> <div class="message"><p>when you select text and press Option Space</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:30:08.087Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:30:08.087Z" class="date">2024-03-06 17:30:08</a> <div class="message"><p>then that text goes into the context</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:32:42.086Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:32:42.086Z" class="date">2024-03-06 17:32:42</a> <div class="message">
</div> <div class="attachments"></div> <div class="files"><p>üé• <a href="http://history.futureofcoding.org/history/msg_files/F06/F06N5FD15CM.mp4">Screen slack.mp4</a></p>
</div></div><div id="2024-03-06T17:36:49.779Z" class="reply"><span class="user">Daniel Sosebee</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:36:49.779Z" class="date">2024-03-06 17:36:49</a> <div class="message"><p>Awesome, excited to try it out!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:51:18.694Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:51:18.694Z" class="date">2024-03-06 17:51:18</a> <div class="message"><p>also! you can also @tag windows that you‚Äôve had open recently to add them to the context in the option space chat</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-06T17:51:38.984Z" class="reply"><span class="user">Michael Jelly</span> <a href="./?fromDate=2024-03-03&amp;toDate=2024-03-09&amp;channel=share-your-work&amp;filter=#2024-03-06T17:51:38.984Z" class="date">2024-03-06 17:51:38</a> <div class="message"><p>and any recently selected text too</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-07T10:19:01.796Z" class="reply"><span class="user">Achille Lacoin</span> <a href="./?fromDate=2024-03-04&amp;toDate=2024-03-10&amp;channel=share-your-work&amp;filter=#2024-03-07T10:19:01.796Z" class="date">2024-03-07 10:19:01</a> <div class="message"><p>For the "copilot in the shell" usecase, there is <a href="https://butterfi.sh/">butterfi.sh</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://butterfi.sh/">Butterfish - A shell with AI superpowers</a></p>
<p>Add easy, context aware AI prompting with OpenAI to bash and zsh shells</p>
</blockquote>
</div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
