
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-03-26T02:27:50.923Z" class="post"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T02:27:50.923Z" class="date">2024-03-26 02:27:50</a> <div class="message"><p>At about 54:20+, Crockford ends up saying that types cause bugs. What are examples of those kinds of bugs?</p>
<p><a href="https://www.youtube.com/watch?v=XFTOG895C7c">youtube.com/watch?v=XFTOG895C7c</a></p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=XFTOG895C7c">The Better Parts. Douglas Crockford. JS Fest 2018</a></p>
<p><img src="https://i.ytimg.com/vi/XFTOG895C7c/hqdefault.jpg" alt="The Better Parts. Douglas Crockford. JS Fest 2018"></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2024-03-26T11:17:42.359Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T11:17:42.359Z" class="date">2024-03-26 11:17:42</a> <div class="message"><p>I think he's saying that having to bend your thoughts to suit or evade the type system causes the really tricky bugs because your natural train of thought or expectations have been disrupted.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T11:20:08.470Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T11:20:08.470Z" class="date">2024-03-26 11:20:08</a> <div class="message"><p>Which I agree with.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T11:34:56.015Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T11:34:56.015Z" class="date">2024-03-26 11:34:56</a> <div class="message"><p>I would have to go away and ponder good examples, but it'll be something around edge cases where a strict type doesn't capture the domain type</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T12:24:12.623Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T12:24:12.623Z" class="date">2024-03-26 12:24:12</a> <div class="message"><p>I agree. EEs use (or used to use when I learned how to design electronics) a concept more powerful than "types". It was called "design rules". You could specify - on a per project basis (instead of generalizing) - some rules / invariants that had to be upheld. For example "don't let parallel lines on a printed circuit board be longer than XX inches, (since long lines in parallel can cause noticeable cross-talk and this circuit is designed to tolerate only YYmicro-volts of cross-talk)", or, "this project uses ECL chips, ensure that lines on the PC are equal in length  (since the speed of light begins to matter and some signals might arrive before others)", etc. It seems to me that "dependent types" are a step in the direction of writing more-flexible programs about types (rather than writing programs about values in memory), which basically admits that most general purpose programming languages aren't really all that general (you get what the language designer thought was important, instead of what your project says is important)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T15:29:37.409Z" class="reply"><span class="user">Ionu»õ G. Stan</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T15:29:37.409Z" class="date">2024-03-26 15:29:37</a> <div class="message"><p>I fail to remember any situation in which I had a bug caused by a type system... The only way I can interpret his statement is that a type system might give you a false sense of safety (I never agreed to the Haskell mantra that if it compiles, then it must be correct, although it can and does happen), so you can then neglect test coverage.</p>
<p>More often than not the adamancy of a type system to accept my code forced me to become aware of intricacies in the domain model. Is it perfect? Nope, nothing is, but it's more helpful for me to use a tool with a type system.</p>
<p>I think Crockford sometimes makes some unwarranted assertions. He used to say that parsing JSON was the only acceptable use of  <code>eval</code>  in JavaScript, which I never understood, since one should absolutely not use  <code>eval</code>  on external input.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T20:04:30.463Z" class="reply"><span class="user">Fredrik</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T20:04:30.463Z" class="date">2024-03-26 20:04:30</a> <div class="message"><p>He seems to be in favor of duck typing, and if the type system prevents you from making a solution that relies on duck typing, he assumes that your alternative solution will be more complicated and have a higher risk of defects, which is an unproven assumption just like all his other opinions. He could equally well have made the opposite claim, that the type system forces you to make a cleaner solution that other programmers can understand without finding surprises, but what opinion he chooses to go with on each question seems to be a roll of dice.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T20:11:15.242Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T20:11:15.242Z" class="date">2024-03-26 20:11:15</a> <div class="message"><p>If more of us loose/dynamic typing advocates rock up this could turn into a vim/emacs bunfight!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T20:31:52.982Z" class="reply"><span class="user">Fredrik</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T20:31:52.982Z" class="date">2024-03-26 20:31:52</a> <div class="message"><p>That's what the JS community loves to do, and Douglas opens with a bunch of slides making strawmen arguments telling that anyone who disagrees with him is stupid and has no facts to come with. In fact, both Vim and Emacs are severely outdated, and I'd rather have the future of editors and programming than influencers provocing flamewars about binary choices of features from the past, as if these features are the ultimate and one of them must be the winner.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-26T20:58:02.353Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2024-03-23&amp;toDate=2024-03-29&amp;channel=thinking-together&amp;filter=#2024-03-26T20:58:02.353Z" class="date">2024-03-26 20:58:02</a> <div class="message"><p>Been usin' vi(m) 44 years, man-n-boy, an' I ain't stoppin' now. Pfwah! You young 'uns!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-27T10:54:02.586Z" class="reply"><span class="user">Dave Liepmann</span> <a href="./?fromDate=2024-03-24&amp;toDate=2024-03-30&amp;channel=thinking-together&amp;filter=#2024-03-27T10:54:02.586Z" class="date">2024-03-27 10:54:02</a> <div class="message"><p>It's not strictly an example of a bug but Crockford wrote a bit about his thinking in How JavaScript Works:</p>
<blockquote><p>Types are not blamed for the bugs they fail to find, the expensive bugs. And types do not get blamed for the problems they cause by requiring circumvention. Types can induce us to embrace cryptic, intricate, and dubious coding practices.</p>
</blockquote>
<p>An example he gives elsewhere of such circumvention:</p>
<blockquote><p>The Java language encourages misuse of exceptions as a way to get around problems in its type system. A Java method can only return a single type of result, so exceptions are used as an alternate channel to return the ordinary results that the type system does not allow.</p>
</blockquote>
<p>The paper <a href="https://dl.acm.org/doi/pdf/10.1145/3485500">Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers</a> has some concrete bugs caused by types:</p>
<blockquote><p>In statically-typed programming languages with rich and expressive type systems and modern features, such as type inference or a mix of object-oriented with functional programming features, the process of static typing in compiler front-ends is complicated by a high-density of bugs. Such bugs can lead to the acceptance of incorrect programs (breaking code portability or the type system‚Äôs soundness), the rejection of correct (e.g. well-typed) programs, and the reporting of misleading errors and warnings.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F06/F06S82RAPQQ.png" alt="Screenshot 2024-03-27 at 11.53.00.png"></p>
</div></div><div id="2024-03-27T11:15:02.096Z" class="reply"><span class="user">Ionu»õ G. Stan</span> <a href="./?fromDate=2024-03-24&amp;toDate=2024-03-30&amp;channel=thinking-together&amp;filter=#2024-03-27T11:15:02.096Z" class="date">2024-03-27 11:15:02</a> <div class="message"><p>üòÇ Typical Crockford:</p>
<blockquote><p>The word for 1 is misspelled. I use the corrected spelling 
 <em>wun</em> 
. The pronunciation of one does not conform to any of the standard or special rules of English pronunciation. And having the word for 1 start with the letter that looks like 0 is a bug.</p>
</blockquote>
<p>That actually kinda puts in perspective all the other stuff, honestly.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-28T06:59:28.302Z" class="reply"><span class="user">Fredrik</span> <a href="./?fromDate=2024-03-25&amp;toDate=2024-03-31&amp;channel=thinking-together&amp;filter=#2024-03-28T06:59:28.302Z" class="date">2024-03-28 06:59:28</a> <div class="message">
<blockquote><p>The Java language encourages misuse of exceptions</p>
</blockquote>
<p>That makes sense. I'm getting the feeling Douglas makes a sweeping generalization based on his knowledge of Java, which does not have a helpful type system. It shows ignorance to Typescript, which the question was actually about, and even more ignorance to more advanced type systems, such as that of Rust that prevents bugs by having a good way to handle errors instead of relying on exceptions, and also unlike Typescript prevent mixing up two different things that happen to have the same shape.</p>
<p>I find it contradictory to claim that type systems are not helpful and in the same presentation preach the use of Eslint. Eslint can't do its job well, because it doesn't know the intended type of values, so it mostly does low value remarks that don't help prevent bugs. I consider objects to be one of the bad parts of JS, because Eslint can't detect invalid property accesses, so I don't do objects, and instead pass everything through closure variables that Eslint can check.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-28T07:33:52.025Z" class="reply"><span class="user">Fredrik</span> <a href="./?fromDate=2024-03-25&amp;toDate=2024-03-31&amp;channel=thinking-together&amp;filter=#2024-03-28T07:33:52.025Z" class="date">2024-03-28 07:33:52</a> <div class="message">
<blockquote><p>That actually kinda puts in perspective all the other stuff</p>
</blockquote>
<p>Jes, √© p√∂rspektiv ov kaming ap with wan na√≠v ajd√≠a withaut s√≠ing the kontext √©nd thinking h√≠'s rajt abaut it √©nd evrywan els is wrong. Ingli≈° has no konsistent speling, √©nd the w√∂rd wan is nou eksep≈°√∂n. W√≠ kud s√≠ the big pikt≈°√∂r √©nd r√≠f√≥rm the houl l√©nggwit≈°, √©nd th√§t stil d√°sn't w√∂rk, bec√≥s √≠ngli≈° hes t√∫ m√©ni d√©mn homofouns.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-28T08:38:00.577Z" class="reply"><span class="user">Dave Liepmann</span> <a href="./?fromDate=2024-03-25&amp;toDate=2024-03-31&amp;channel=thinking-together&amp;filter=#2024-03-28T08:38:00.577Z" class="date">2024-03-28 08:38:00</a> <div class="message">
<blockquote><p>I find it contradictory to claim that type systems are not helpful and in the same presentation preach the use of Eslint.</p>
</blockquote>
<p>Does JSLint (which he recommends at 5:35) incur the same costs of type systems (circumvention, cryptic or complex code patterns) which bother Crockford? To me it seems not, thus no contradiction. He uses the tool to block off parts of the language he considers foot-guns, and to "increase the visual distance between a good program and a bad one". These goals seem distant to those of type systems.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-28T09:16:31.200Z" class="reply"><span class="user">Fredrik</span> <a href="./?fromDate=2024-03-25&amp;toDate=2024-03-31&amp;channel=thinking-together&amp;filter=#2024-03-28T09:16:31.200Z" class="date">2024-03-28 09:16:31</a> <div class="message"><p><strong>@Dave Liepmann</strong> I guess he's bothered by completely different things than other programmers then.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-28T09:38:28.461Z" class="reply"><span class="user">Ionu»õ G. Stan</span> <a href="./?fromDate=2024-03-25&amp;toDate=2024-03-31&amp;channel=thinking-together&amp;filter=#2024-03-28T09:38:28.461Z" class="date">2024-03-28 09:38:28</a> <div class="message"><p>[offtopic: For a split second, <strong>@Fredrik</strong>, my brain wanted to put that through Google Translate because it looked like Czech or Slovak or Polish, something in that linguistic area üòÖ]</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-29T13:48:45.743Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2024-03-26&amp;toDate=2024-04-01&amp;channel=thinking-together&amp;filter=#2024-03-29T13:48:45.743Z" class="date">2024-03-29 13:48:45</a> <div class="message"><p><strong>@Fredrik</strong> it's funny that Chat does a good job normalizing your funny message's spelling.  (Only added "one is  <em>now</em>  no exception.")  Homophones are one reason why Pinyin was not adopted during twentieth century attempts to simply Chinese characters.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-03-29T02:18:31.156Z" class="post"><span class="user">Justin Janes</span> <a href="./?fromDate=2024-03-26&amp;toDate=2024-04-01&amp;channel=thinking-together&amp;filter=#2024-03-29T02:18:31.156Z" class="date">2024-03-29 02:18:31</a> <div class="message"><p>Does anyone have any solid papers on interactions with operating systems using primarily hand gestures from cameras and projectors? I know this is very dynamicland but i‚Äôm kinda tired of waiting for a system i can let the kids play with on the carpet. </p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-29T02:36:28.021Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="./?fromDate=2024-03-26&amp;toDate=2024-04-01&amp;channel=thinking-together&amp;filter=#2024-03-29T02:36:28.021Z" class="date">2024-03-29 02:36:28</a> <div class="message"><p>it‚Äôs not a paper (&amp; may or may not be ‚Äúinteractions with operating systems‚Äù?) but: <a href="https://folk.computer/">folk.computer</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-29T09:38:51.262Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="./?fromDate=2024-03-26&amp;toDate=2024-04-01&amp;channel=thinking-together&amp;filter=#2024-03-29T09:38:51.262Z" class="date">2024-03-29 09:38:51</a> <div class="message"><p>oh it's also not hand gestures! sorry I didn't notice that part.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-03-30T10:10:48.647Z" class="post"><span class="user">William Taysom</span> <a href="./?fromDate=2024-03-27&amp;toDate=2024-04-02&amp;channel=thinking-together&amp;filter=#2024-03-30T10:10:48.647Z" class="date">2024-03-30 10:10:48</a> <div class="message"><p>My sister asked whether her middle-school son should pick the choice of a block programming language (like Scratch), JavaScript, or C# for a class he's in.  I claimed that he'll learn the same fundamentals with blocks minus the frustration, tedium, tea ceremony, and incantations associated with the others.  To prove that the block program has the real creativity and that moving to the others is practically automatable, I took may favorite Scratch program <a href="https://scratch.mit.edu/projects/605658/">scratch.mit.edu/projects/605658</a> and had Chat translate it into JavaScript and C# <a href="https://chat.openai.com/share/02215935-c0b8-4fc9-9bf9-94f0b3fab613">chat.openai.com/share/02215935-c0b8-4fc9-9bf9-94f0b3fab613</a>.  The results seemed promising.  Chat even made helpful observations:</p>
<blockquote><p>Translating the same Scratch program to C# requires a different approach because C# is often used in desktop applications, and there's no direct equivalent of the Canvas API like in web technologies. However, you can use Windows Forms or WPF (Windows Presentation Foundation) for graphical applications in C#. Here, I'll provide an example using Windows Forms to create a simple drawing application that mimics the Scratch program's behavior.</p>
</blockquote>
<p>If you check my conversation, you'll see I start asking what a "partial class" is having never heard the term.  Chat parroted:</p>
<blockquote><p>Using partial classes in this way provides flexibility. You can start with all your code in one file for simplicity. Then, if the class grows or you decide to use the designer, you can easily refactor the designer-generated code into its own file without changing the class's functionality. This approach keeps your custom code separate from the auto-generated code, making it easier to read and maintain.</p>
</blockquote>
<p>I explained that every language, every tool has many such conventions. You learn the ones reverent to whatever you're doing right now, but learning them all is impossible. Instead the real skill is knowing that you don't know and being able to find out quickly. We're lucky that a these things are obscure, come up often, and are discussed on the Web. Thus LLMs are especially good at helping with dumb programming problems.</p>
<p>So why use the established languages besides Chat knowing them well?  I thought of three reasons:</p>
<ul><li>Expressivity ‚Äî Blocks will get a beginner pretty far, but you'll find the others have constructs that helpful for saying things that would be very hard with blocks.  You won't appreciate scratch until you feel the itch.</li><li>Causal Powers ‚Äî The block system will let you do things in class you'll learn core ideas, but the blocks themselves won't work everywhere.  JavaScript, on the other hand, works all over on the web, and C# has its own ecosystem.  Often there's bridging, but also one or other language will be the most natural one for certain kinds of work.</li><li>Scale ‚Äî With big and medium sized programs being done with text, editors for wrangling it, and version control for keeping track of it exist.  They can we weirdly powerful and janky.  But you're liable to start having a hard time keeping track of blocks when it takes a dozen or more screens to fit them all.</li></ul></div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-31T17:14:19.932Z" class="reply"><span class="user">Christopher Shank</span> <a href="./?fromDate=2024-03-28&amp;toDate=2024-04-03&amp;channel=thinking-together&amp;filter=#2024-03-31T17:14:19.932Z" class="date">2024-03-31 17:14:19</a> <div class="message"><p>I think there is a project that explores that translation <a href="https://x.com/moenig/status/1601890041499996161?s=20">x.com/moenig/status/1601890041499996161?s=20</a></p>
</div> <div class="attachments">
<blockquote><blockquote><p>üê¶ <a href="https://x.com/moenig/status/1601890041499996161?s=20">Jens M√∂nig (@moenig) on X</a>: Did you know that since a decade ago Snap! can translate blocks to any textual grammar? I‚Äôm now experimenting with backmapping arbitrary grammars to identify blocks from text code. Just now went live on a line-of-code basis: <a href="https://t.co/lLMGD1c1dY">https://t.co/lLMGD1c1dY</a></p>
<p><img src="https://pbs.twimg.com/tweet_video_thumb/FjsOXAyWAAQuAGC.jpg:large" alt="Tweet Thumbnail"></p>
</blockquote>
</blockquote>
</div> <div class="files"></div></div></div></div><div id="2024-03-09T10:29:03.296Z" class="post"><span class="user"></span> <a href="./?fromDate=2024-03-06&amp;toDate=2024-03-12&amp;channel=thinking-together&amp;filter=#2024-03-09T10:29:03.296Z" class="date">üï∞Ô∏è 2024-03-09 10:29:03</a> <div class="message"><p>...</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-03-31T09:48:01.136Z" class="reply"><span class="user">Kongwei Ying</span> <a href="./?fromDate=2024-03-28&amp;toDate=2024-04-03&amp;channel=thinking-together&amp;filter=#2024-03-31T09:48:01.136Z" class="date">2024-03-31 09:48:01</a> <div class="message"><p><a href="https://twitter.com/jimmeyer">Jim Meyer</a> I'm working on something a bit like what you're talking about. The biggest problem I see at the moment is that the best programmers (and AI to a large extent these days) have developed a meta cognitive layer over plain textual code, that more accurately describes the data structures and flows of information inherent in code.</p>
<p>Simplest example is assignment</p>
<p>let fruit = "banana"</p>
<p>The implicit flow is</p>
<p>"banana" -&gt; fruit</p>
<p>"banana" is also a constant, whereas the variable fruit, is a store of information that may change over time.</p>
<p>So how to visually represent that fruit is possibly changing, and is a store of information, and that the string "banana" is constant, beyond the obvious string marks and let declaration?</p>
<p>We could show a flowing string of information that goes from "banana" to the variable fruit. Fruit could be highlighted with water as a background, and "banana" could be highlighted with concrete as a background. Maybe this isn't the best visual representation but you get what I mean.</p>
<p>Obviously it gets way more complicated than simple variable declarations and variable assignment but imagine if this kind of visual representation was extended to almost every single aspect of the language?</p>
<p>If, we could explicitly show this implicit meta cognitive layer as visually overlaid over the text itself, it would be a revolution for newbies and seasoned veterans. For newbies, they would understand the logic and flow of the code much much faster, and for veterans, their brain power would be freed from trying to visualise this meta cognitive structure, to focusing on even higher abstraction problems.</p>
<p>The main problems I see are:</p>
<ul><li>Identifying all the implicit structures inside our programming languages</li><li>Creating an intuitive visual representation of each, that is easily understandable</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-03-31T09:48:01.136Z" class="reply"><span class="user">Kongwei Ying</span> <a href="./?fromDate=2024-03-28&amp;toDate=2024-04-03&amp;channel=thinking-together&amp;filter=#2024-03-31T09:48:01.136Z" class="date">2024-03-31 09:48:01</a> <div class="message"><p><a href="https://twitter.com/jimmeyer">Jim Meyer</a> I'm working on something a bit like what you're talking about. The biggest problem I see at the moment is that the best programmers (and AI to a large extent these days) have developed a meta cognitive layer over plain textual code, that more accurately describes the data structures and flows of information inherent in code.</p>
<p>Simplest example is assignment</p>
<p>let fruit = "banana"</p>
<p>The implicit flow is</p>
<p>"banana" -&gt; fruit</p>
<p>"banana" is also a constant, whereas the variable fruit, is a store of information that may change over time.</p>
<p>So how to visually represent that fruit is possibly changing, and is a store of information, and that the string "banana" is constant, beyond the obvious string marks and let declaration?</p>
<p>We could show a flowing string of information that goes from "banana" to the variable fruit. Fruit could be highlighted with water as a background, and "banana" could be highlighted with concrete as a background. Maybe this isn't the best visual representation but you get what I mean.</p>
<p>Obviously it gets way more complicated than simple variable declarations and variable assignment but imagine if this kind of visual representation was extended to almost every single aspect of the language?</p>
<p>If, we could explicitly show this implicit meta cognitive layer as visually overlaid over the text itself, it would be a revolution for newbies and seasoned veterans. For newbies, they would understand the logic and flow of the code much much faster, and for veterans, their brain power would be freed from trying to visualise this meta cognitive structure, to focusing on even higher abstraction problems.</p>
<p>The main problems I see are:</p>
<ul><li>Identifying all the implicit structures inside our programming languages</li><li>Creating an intuitive visual representation of each, that is easily understandable</li></ul></div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
