
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-07-15T19:54:14.172Z" class="post"><span class="user">Jason Morris</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-12&amp;toDate=2024-07-18&amp;channel=thinking-together&amp;filter=#2024-07-15T19:54:14.172Z" class="date">2024-07-15 19:54:14</a> <div class="message"><p>After reading a linkedin post by a friend of mine, today, in which he describes "protective randomness" as a virtue of human systems, the absence of which makes certain AI applications frightening, (<a href="https://www.linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&amp;utm_medium=member_android">linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&amp;utm_medium=member_android</a>) I have come to the conclusion that this may be the best argument I have heard to object to the determinism in Rules as Code: that the systems we have for dealing with the output of the interpretation of statute not only anticipate but depend on variability of interpretation for their effective operation, and that they operate to do more than merely resolve disputes over legal interpretation, so the absence of those disputes is not an unmitigated benefit. Take for instance the conversation that happens between law makers and judges. A law is drafted, there are disputes over how to interpret it, in part fueled by examples of differing interpretations from administrative decision makers. Those differences in interpretation can help people know on what grounds they might object to a particular decision. Those objections go to judges, and judges might differ again, which has the same effect. And the differing interpretations of the judges in the context of things worth arguing about brings to legislators' attention places where the rule itself is both problematic from a fairness and/or interpretation standpoint, and where that problem causes significant issues in the real world, equipping them with information about where to focus when considering amendments. All of those benefits accrue even if no decision is ever made to resolve the dispute. If you replace variable administrative decision makers with a deterministic system based on a best shared interpretation, that review system, which not only accounts for but depends on variable outputs to function, stops working as effectively. That is not to say that what you lose is not worth what you gain. But it is a coherent argument about what is lost, and how, from consistent automated application of laws, and it is prescriptive about where and how rules as code should best be applied to avoid those losses. Which now makes me wonder whether armed with this idea, I would have a more generous read of the Laurence Driver paper.</p>
<p>For context, the linked post is aimed more at attempting to understand some forms of anxiety around AI applications, and particularly in the context of copyright violation, which Colarusso considers complaining about the wrong thing. But the idea metastasized in my head, and now I might have to give Driver the benefit of the doubt.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2024-07-15T21:17:05.245Z" class="post"><span class="user">Guyren Howe</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-12&amp;toDate=2024-07-18&amp;channel=thinking-together&amp;filter=#2024-07-15T21:17:05.245Z" class="date">2024-07-15 21:17:05</a> <div class="message"><p>I have a blog about matters related to the topics here. Just dropped this, which discusses why more of typical business logic should be implemented in the database: <a href="https://frest.substack.com/p/state-farming">frest.substack.com/p/state-farming</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2024-07-05T14:36:09.723Z" class="post"><span class="user"></span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-02&amp;toDate=2024-07-08&amp;channel=thinking-together&amp;filter=#2024-07-05T14:36:09.723Z" class="date">üï∞Ô∏è 2024-07-05 14:36:09</a> <div class="message"><p>...</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-15T21:24:40.266Z" class="reply"><span class="user">Guyren Howe</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-12&amp;toDate=2024-07-18&amp;channel=thinking-together&amp;filter=#2024-07-15T21:24:40.266Z" class="date">2024-07-15 21:24:40</a> <div class="message"><p>That folks synonimise programming with programming languages is hugely distorting.</p>
<p>The most successful non-programmer programming systems are Excel and end-user databases like FileMaker and access.</p>
<p>Excel has declarative formulas but much of the programming is in the structure of the spreadsheets.</p>
<p>A relational database with a strong user-modifiable UI is a great way of solving problems that would otherwise need a programmer. Our whole industry has almost ignored the Relational Model because it has been synonimised with the execrable SQL.</p>
<p>I am working toward a system that resembles FileMaker but that brings in any and all data that I can into the same UI. Imagine FileMaker but there are relations representing your calendar, your filesystem, your email and social media feeds, a vast array of online data sources and services, all in one UI and freely joinable etc.</p>
<p> <em>This</em>  is the way to enable non-programmers to solve their computing problems.</p>
<p>I would throw in regular programming  <em>also</em> , but  a relational query interface over everything just solves  <em>so</em>  many problems.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-17T20:08:31.989Z" class="post"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-14&amp;toDate=2024-07-20&amp;channel=thinking-together&amp;filter=#2024-07-17T20:08:31.989Z" class="date">2024-07-17 20:08:31</a> <div class="message"><p>Thinking about Schematics vs. Code. [This began as a short reply to <a href="https://twitter.com/stefanlesser">Stefan Lesser</a> regarding my take on electronics schematics in another thread.]</p>
<p><a href="https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true">open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true">2024-07-17-Thinking About The Game Of Pong In Hardware And Software</a></p>
<p>In aircraft and flying terminology, there is induced drag and parasitic drag. Induced drag is the kind of drag that you want, while parasitic drag is a side-effect that you wish weren‚Äôt there. For an airplane, we want lift which is a kind of drag. We push the plane faster through the air to make a good kind of drag (lift) on the airfoil-shaped wings. As we push the plane forward faster, though, we get unwanted drag (friction) against things like the landing gear. The good kind of drag is called ‚Äúinduced drag‚Äù, while the unwanted kind of drag is called ‚Äúparasitic drag‚Äù.</p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2024-07-20T16:07:04.629Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T16:07:04.629Z" class="date">2024-07-20 16:07:04</a> <div class="message"><p>Thanks <a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> for this detailed explanation with a nice example!</p>
<p>There's one aspect I find missing from the discussion: CPUs. Early CPUs, the ones for which our languages, compilers, etc. were designed, have no accessible parallelism (and the very early ones no parallelism at all). There's a single instruction stream. In that universe, function-based programming did not any additional synchronicity constraint.</p>
<p>Today, all CPUs and GPUs have some level of parallelism, but it's not under the control of the software. If I have a four-core processor, I can run up to four independent threads. That's a pretty severe constraint on asynchronicity in software as well.</p>
<p>So I wonder how we could possibly get to your dream situation of "as many asynchronously working subsystems as our design requires" with today's processors and no software layer for multithreading on top of them.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-21T09:43:33.669Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-18&amp;toDate=2024-07-24&amp;channel=thinking-together&amp;filter=#2024-07-21T09:43:33.669Z" class="date">2024-07-21 09:43:33</a> <div class="message"><p>The issue of CPUs is addressed, but, maybe not with enough brutality</p>
<p>There‚Äôs approximately 60+ truly-asynchronous processes on the 1972 Pong schematic, but no CPU. The design employs massive parallelism and real internal asynchronousity.</p>
<p>In 2024, we consider 8-ish cores to be a marvel. The cores share memory, so they cannot even be truly asynchronous.</p>
<p>That‚Äôs some 50 years later. Something is wrong with this picture.</p>
<p>A CPU was originally meant to be a simple sequencer circuit that was not reentrant. There is no reason to make CPU‚Äôs multi-threaded, other than co$t. In 1950, it was too expensive to own more than one CPU, so human brain-power was wasted on inventing and adding software to make CPUs multi-threaded. Today, we have access to very cheap hardware actors - Arduinos, Rasberry Pis, etc. (cheaper yet, if you discard Linux and reclaim internal chip space).</p>
<p>N.B. ‚Äúcentral‚Äù is a bad word these days. We probably want DPUs (distributed processing units).</p>
<p>I previously tried to write about hardware actors in <a href="https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html">guitarvydas.github.io/2024/02/17/Hardware-Actors.html</a>.</p>
<p>So, one might imagine a reprogrammable electronic machine (avoid the use of the word ‚Äúcompute-er‚Äù) to be a collection of 1,000s of cheap hardware actors on-a-chip, where only one of them is a big honking Linux blob for running existing bloatware and for backwards compatibility.</p>
<p><a href="https://khinsen.net/">Konrad Hinsen</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html">Hardware actors</a></p>
<p>Oops! Your browser doesn't support PDFs! Download Instead</p>
</blockquote>
</div> <div class="files"></div></div></div></div><div id="2024-07-19T16:35:00.550Z" class="post"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T16:35:00.550Z" class="date">2024-07-19 16:35:00</a> <div class="message"><p>Just a random thought that has been rattling around in my head while listening through podcast episodes and Ivan‚Äôs visual programing points. I am new here so apologies If all this has been said before, or covered in podcasts I haven‚Äôt gotten to yet.</p>
<p>I want to propose a slightly different framing for what it means to say that a representation of a program is visual / spatial or not</p>
<p> <em>I think that textual programming is visual</em> . It‚Äôs a series of symbols laid out on a screen in rows, and the spatial/visual relationship between the tokens does actually correspond to aspects of the operation of the program. For example an assignment statement has the thing being assigned to on the left, and the value on the right, parentheses group things together spatially on the screen, statements that appear above others within a block (usually) execute before the ones below (goto considered harmful breaks that down which I think you talked about). And good code formatting is mostly about making these visual analogies stronger. Zig plays with this by allowing you to release memory the line below where you have allocated it, which breaks down the time &lt;-&gt; up down analogy since the deallocation actually happens after the lines that follow, in favor of being able to spatially group two very semantically related statements in the program. That shows that there‚Äôs a lot to be played with within the context of textual programming if you think about in terms of spatial analogies to your program.</p>
<p>To explore this more though, it‚Äôs interesting to think about how a program could be represented completely  <em>non-spatially</em>  or  <em>non-visually</em> , and how these two things might differ.</p>
<p>You could imagine being read the textual code for some program aloud, without seeing the text at all, that would be a non-spatial, and non-visual representation of the program</p>
<p>You could also imagine seeing a single visual element, like a black circle on a screen or something, blinking on and off in morse code to transmit the code to you. To me that would be a visual representation that is not spatial, since the spatial dimensions of that single visual element don‚Äôt matter at all to the information being transmitted. It could be an array of dots or an image of some crazy person‚Äôs pure data patch or anything at all blinking on and off and the program being transmitted would be the same.</p>
<p>So what would a representation of a program look like that is  <em>minimally spatial</em> ? Maybe you could imagine two dots on the screen that encode a two bit piece of a textual program encoded in unicode, one two bit portion at a time? They flash on with the first two bits for a second, then the second two bits for a second blah blah blah (so practical!) Is this spatial?</p>
<p>There is a lot to explore here actually I think. Technically the particular spatial relationships of the pixels on the screen  <em>does</em>  need to be considered in order to decipher the program in the two dots scenario, and that is qualitatively different from the one dot scenario, where no information is gained from examining any spatial relationships.</p>
<p>But I am skeptical of whether or not this is actually minimally spatial. It seems like we should define a spatial representation of a program to mean that some  <em>meaningful part of the program</em>  is represented spatially, and I don‚Äôt think ‚Äúa two bit portion of a unicode character making up a textual program‚Äù meets that criteria. But Is this ‚Äúmeaningful vs non meaningful part of a program representation‚Äù a distinction that can even be clearly drawn? It seems obvious that there is at least a real quantitative difference if not a qualitative difference there. If the difference is only quantitative, then this two bit program would have to be a minimally (if highly unsatisfying) spatial representation of a program, but maybe there is some way to formally filter out non meaningful parts of a a program‚Äôs representation that are only essential to the representation of the program and not to the program itself?</p>
<p>But like was pointed out in the No Silver Bullets episode, there are a huge number of different ways to visualize the same program. I think that we are stuck in a single way of visualizing our programs - which is the code, and to me the problem is not that code is bad, but that we are missing out on a huge number of different ways we could visualize and ‚Äúreason about‚Äù (lol) our programs, so I‚Äôm not disagreeing with the actual takeaway, it‚Äôs more a critique of the hard division between textual and visual programming.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-19T17:26:21.987Z" class="reply"><span class="user">Scott</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:26:21.987Z" class="date">2024-07-19 17:26:21</a> <div class="message"><p>Going to need to take some time to digest this, but I wanted to say I really like thinking about "how could a program be representated non-spacially or non-visually, and the comment that "I think that textual programming is visual"</p>
<p>One thing that comes to mind - there have been some esolangs that have explored this idea a bit, though I don't think it was from this particular starting point. Velato (<a href="http://velato.net/">velato.net</a>) for example, encodes programs as midi files, so you could have an audio representation of a program...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:32:28.005Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:32:28.005Z" class="date">2024-07-19 17:32:28</a> <div class="message"><p>Fwiw, a relevant piece of math lore is the informal distinction between <code>algebraic thinkers' and </code>geometric thinkers'. All of the most useful mathematical machinery, of course, may be represented either algebraically in terms of symbols, or geometrically in terms of diagrams. So these two modes are isomorphic, but not trivially so. This yields many productive conceptual moves.</p>
<p>You've described a situation where  <em>every representation</em> , I think, is both useful and arbitrary. So that at the limit you get that <code>minimally spatial' vision of the </code>essence' from which which the universe of diagrammatic, symbolic, etc. forms may arise.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:34:35.307Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:34:35.307Z" class="date">2024-07-19 17:34:35</a> <div class="message"><p>This overlaps a lot with some stuff I've been trying out recently to allow us to create new "characters" in our programming environments that string together more spatially than just a linear sequence.</p>
<p>My inspiration for a minimally spatial notation is the mathematical notation for summation: <a href="https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation">en.wikipedia.org/wiki/Summation#Capital-sigma_notation</a>. It's a character, and you have a few places to add characters above and below it (in addition to the right)</p>
<p>The direction my thoughts have been going with this is, what if we had a way to just draw new such characters, specify holes around them where other characters go. And then use them transparently in an otherwise textual screen of code.</p>
<p>The primary use case in my mind is function calls, making them more visually distinct.</p>
<p>Links to my posts, all in <strong>#devlog-together</strong> over the past few weeks:</p>
<p><a href="https://history.futureofcoding.org/?fromDate=2024-06-27&amp;toDate=2024-07-03&amp;channel=devlog-together&amp;filter=#2024-06-30T23:49:07.513Z">üí¨ #devlog-together@2024-06-30</a></p>
<p><a href="https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1720015836688779">futureofcoding.slack.com/archives/C03RR0W5DGC/p1720015836688779</a></p>
<p><a href="https://history.futureofcoding.org/?fromDate=2024-07-08&amp;toDate=2024-07-14&amp;channel=devlog-together&amp;filter=#2024-07-11T01:07:01.938Z">üí¨ #devlog-together@2024-07-11</a></p>
<p><a href="https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1720750642619629">futureofcoding.slack.com/archives/C03RR0W5DGC/p1720750642619629</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:34:47.879Z" class="reply"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:34:47.879Z" class="date">2024-07-19 17:34:47</a> <div class="message"><p><strong>@Scott</strong> this is a cool esolang! definitely an example of a completely non spatial representation if you were to listen to the midi</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:45:23.225Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:45:23.225Z" class="date">2024-07-19 17:45:23</a> <div class="message"><p><strong>@Scott</strong> on the subject of esolangs, one earworm I have never been able to free myself of is, "what if Befunge but readable?"</p>
<p><a href="https://akkartik.name/archives/foc/thinking-together/1681698511.039269.html">akkartik.name/archives/foc/thinking-together/1681698511.039269.html</a></p>
<p><a href="https://akkartik.name/post/2020-03-13-devlog">akkartik.name/post/2020-03-13-devlog</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:47:36.359Z" class="reply"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:47:36.359Z" class="date">2024-07-19 17:47:36</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> this is almost exactly where my thoughts went - that thinking about textual programming visually could give you a path to a sort of incrementalist way of getting more and better spatial metaphors from where we currently are with textual programing - I will have to read through some of these threads. there is a lot of cool discussion to read through in this slack</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:56:04.734Z" class="reply"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:56:04.734Z" class="date">2024-07-19 17:56:04</a> <div class="message"><p><strong>@Jasmine Otto</strong> That divide in math does maps to what I am talking about here I think, I am reading through sipser‚Äôs computation textbook right now and he gives the formal algebraic and graphical representations for finite automata, pushdown automata turing machines etc, and it‚Äôs always easier and quicker to understand the graphs. But the algebraic definitions are still are spatial when written down on paper, in my mind, so maybe it‚Äôs not exactly the same thing? not sure though</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:59:31.015Z" class="reply"><span class="user">Scott</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=thinking-together&amp;filter=#2024-07-19T17:59:31.015Z" class="date">2024-07-19 17:59:31</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> hah! First I loved this line: "Now you can imagine a reduce operation as a series of solar systems that the spaceship visits one by one."...going to have to play with this a bit...I think there might be something here - I've been noodling around about new types of interfaces for AI agents...and a fully 2d/spatial metaphor for building/interacting/observing them seems worth digging in to...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T00:09:51.367Z" class="reply"><span class="user">Daniel Buckmaster</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T00:09:51.367Z" class="date">2024-07-20 00:09:51</a> <div class="message"><p>This is really thought provoking. As someone who is a big fan of text, it's really interesting to think of it as a visual medium.</p>
<p>It reminds me of a friend who I did uni with, where we took a course programming 6800 microcontrollers in assembly. And of course being the types we were, we decided that we needed to build a better IDE for assembly to make the course tolerable. One of the first things we tried was just changing the lines' background colour at each <a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a> boundary. That's playing with the visual nature of the text representation.</p>
<p>There wasn't anything profound about that, I'm just reminiscing and saying thank you for this post!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T00:21:47.794Z" class="reply"><span class="user">Scott</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T00:21:47.794Z" class="date">2024-07-20 00:21:47</a> <div class="message"><p>Ahh! That‚Äôs a great point, that must be what resonated with me about the ‚Äútext  ~<em><em>is</em></em>~  a visual medium‚Äù line‚Ä¶years ago I suggested to a new developer on my team that he turn syntax highlighting off on his ide for a few months to start to build the muscle of being able see the structure of the code he‚Äôs working with rather than the details‚Ä¶it‚Äôs the inverse of what you‚Äôre saying, but still points to this idea that we do treat text visually without really talking about that aspect of it</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T01:06:46.570Z" class="reply"><span class="user">Daniel Buckmaster</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T01:06:46.570Z" class="date">2024-07-20 01:06:46</a> <div class="message"><p>Syntax and code formatting is so often and hotly debated because it deeply affects the visual quality of our textual representation of the program!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T01:37:11.034Z" class="reply"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T01:37:11.034Z" class="date">2024-07-20 01:37:11</a> <div class="message"><p>Very true, it‚Äôs a way we can have control over the visualization of the program within the textual paradigm</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T06:30:49.304Z" class="reply"><span class="user">Dany</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T06:30:49.304Z" class="date">2024-07-20 06:30:49</a> <div class="message"><p>Don't forget syntax highlighting, Remove all colors from a piece of code and find yourself disoriented.</p>
<p>quote: ".. <em>meaningful part of the program</em> is represented spatially <em>"</em> </p>
<p>I think that is exactly the question, what parts should be visually / spatially represented. The big one in textual code is, top to bottom is execution order. We are giving one dimension to basically procedural programming.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T06:41:33.089Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T06:41:33.089Z" class="date">2024-07-20 06:41:33</a> <div class="message"><p>Not always, which complicates things.  <code>a, b, c</code>  executes from left to right, but  <code>a(b(c))</code>  executes from right to left. As those variables grow long they also take up the vertical axis (top to bottom and bottom to top respectively).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T12:51:31.416Z" class="reply"><span class="user">Don Abrams</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T12:51:31.416Z" class="date">2024-07-20 12:51:31</a> <div class="message"><p>I had a similar question and reduced it down to "what would an audio-only programming language sound like?" My guess was a lot more <a href="https://www.cs1subgoals.org/what-are-subgoals/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.">subgoals</a>, markers for "filling in later", and fine scoped tests/examples.</p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://www.cs1subgoals.org/what-are-subgoals/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.">What are subgoals?, SUBGOALS</a></p>
<p>What are subgoals? A common problem in introductory programming courses is the expert-novice gap between instructors and students.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-07-20T13:53:50.986Z" class="reply"><span class="user">Hayden</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T13:53:50.986Z" class="date">2024-07-20 13:53:50</a> <div class="message"><p>Loving all of the orthogonal thinking prompts throughout this thread. My perspective is that text-based programming is more characterized by the interaction model of essentially being equivalent to typesetting a document. Also worth considering is that many people interact with textual programming strictly non-visually through the use of text-to-speech. In my mind, things move to being more "visual" or "spatial" programming as the document interaction model goes away and the mapping to audio-only interface becomes less clear.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T17:40:20.585Z" class="reply"><span class="user">Adam Davidson</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T17:40:20.585Z" class="date">2024-07-20 17:40:20</a> <div class="message"><p>Ok so sorry for posting a super long thing again but what <strong>@Jasmine Otto</strong> brought up about Geometric vs Algebraic representations got me thinking. So if you define an ‚ÄúAlgebraic‚Äù representation to be a representation of some formal object that can be expressed as a sequence of symbols, and a ‚ÄúGeometric‚Äù representation to be one that has a set of symbols that can be oriented anywhere in 2d space in relation to one another, then I think you can actually draw a pretty clear distinction between the two. Maybe the distinction is better defined as 1 dimensional vs 2 dimensional, but I will stick with this Algebraic vs Geometric thing.</p>
<p>say the formal object we are representing is the fully connected graph of 3 nodes a, b, c. With a geometric representation, you can have three nodes laid out as an equilateral triangle, with 3 edges connecting them. Very simple. You have 4 different symbols, a, b, c, and &lt;line&gt;, which represents an edge. In the standard algebraic representation, where you have a pair (V,E) of vertices and edges, the representation is ({a,b,c},{(a,b),(b,c),(c,a)}). The symbols used are (, ), {, }, a, b, c, ‚Äú,‚Äù, which is 8 different symbols. And the total number of symbols in the representation, counting repetitions is 29 (if I counted right).</p>
<p>Let‚Äôs say we just want a representation that can distinctly express any graph with just 3 nodes to simplify things a bit. For the fully connected graph you can think of a sequential representation that has the same number of symbols and symbol instances as the geometric representation: ‚Äúa-b-c-‚Äù the ‚Äú-‚Äù at the end could be interpreted to mean that there is a connection back to the first node in the sequence. Or you could simply do ‚Äúabca‚Äù, where two nodes have an edge between them if they are next to each other in the sequence. In this case, we have a repeated symbol ‚Äúa‚Äù, but fewer symbol types than in the graphical representation.</p>
<p>But then you could similarly eliminate the &lt;line&gt; symbol from the geometric representation by saying that nodes are connected if the symbols representing them are touching. Maybe you replace each symbol a, b, c with that symbol inside a circle to imagine this better. Now I think you reach a point where there is a real difference. In the case of the geometric representation, you can differentiate between the fully connected graph between nodes abc, with only 3 symbol types, and 3 symbol occurrences. Whereas in the sequential graph, there is no way to differentiate between the two with only three symbol types and 3 symbol instances. With only ‚Äúabc‚Äù you don‚Äôt know if the a is connected to the c or not.</p>
<p>Textual programming is purely sequential in nature. No matter how you format your code visually, the one dimensional sequence of characters fully determines the program. So you will need either more symbol types, or more symbol occurrences to represent programs textually than we might if we use 2d space!!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T20:47:17.355Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=thinking-together&amp;filter=#2024-07-20T20:47:17.355Z" class="date">2024-07-20 20:47:17</a> <div class="message"><p>Shorter version of the previous:</p>
<p>In visual programming, spatial arrangement of objects doesn't have to be meaningful. But it can be. That part is open to design.</p>
<p>Now I'll add:</p>
<p>In a good system, the programmer would get to choose whether spatial arrangement is meaningful or not.</p>
<p>In a good system, the movement of objects through time is just as significant as relative positions, connections, visual representations, etc.</p>
<p>There are physical dimensions we haven't explored. If you live in text, you won't feel the pull to explore them.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-21T08:10:41.347Z" class="reply"><span class="user">Dany</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-18&amp;toDate=2024-07-24&amp;channel=thinking-together&amp;filter=#2024-07-21T08:10:41.347Z" class="date">2024-07-21 08:10:41</a> <div class="message"><p><strong>@Adam Davidson</strong> Reading your post,.. you know, writing down geometric and algebraic problems like this is sort of a prompt for an AI? That makes me realize why I dislike AI for coding, it's like we un-invented algebraic notation and went back to writing prose. Instead I want to go into the other direction.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-21T20:57:32.158Z" class="reply"><span class="user">Dennis Hansen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-18&amp;toDate=2024-07-24&amp;channel=thinking-together&amp;filter=#2024-07-21T20:57:32.158Z" class="date">2024-07-21 20:57:32</a> <div class="message"><p>Love this train of thought. I like to think of visual programming as a 'superset' of textual programming.</p>
<p>In general the following roots my thinking in a broader context but beware: This definitely has im14andthisisdeep energy:</p>
<p>Perhaps the stark divide between computation and physicality is an illusion as all computation is physical in nature, with much of it being observable- some through a representation on an interface (the 'visual' component), or some so hidden in patterns of electricity. So we might say minimizing the visio-spatial element of a computation is either compressing the representation of the code (Now you don't need semicolons!) or leaving information out (No more writing explicit types!).</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
