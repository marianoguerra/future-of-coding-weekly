
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-07-05T14:36:09.723Z" class="post"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-02&amp;toDate=2024-07-08&amp;channel=thinking-together&amp;filter=#2024-07-05T14:36:09.723Z" class="date">üï∞Ô∏è 2024-07-05 14:36:09</a> <div class="message"><p>pond‚Äôring aloud:</p>
<p>I wonder if the problem with VPLs is the word ‚Äúlanguage‚Äù.</p>
<p>It appears to me that the word ‚Äúprogramming‚Äù has been generally accepted to mean ‚Äúsequential language‚Äù or writing sequential codes (aka ‚Äúcoding‚Äù). I view this view as being too restrictive. Programming is more than just commanding a machine with sequentialistic instructions. Programming a  <em>CPU</em> , though, is - by definition - sequentialistic. But,,, programming a  <em>machine(s)</em>  need not be sequentialistic. Especially in the age of nothing-is-central. In fact, LLMs are an example of non-sequentialism. The machines that run LLMs were programmed, arduously, in sequential notation, but, the inner success of LLMs is not sequential, but something else (massively parallel plinko?).</p>
<p>VPLs and DPLs are, to me, not sequentialistic things. Maybe they should be called ‚Äúnotations‚Äù instead of ‚Äúlanguages‚Äù? VNP and DNP? Visual Notation for Programming, Diagrammatic Notation for Programming? [In which case, ‚Äúprogramming languages‚Äù as we know them, are TNPs - Textual Notations for Programming].</p>
<p>In fact, programming is not the difficult part. Re-programming is the novel aspect of Design that computers bring to the world. We have been programming machines to do  <em>single</em>  things for centuries (using metal lathes, etc.). This time through, though, we have built machines capable of doing  <em>many</em>  things.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-15T21:24:40.266Z" class="reply"><span class="user">Guyren Howe</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-12&amp;toDate=2024-07-18&amp;channel=thinking-together&amp;filter=#2024-07-15T21:24:40.266Z" class="date">2024-07-15 21:24:40</a> <div class="message"><p>That folks synonimise programming with programming languages is hugely distorting.</p>
<p>The most successful non-programmer programming systems are Excel and end-user databases like FileMaker and access.</p>
<p>Excel has declarative formulas but much of the programming is in the structure of the spreadsheets.</p>
<p>A relational database with a strong user-modifiable UI is a great way of solving problems that would otherwise need a programmer. Our whole industry has almost ignored the Relational Model because it has been synonimised with the execrable SQL.</p>
<p>I am working toward a system that resembles FileMaker but that brings in any and all data that I can into the same UI. Imagine FileMaker but there are relations representing your calendar, your filesystem, your email and social media feeds, a vast array of online data sources and services, all in one UI and freely joinable etc.</p>
<p> <em>This</em>  is the way to enable non-programmers to solve their computing problems.</p>
<p>I would throw in regular programming  <em>also</em> , but  a relational query interface over everything just solves  <em>so</em>  many problems.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-18T05:11:27.692Z" class="post"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T05:11:27.692Z" class="date">2024-07-18 05:11:27</a> <div class="message"><p><a href="https://merveilles.town/@zens/112805206600616310">This masto thread</a> should resonate with folks here. Teaser:</p>
<blockquote><p>fediverse is the kind of place where I can ask a question of ‚Äúlet‚Äôs say we‚Äôre designing an operating system from scratch. Clean slate. Let‚Äôs throw away all our old habits and legacy decisions. what‚Äôs the minimal set of applications we need to make a new operating system useful‚Äù</p>
</blockquote>
<p>and the top replies are vt100 emulator, virtual machine to run other operating systems, and c compiler to port vim</p>
<p>like y‚Äôall are missing the point of the question!</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-18T08:47:24.484Z" class="reply"><span class="user">Dany</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T08:47:24.484Z" class="date">2024-07-18 08:47:24</a> <div class="message"><p>Reminds me of a similar question to some of the top economists, "if we could redo our tax system from scratch, how would that look?"</p>
<p>They all basically said, its good the way it is, doesn't need change.</p>
<p>I think there are several forces at play:</p>
<p>"You don't know enough, so you feel like all this complexity is unnecessary"</p>
<p>"You know all the details and lost the big picture",</p>
<p>"You have stakes in the game"</p>
<p> "You resist change"</p>
<p>"Something out of the ordinary does not get funded"</p>
<p>"The idea, actually just adds to the complexity"</p>
<p>"There is no transition from old to new"</p>
<p>"The new idea is just bad"</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T09:10:32.630Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T09:10:32.630Z" class="date">2024-07-18 09:10:32</a> <div class="message"><p>If you look at a complex system that has evolved out of thousands (millions?) of little decisions over a long period of time, and then ask to redesign such a system from scratch, it‚Äôs just overwhelming.</p>
<p>There are no good answers to the question, because all the answers we have found in the old system came out of this long grinding process. To answer the question, we‚Äôd have to go on another long journey of making thousands of little decisions one by one all over again.</p>
<p>I bet if we tried, we‚Äôd end up somewhere completely different this time. But it‚Äôs hard to convince people to do it all over again. Seems so inefficient.</p>
<p>But if you see it (oversimplified) as a binary decision tree of 1000 decisions made over time, it would be rather spectacular if we nailed each of those 1000 decisions the first time such that we would take exactly the same path again.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T19:34:21.618Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T19:34:21.618Z" class="date">2024-07-18 19:34:21</a> <div class="message"><p>The path depends on the ongoing context as well. What specific hardware tech is available and feasible. What ideas click and get funding, or get picked up by a business that happens to take off due to market factors.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T08:39:37.553Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T08:39:37.553Z" class="date">2024-07-19 08:39:37</a> <div class="message"><p>If you look at complex social systems such as tax rules, big changes happen only after some major breakdown: after wars, revolutions, etc. Inversely, accumulated unsolved problems are the cause of such major breakdowns. The interesting fundamental question thus is if complex systems can undergo major change in an evolutionary rather then disruptive way. I don't know the answer.</p>
<p>In a well-delimited technology context, starting from scratch is a realistic approach in a research setting, but not in real-life applications. Research projects of this kind can then influence the evolution of mainstream tech. That looks like a reasonable way to evolve rather than disrupt working systems.</p>
<p>An underappreciated concept in this space is the narrow waist (<a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist</a>): a system layer that permits independent evolution both above and below it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T09:31:59.804Z" class="reply"><span class="user">Dany</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T09:31:59.804Z" class="date">2024-07-19 09:31:59</a> <div class="message"><p>Isn't the "narrow waist" part of the problem and not the solution? One could argue that CPU &lt;-&gt; GPU divide is a narrow waist. Both are developed independently, but at this point we're really putting a smaller supercomputer into a bigger computer.</p>
<p>The communication between the two is a big source of complexity in todays compute.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T10:00:37.747Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T10:00:37.747Z" class="date">2024-07-19 10:00:37</a> <div class="message"><p>I have also been struggling with the ‚Äúnarrow waist‚Äù concept. I‚Äôm not entirely sure how to properly distinguish it from or how it interacts with layer architectures (which seem to be the primary example) and separation between interface and implementation.</p>
<p>There is something important all of these point at, which has to do with stabilizing one part while allowing another to change. But the distinction isn‚Äôt as clear as they all make it look.</p>
<p>The description I like most so far is the one Herbert Simon makes in  ~<em><em>The Architecture of Complexity</em></em>~ , where he talks about ‚Äúnearly decomposable systems‚Äù. That seems to capture the not quite clear boundary between what can change and what is stable best. </p>
<p>And I have a suspicion that there is no clear boundary that can be drawn, and that the subtle interactions between different scales, what makes Simon call it  ~<em><em>nearly</em></em>~  decomposable, are actually not a bug but a feature.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T11:37:10.240Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T11:37:10.240Z" class="date">2024-07-19 11:37:10</a> <div class="message">
<blockquote><p>stabilizing one part while allowing another to change</p>
</blockquote>
<p>Question: Is the /bin/sh pipe operator  <code>|</code>  a (restricted) form of narrow waist?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:28:48.690Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T17:28:48.690Z" class="date">2024-07-19 17:28:48</a> <div class="message">
<blockquote><p>In a well-delimited technology context, starting from scratch is a realistic approach in a research setting, but not in real-life applications. Research projects of this kind can then influence the evolution of mainstream tech. That looks like a reasonable way to evolve rather than disrupt working systems.</p>
</blockquote>
<p>Indeed. Any foc style work or ideation we do should completely ignore the status quo for this reason. I feel if you think about product-market-fit you've already lost. Depends on your goals of course, I'm taking about research.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T19:13:21.970Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T19:13:21.970Z" class="date">2024-07-19 19:13:21</a> <div class="message"><p><strong>@Dany</strong> I wouldn't call CPU/GPU a narrow waist. CPU and GPU are not different technology layers. CPUs are not implemented in terms of GPUs, nor the other way round.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T19:15:30.218Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T19:15:30.218Z" class="date">2024-07-19 19:15:30</a> <div class="message"><p><a href="https://twitter.com/stefanlesser">Stefan Lesser</a> I agree that Simon's perspective is still a very useful one, though rarely adopted in practice. But I see this as distinct from the narrow waist context, which is about layers, not interacting modules.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T19:51:12.242Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T19:51:12.242Z" class="date">2024-07-19 19:51:12</a> <div class="message"><p>Now I'm rereading <a href="https://faculty.sites.iastate.edu/tesfatsi/archive/tesfatsi/ArchitectureOfComplexity.HSimon1962.pdf">faculty.sites.iastate.edu/tesfatsi/archive/tesfatsi/ArchitectureOfComplexity.HSimon1962.pdf</a></p>
<p>I swear, sometimes I think I only read the first 5 pages of any paper. I very often have no memory of the rest.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T20:06:59.271Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:06:59.271Z" class="date">2024-07-19 20:06:59</a> <div class="message"><p>A good example of a narrow waist is in the internet architecture. TCP/IP is the waist with heterogeneity and evolution both above and below it.</p>
<p>I believe the concept of a file is also a narrow waist. Not only do you have different filesystems underneath, you can also map it to different mediums (SSD, HDD, optical, remote). Of course there is the entire world of applications above it.</p>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07D6H51KJR.jpg" alt="20240719_130236.jpg"></p>
</div></div><div id="2024-07-19T20:51:33.900Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:51:33.900Z" class="date">2024-07-19 20:51:33</a> <div class="message"><p>Ok, I'm gonna do one more comment on the subject of how come I don't remember all this from  <em>The architecture of complexity</em> . Hopefully it's not too off-topic.</p>
<p>In 2 pages from page 8 to page 10, the paper makes the statement that I think Stefan was pointing at above:</p>
<ul><li>When subsystems are out of equilibrium, you can ignore macroscopic interactions between subsystems. They're in the noise compared to the churn going on within each subsystem.</li><li>When subsystems are in equilibrium, cross-subsystem interactions dominate. You can even summarize each subsystem with a few gross aggregate metrics.</li></ul><p>This duality is really interesting! It connects up with Christopher Alexander's  <em>A City is not a Tree</em>  (<a href="https://www.patternlanguage.com/archive/cityisnotatree.html">patternlanguage.com/archive/cityisnotatree.html</a>)</p>
<p>However, in the rest of the (17-page) paper Simon focuses exclusively on the second bullet. The result is to belabor something we moderns at least get told all the time: to manage complexity, divide and conquer. This is why I totally missed the gold.</p>
<p>I think I'm saying I appreciate <a href="https://twitter.com/stefanlesser">Stefan Lesser</a> for highlighting this point almost more than I appreciate Herb Simon üòÑ</p>
<p>Perhaps an alternative explanation is that Herb Simon had several thoughts on the subject and put them into a single paper. If so, a unitary introduction and conclusion feels counter-productive. This is a series of short stories, not a novella.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:12:15.695Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:12:15.695Z" class="date">2024-07-19 21:12:15</a> <div class="message"><p><a href="https://twitter.com/chatur_shalabh">Shalabh Chaturvedi</a> That‚Äôs the example I had in mind. So, ok, if that‚Äôs a narrow waist, then is, say, LLVM also a narrow waist (between compiler front- and backends), or is that something else?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:16:29.187Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:16:29.187Z" class="date">2024-07-19 21:16:29</a> <div class="message"><p>Yes LLVM is also a narrow waist.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:18:49.217Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:18:49.217Z" class="date">2024-07-19 21:18:49</a> <div class="message"><p>Layering is essential in narrow waists, but not vice versa. You can have layering without large ecosystems above and below a specific narrow layer. I create systems with layers, but they are no ecosystems above and below it - it's just a cylinder shape, not an hourglass.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:21:34.712Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:21:34.712Z" class="date">2024-07-19 21:21:34</a> <div class="message"><p>From the original link above</p>
<blockquote><p>The narrow waist (of an hourglass) is a software concept that solves an interoperability problem, avoiding an O(M √ó N) explosion.</p>
</blockquote>
<p>So LLVM certainly fits that definition. Without LLMV you'd have M √ó N, specifically  <code>(C, C++, Rust, Haskell, ...) √ó (x86, arm, mips, ...)</code> </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:28:27.264Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:28:27.264Z" class="date">2024-07-19 21:28:27</a> <div class="message"><p><a href="https://twitter.com/chatur_shalabh">Shalabh Chaturvedi</a> Thanks, that makes sense. Now I‚Äôm wondering: What would be a good example for a layer architecture that doesn‚Äôt have a narrow waist?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:39:13.871Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:39:13.871Z" class="date">2024-07-19 21:39:13</a> <div class="message"><p>Layers are essential to narrow waist but not vice versa. I create systems all the time with layers, but no special narrow layer that has diversity above and below. I have a web app handing request above and an db access layer below, with an actual db underneath - it's like a cylinder. There are no ecosystems involved. You can say libraries like sqlalchemy orm try to do a narrow waist, but have not been as successful. The leaky abstraction principle also applies - some waists work better in their context than others.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:42:47.582Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:42:47.582Z" class="date">2024-07-19 21:42:47</a> <div class="message"><p>The downside of well established narrow waists is you cant move the waist because it is so deeply entrenched in systems and minds. So with TCP/IP, you have all different physical protocols designed and optimized to cater to its specific features. Same with LLVM backends. Similar to how "and then our tools shape us", language designers comfortable with LLVM may end up designing languages that can be easily mapped to it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:42:52.942Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:42:52.942Z" class="date">2024-07-19 21:42:52</a> <div class="message"><p>Sounds like layers can have two purposes:</p>
<ul><li>'vertically' to separate concerns</li><li>'horizontally' as a narrow waist</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:50:38.255Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:50:38.255Z" class="date">2024-07-19 21:50:38</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> Thanks. I found the room temperature example useful to illustrate this.</p>
<p>Simon also points out in that paper that it‚Äôs not quite clear if we see hierarchies everywhere because they are everywhere, or just because we are adapted to see hierarchies. That‚Äôs also pretty much just a sentence or paragraph at most, but in my view one of the most thoughtful observations in there.</p>
<p>I‚Äôve mentioned Alicia Juarrero somewhere here before who wrote two books that take this idea of interactions across subsystems on different hierarchy levels much further with a comprehensive theory about constraints. In case you were looking for another rabbit hole‚Ä¶ :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:55:20.904Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:55:20.904Z" class="date">2024-07-19 21:55:20</a> <div class="message"><p>Kartik - I didn't get the vertical vs horizontal - can you elaborate / give an example of vertical?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T22:01:50.861Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T22:01:50.861Z" class="date">2024-07-19 22:01:50</a> <div class="message"><p><a href="https://twitter.com/chatur_shalabh">Shalabh Chaturvedi</a> I was imagining the layers stacked one on another. So as you move vertically you cross layer boundaries.</p>
<p>Imagine you have a system. As you separate concerns it's often natural to have one concern treat another as a black box. Caller vs callee. You're basically creating a layer boundary here. So this is what I think of as 'vertical'.</p>
<p>But another reason to create a layer doesn't start from a system at all. Instead you have a bunch of systems of two kinds that want to talk across a requirement/provider boundary. I imagine these alternatives lined up horizontally in two lines, one above another (but here 'vertical' doesn't mean caller-callee, hehe. It's symmetric; either side can initiate a connection). In this case you form a new system "fully formed from the brow of Zeus" as it were, to intermediate the two sides. This is the thin waist. Before it existed there was cacophony. After it exists you suddenly find yourself in a layered architecture.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T22:21:31.217Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T22:21:31.217Z" class="date">2024-07-19 22:21:31</a> <div class="message"><p>yeah makes sense. "interoperability standards" often seem synonymous with narrow waists. it's not about a single system but an ecosystem.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T22:25:07.748Z" class="reply"><span class="user">Stefan Lesser</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T22:25:07.748Z" class="date">2024-07-19 22:25:07</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> About Simon‚Äôs approach: What do you mean by ‚Äúrarely adopted‚Äù? Simon was trying to describe and explain complex systems. I‚Äôm not sure there was anything to adopt?</p>
<p>I think his observations do apply to layer architectures. First, in the form of leaky abstractions. But even if the interfaces are well specified and achieve good separation, which is incredibly difficult to achieve, there are still subtle effects that can be ignored most of the time, but then sometimes do shine through, like, I don‚Äôt know, packet size constraints on the IP layer causing performance issues on the HTTP layer or something like that.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T16:00:25.301Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=linking-together&amp;filter=#2024-07-20T16:00:25.301Z" class="date">2024-07-20 16:00:25</a> <div class="message"><p><a href="https://twitter.com/stefanlesser">Stefan Lesser</a> I meant rarely adopted when designing software systems. Simon's discussion is about both natural (evolved) systems and about human-made artifacts (and he says it's for the same reason of economy in construction). His artifact example, a watch, ends up made from nearly decomposable subsystems not through insight into complex systems, but because watchmakers are clever people and end up designing watches in a way that is easier for them to build. In software, I don't see this happening. On the contrary, it is very difficult to achieve such a design, because our toolboxes are set up for strong coupling of submodules via shared dependencies.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-18T15:46:25.631Z" class="post"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:46:25.631Z" class="date">2024-07-18 15:46:25</a> <div class="message"><p><a href="https://blog.sbensu.com/posts/demand-for-visual-programming/">We need visual programming. No, not like that.</a></p>
<blockquote><p> <em>Let's observe what developers</em> 
 <em><em>do</em></em> 
 <em>, not what they</em> 
 <em><em>say</em></em> 
 <em>.</em> </p>
</blockquote>
<p>Developers do spend the time to visualize aspects of their code but rarely the logic itself. They visualize other aspects of their software that are 
&gt;  <em>important, implicit, and hard to understand</em> 
&gt; . Here are some visualizations that I encounter often in 
&gt; serious contexts of use
&gt; :</p>
<ul><li>Various ways to visualize the codebase overall.</li><li>Diagrams that show how computers are connected in a network</li><li>Diagrams that show how data is laid out in memory</li><li>Transition diagrams for state machines.</li><li>Swimlane diagrams for request / response protocols.</li></ul><blockquote>
<p> <em>This</em> 
 is the visual programming developers are asking for.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-18T15:47:09.069Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:47:09.069Z" class="date">2024-07-18 15:47:09</a> <div class="message"><p>Oh wait, this is of a piece with the previous post. I suppose it's also ok at the top-level..</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T15:50:12.967Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:50:12.967Z" class="date">2024-07-18 15:50:12</a> <div class="message"><p>Fixed :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T15:53:02.990Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:53:02.990Z" class="date">2024-07-18 15:53:02</a> <div class="message"><p>Now I'm wondering what a  <em>programming language</em>  looks like that makes it easy to create such visualizations and keep them updated over time.</p>
<p>My biases make me go first to Lisp, but in practice it's actually no easier to parse Lisp on a semantic level (e.g. detecting new variable scopes) than any other language.</p>
<p>Maybe Glamorous Toolkit? <a href="https://khinsen.net/">Konrad Hinsen</a> <a href="https://twitter.com/girba">Tudor Girba</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T15:59:25.599Z" class="reply"><span class="user">Tudor Girba</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:59:25.599Z" class="date">2024-07-18 15:59:25</a> <div class="message"><p>The visualizations you are talking about are first and foremost for reading, not for writing, which is indeed the most costly and painful problem in software engineering today. As such, this is not a programming language issue, but an environment issue. Moldable Development is a systematic method for doing exactly that. It turns out that reading needs are orthogonal with writing needs. Glamorous Toolkit is the most advanced and extensive environment that shows how far doing this systematically can get you. I do expect people will copy GT, and they very much should. My only worry is that they will not copy everything.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T16:01:00.246Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T16:01:00.246Z" class="date">2024-07-18 16:01:00</a> <div class="message"><p>Thanks! Does GT currently support visualizations like call graphs (I'm sure), automatically extracting from code visualizations like state machines, heat maps, time sequence diagrams? Any programming language..</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-18T16:35:36.722Z" class="reply"><span class="user">Tudor Girba</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T16:35:36.722Z" class="date">2024-07-18 16:35:36</a> <div class="message"><p>The idea is to not restrict the specific visualizations, but rather to enable one to construct custom visualizations of arbitrary input data. It is many times more valuable and cheaper to build custom visualizations than generic ones. There patterns language and the components are reusable, but the specific visual representations are less interesting for reuse.</p>
<p>The question about programming languages is interesting. We can think of it as ‚Äúare there parsers and semantic importers for language X‚Äù. But we can also think of it as ‚Äúhow do we build a parser and an importer for language X‚Äù. The former will lead to a library of parsers (like that built around ANTLr). The latter will lead to a dedicated environment for building parsers and importers faster. In GT we show that it is possible to have both, but really the interesting one is how to adjust to a language that you might not know.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T08:28:37.385Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T08:28:37.385Z" class="date">2024-07-19 08:28:37</a> <div class="message"><p>That's indeed the main lesson learned (for me) from a few years in "moldable development" land. Support for situated development tools is much more valuable than generic development tools. The tools are better adapted to the specific task, and perhaps even more importantly, the user understands the situated tool perfectly well.</p>
<p>I suspect that all this remains true if you cross out "development" - it should apply to any software tool. My near-term goal is "moldable data science".</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-18T15:50:07.883Z" class="post"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T15:50:07.883Z" class="date">2024-07-18 15:50:07</a> <div class="message"><p>As a follow-up to the above, there's this nice blog post from <strong>@Nikita Prokopov</strong> on  <em>diagrams as code:</em> <a href="https://tonsky.me/blog/diagrams/">Where Should Visual Programming Go?</a></p>
<blockquote><p>Level 3: Diagrams are code</p>
</blockquote>
<p>This is what the endgame should be IMO. Some things are better represented as text. Some are best understood visually. We should mix and match what works best on a case-by-case basis. Don‚Äôt try to visualize simple code. Don‚Äôt try to write code where a diagram is better.</p>
<p>Hear, hear!</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-07-18T19:40:18.212Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-15&amp;toDate=2024-07-21&amp;channel=linking-together&amp;filter=#2024-07-18T19:40:18.212Z" class="date">2024-07-18 19:40:18</a> <div class="message">
<blockquote><p>Think of it as a game engine like Godot or Unity. In them, you can write normal text code, but you can also create and edit scenes. These scenes are stored in their own files, have specialized editors that know how to edit them, and have no code representation. Because why? The visual way 
 <em>in this particular case</em> 
 is better.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T05:47:53.990Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T05:47:53.990Z" class="date">2024-07-19 05:47:53</a> <div class="message"><p>‚ÄúLevel 3‚Äù, when it‚Äôs not code &amp; diagram as universal parallel representations but domain-specific  <em>visual syntaxes</em>  (as <strong>@Nikita Prokopov</strong> says he wants) has been explored a number of times. Here is the relevant section from <a href="https://arxiv.org/pdf/2303.06777">arxiv.org/pdf/2303.06777</a>, with some hopefully helpful citations.</p>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07D2AT8ASZ.png" alt="Screenshot 2024-07-18 at 10.46.15‚ÄØPM.png"></p>
<p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07DU1RDQMN.png" alt="Screenshot 2024-07-18 at 10.46.31‚ÄØPM.png"></p>
</div></div><div id="2024-07-19T10:23:06.715Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T10:23:06.715Z" class="date">2024-07-19 10:23:06</a> <div class="message"><p>Yeah this is basically notebook programming. There are two levels to what you want to diagram too. 1. the program specification (e.g. the source or configuration) or 2. The runtime state. Text source code is just a narrow view of 1. I think that can be enhanced with diagrams across for both 1 and 2. <a href="https://observablehq.com/plot/">observablehq.com/plot</a> is incredibly flexible for quite a huge range of visualizations (grammar of graphics). I use it for schematic like diagrams, but obviously it also does more recognisable mathy charts too.</p>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07D6E4LGQ2.png" alt="image.png"></p>
</div></div><div id="2024-07-19T15:41:07.690Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T15:41:07.690Z" class="date">2024-07-19 15:41:07</a> <div class="message"><p><a href="https://webcode.run">Tom Larkworthy</a> This isn‚Äôt ‚Äúbasically notebook programming‚Äù if that‚Äôs taken in the sense of notebook programming today, right? Notebooks today can‚Äôt use graphics to define part of a program, only to visualize data. Here‚Äôs another screenshot from my paper I linked above.</p>
</div> <div class="attachments"></div> <div class="files"><p><img src="http://history.futureofcoding.org/history/msg_files/F07/F07D56L4XJR.png" alt="Screenshot 2024-07-19 at 8.40.06‚ÄØAM.png"></p>
</div></div><div id="2024-07-19T15:42:11.829Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T15:42:11.829Z" class="date">2024-07-19 15:42:11</a> <div class="message"><p>I begin to wonder whether my paper is relevant to this discussion and could perhaps provide a clarifying framework.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T16:18:07.139Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T16:18:07.139Z" class="date">2024-07-19 16:18:07</a> <div class="message"><p>notebooks are definitely capable of reading external data and making dynamic, executable decisions based on it. The also have a ton of affordances for representing data visually, and for implementing UIs inline. So together all those things seem like level 3 to me, but some assembly is required. The browser itself has <a href="https://observablehq.com/@tomlarkworthy/local-storage-view">local storage </a>and the env has internet access so I think persistence is a red herring if you consider the system as a whole.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T16:31:06.662Z" class="reply"><span class="user">Ivan Reese</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T16:31:06.662Z" class="date">2024-07-19 16:31:06</a> <div class="message"><p>What <strong>@Nikita Prokopov</strong> is arguing for in level 3, and what <a href="https://twitter.com/qualmist">Joshua Horowitz</a> seems to be referring to, is the desire for such tools that  <em>don't</em>  require "some assembly". The amount of assembly needed to go from notebook to programming-with-diagrams is about the same amount of assembly to go from smalltalk to programming-with-diagrams or the web platform to programming-with-diagrams. So while notebooks certainly are nice environments to work in, and while it would be nice if notebooks offered p-w-d out of the box, I don't think it's true that "this is basically notebook programming", unless it's also true that this is basically smalltalk or basically javascript.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T17:24:10.042Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T17:24:10.042Z" class="date">2024-07-19 17:24:10</a> <div class="message"><p>I appreciate the reminder to go reread <a href="https://twitter.com/qualmist">Joshua Horowitz</a>'s paper. Very useful framework and I'd completely forgotten about it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T18:26:00.288Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T18:26:00.288Z" class="date">2024-07-19 18:26:00</a> <div class="message"><p>With great timing, somebody just showed me <a href="https://holzer.online/articles/calculate-contrast-ratio/index.html">holzer.online/articles/calculate-contrast-ratio/index.html</a> which manages in a very narrow way to be both live and rich (if I understand correctly).</p>
<p>Still not composable, though..</p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://holzer.online/articles/calculate-contrast-ratio/index.html">How to calculate the contrast ratio of two colors - Fabian's public notepad</a></p>
<p>Thoughts on topics like software engineering, web development, blogging and the web in general</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-07-19T20:15:35.478Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:15:35.478Z" class="date">2024-07-19 20:15:35</a> <div class="message"><p><a href="https://webcode.run">Tom Larkworthy</a>: Notebooks are great at displaying runtime state. You can also use them to render UIs, with which you can modify transient state. But the persistent code that makes up a notebook can only be edited through the notebook‚Äôs code editor. If I want to edit a state chart graphically and have that be part of the code my notebook runs, I can‚Äôt do that with Observable or Jupyter or whatever without very awkward workflows (like copy-pasting text from an Observable output cell into a code cell). Interactions with graphical things rendered in a notebook don‚Äôt survive a browser refresh. So they do not pull off the <strong>@Nikita Prokopov</strong> level-3 thing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T20:16:14.061Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:16:14.061Z" class="date">2024-07-19 20:16:14</a> <div class="message"><p>(There are some Jupyter extensions like mage that partially fix this.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T20:18:46.876Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:18:46.876Z" class="date">2024-07-19 20:18:46</a> <div class="message"><p>I roughly agree with <a href="http://ivanish.ca/">Ivan Reese</a>‚Äôs response, except that notebooks do have a slight advantage ‚Äì if I‚Äôm ok editing a ‚Äúdiagrammatic program‚Äù through textual data, then I can do that in Observable, and also have Observable visualize the ‚Äúdiagrammatic program‚Äù, live, in the place where I‚Äôm editing it. Doing that in a trad dev environment would make it harder to see that visualization.</p>
<p>My issue is that I don‚Äôt want to edit a diagrammatic program through textual data ‚Äì I wanna edit it through a diagram!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T20:25:25.120Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:25:25.120Z" class="date">2024-07-19 20:25:25</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> That website is an interesting case, because there we‚Äôre not talking about a program-authoring environment being live and/or rich; we‚Äôre talking about a (one-off) program-reading environment being live and/or rich. I agree that it‚Äôs kinda live! (Wish it had a more fine-grained liveness tho ‚Äì like don‚Äôt you want to see the relativeLuminance values, not just the final output?) As a test rig of the code, it‚Äôs kinda rich, in that you‚Äôre editing the test inputs with a direct-manipulation editor‚Ä¶ but it feels weird to call that rich, cuz we‚Äôre not editing the  <em>program</em>  in a rich way, just some test inputs. But I see where you‚Äôre coming from.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T20:56:11.053Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T20:56:11.053Z" class="date">2024-07-19 20:56:11</a> <div class="message"><p>observable views are a UI + a data-channel and they can be 2-way bound to other UI components, composed <a href="https://observablehq.com/@tomlarkworthy/view">hierarchically</a>, or  <em>even bound to persistence [</em> <a href="https://observablehq.com/@tomlarkworthy/local-storage-view">local</a> <em>view,</em> <a href="https://observablehq.com/@tomlarkworthy/shareview">shared</a> <em>view]</em> . Diagrammatic editing is a little hard, and this conversation has made me try to see if Plot can be made editable (they do expose their grammar-of-graphics scales and an interactive <a href="https://observablehq.com/plot/interactions/pointer">pointer</a> mark which seems relevant)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:21:57.665Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:21:57.665Z" class="date">2024-07-19 21:21:57</a> <div class="message"><p><a href="https://webcode.run">Tom Larkworthy</a> The only part of your comment which is relevant to what I‚Äôm talking about is the part about local/shared persistence. I appreciate the effort you‚Äôve put into getting around Observable‚Äôs lack of support for this stuff! But those approaches are limited and awkward:</p>
<ul><li>If we‚Äôre talking about using UI to edit your notebook‚Äôs code, local persistence is a non-starter‚Ä¶ the point of notebooks is to share code.</li><li>The shared view has no authentication. So if you used it to author part of the notebook‚Äôs code, anyone with access to the notebook would be able to modify it‚Äôs code. If you added authentication, you would then have two separate, parallel auth systems to keep synchronized ‚Äî one for Observable &amp; one for your sharing system.</li><li>In both local + shared situations, you have to add IDs by hand whenever you want to persist something. If you clone a cell, it keeps the same ID, so it edits the same underlying (local or cloud) state. You gotta remember to change them or you‚Äôll clobber stuff. Same for cloning / forking notebooks.</li></ul><p>In short, I think these approaches all get very awkward, arguably no less awkward than copy-pasting code into cells. I‚Äôd be curious to hear whether you‚Äôve heard of them being used successfully in practice, in the face of these problems.</p>
<p>Personally, I‚Äôd like it if Observable could add persistent UI-editable state, so we wouldn‚Äôt have to make up work-arounds. But I don‚Äôt see that happening, given that the company is no longer focusing on the notebook product. Perhaps some other notebook product could get in the game, maybe something open-source?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T21:24:09.754Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T21:24:09.754Z" class="date">2024-07-19 21:24:09</a> <div class="message"><p>(As for interactivity in Observable Plot, which is besides any point I‚Äôm making but a good question: I know that lack of good interactivity is one of the main reasons my advisor hasn‚Äôt switched his data vis course to use Observable Plot.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-19T22:36:45.569Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-16&amp;toDate=2024-07-22&amp;channel=linking-together&amp;filter=#2024-07-19T22:36:45.569Z" class="date">2024-07-19 22:36:45</a> <div class="message"><p>I have build several apps on Observable using these techniques</p>
<ul><li>(commercial) <a href="https://observablehq.com/@categorise/surveyslate-filler?username=demoResponder#FnMcjZO1pn1uqmMh%7Ccell-types">observablehq.com/@categorise/surveyslate-filler?username=demoResponder#FnMcjZO1pn1uqmMh%7Ccell-types</a>. &lt;-- magic link authentication to AWS, hosted on a custom domain, persistence is just S3. Whole application is a single cell assembled heirarchically and bound to S3</li><li>(fun) <a href="https://thetarot.online/-O2C-4yex9ykAwoZ_Jvz">thetarot.online</a> no auth, custom domain, also embedded in a Medium article</li><li>(personal) <a href="https://observablehq.com/@tomlarkworthy/minecraft-servers-be">minecraft server front end</a> Firebase login and backend</li></ul><p>The things you say are true in that there are numerous annoying frictions, CORS being the worse one IMHO, but still, compared to setting up Jest on a Typescript project, or installing Numpy, these are not deal breakers, and the reactive environment makes up for all that, with surplus IMHO. There is a bit of a complexity/performance ceiling, but I would say that is true of Jupyter and Excel too, it doesn't stop them being incredibly useful internal micro-apps.</p>
<p>There are several open source Observable-likes in existence already</p>
<ul><li><a href="https://github.com/asg017/dataflow">github.com/asg017/dataflow</a></li><li><a href="https://starboard.gg/">starboard.gg</a></li></ul><p>Building something that is good enough IDE/Visual Env/Ecosystem is basically too large a project to pull off. Even Observable hasn't really pulled it off! I don't think saving the state of the notebook is  <em>the</em>  problem.</p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://thetarot.online/-O2C-4yex9ykAwoZ_Jvz">Tarot Reading for Tom on behalf of Joshua Horowitz</a></p>
<p>Will Joshua have a realisation about the ability to develop faster on Observable reactive Notebooks?</p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-07-20T11:19:22.047Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=linking-together&amp;filter=#2024-07-20T11:19:22.047Z" class="date">2024-07-20 11:19:22</a> <div class="message"><p>Level 3 is straight-forward (and ‚Äúeasy‚Äù) with currently-available technologies:</p>
<ul><li>use diagram editors that save diagrams in some kind of XML or JSON format (I use <a href="http://draw.io">draw.io</a>, I use Kinopio, I‚Äôve used yEd in the past), then, use XML parsing libraries or OhmJS to inhale the info</li><li>isolate software components from one another - make each unit of software be completely stand-alone - meaning data  <em>and</em>  control flow - [hint: closures, queues, avoid function-calling for inter-component communication (level-3 innovation is discouraged by function-calling-think (in fact, at one point, I used mostly Prolog for thinking along with Javascript and Bash and Lisp for clean-up))]</li><li>think of current GPLs - Haskell, Python, Javascript, Rust, Lisp - as just  <em>assembly</em>  languages for level 3.</li></ul><p>(aside: meaning of ‚Äúeasy‚Äù == Zac Nowicki of Kagi created a <a href="http://draw.io">draw.io</a>+Odin based Level 3 DPL for me in less than a week)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-07-20T14:24:44.377Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=linking-together&amp;filter=#2024-07-20T14:24:44.377Z" class="date">2024-07-20 14:24:44</a> <div class="message"><p>ok, interesting, just a prototype but if you click on the plot it adds a point there. The nice thing is that you can work in the coordinate space of the diagram, not pixels or viewport. Maybe plot can be an input ü§î</p>
<p><a href="https://observablehq.com/d/e627aaaaa9857257">observablehq.com/d/e627aaaaa9857257</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://observablehq.com/d/e627aaaaa9857257">Direct Manipulation Plot Experiment</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2024-07-21T20:29:58.308Z" class="reply"><span class="user">Dennis Hansen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-18&amp;toDate=2024-07-24&amp;channel=linking-together&amp;filter=#2024-07-21T20:29:58.308Z" class="date">2024-07-21 20:29:58</a> <div class="message"><p>FWIW I tend to think the ideal environment allows for all of them: code, dumb diagrams, code backed diagrams, diagrams that are 'code', and everything outside and between. If these coexist in a shared environment, we have the best chance at mutating them and ideally converging on the must useful representations for differing situations. (it is also of my personal opinion that diagrams as code will flourish in this kind of a environment)</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-07-20T19:50:21.867Z" class="post"><span class="user">Christopher Galtenberg</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-17&amp;toDate=2024-07-23&amp;channel=linking-together&amp;filter=#2024-07-20T19:50:21.867Z" class="date">2024-07-20 19:50:21</a> <div class="message"><p><a href="https://merveilles.town/@zens/112793890297088472">merveilles.town/@zens/112793890297088472</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://merveilles.town/@zens/112793890297088472">Luci for dyeing (@zens@merveilles.town)</a></p>
<p>a huge formative experience happened when I was 16. I was brought into my mother‚Äôs office and hired to compell a guy to use his computer who was refusing to use his computer, and exclusively used his IBM selectric. </p>
</blockquote>
<p>First up, the guy was an unlikable jerk. However, first thing he does when I get there is refuse to even talk to me about the situation until AFTER I read The Invisible Computer by Donald Norman. </p>
<p>It‚Äôs a good book I cannot summarise in the 50 characters I have left in this post</p>
</div> <div class="files"></div> <div class="replies"></div></div><div id="2024-07-21T19:39:49.246Z" class="post"><span class="user">Nilesh Trivedi</span> <a href="https://history.futureofcoding.org/?fromDate=2024-07-18&amp;toDate=2024-07-24&amp;channel=linking-together&amp;filter=#2024-07-21T19:39:49.246Z" class="date">2024-07-21 19:39:49</a> <div class="message"><p><a href="https://www.edgedb.com/blog/we-can-do-better-than-sql">edgedb.com/blog/we-can-do-better-than-sql</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://www.edgedb.com/blog/we-can-do-better-than-sql">We Can Do Better Than SQL | EdgeDB Blog</a></p>
<p>The questions we often hear are ‚ÄúWhy create a new query language?‚Äù and ‚ÄúWhat‚Äôs wrong with SQL?‚Äù. This blog post contains answers to both.</p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div>
    </div>
  </body>
</html>
