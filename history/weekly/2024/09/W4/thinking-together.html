
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2024-09-16T23:02:56.289Z" class="post"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-13&amp;toDate=2024-09-19&amp;channel=thinking-together&amp;filter=#2024-09-16T23:02:56.289Z" class="date">2024-09-16 23:02:56</a> <div class="message"><p>I am now blogging about design engineering in organizations that deal with lots of domain knowledge(s). This post covers metrics that don't do what your manager thinks they do, and why interdisciplinary work has trouble finding a good home.</p>
<p><a href="https://designengineers.substack.com/p/the-myopia-of-professionalism">designengineers.substack.com/p/the-myopia-of-professionalism</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-09-17T01:25:24.121Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T01:25:24.121Z" class="date">2024-09-17 01:25:24</a> <div class="message"><p>I feel like I understand what you're saying for a second, but then I blink and it disappears.</p>
<hr><blockquote><p>I propose that experts supply and evaluate criticism, just as professionals supply and evaluate metrics.</p>
</blockquote>
<p>Are professionals and experts different people here? Earlier in the article it seems like they're just synonyms.</p>
<hr><p>The part that seemed most fertile was the 3 pictures of domains between the two halves.</p>
<hr><p>I don't quite see how the two halves connect. The major connection I see is between translations between domains and boundary objects between teams. Is there more? Perhaps what's missing is an introduction or conclusion that lives outside the two halves. Or perhaps they should be two distinct posts?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T01:46:07.024Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T01:46:07.024Z" class="date">2024-09-17 01:46:07</a> <div class="message"><p>Yes, that makes sense - thank you for unpacking the disconnect there.</p>
<p>I completely skipped over the definition of a domain (following David Ribes' workplace ethnographies). That would set up the second half as a payoff to the first half, because the boundary object solves the problem where the domains hate to explain themselves to each other (because switching languages  <em>is</em>  really slow and frustrating).</p>
<p>The role of the 'expert' is not grafted quite right into the world of the 'professional' from Stengers' essay. It should be 'public intellectuals', university-affiliated or otherwise.</p>
<p>I expand on the picture of domains at three 'zoom levels' in the BELIV paper! Which is in a dense academic style unfortunately.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T01:51:41.960Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T01:51:41.960Z" class="date">2024-09-17 01:51:41</a> <div class="message"><p>I was between either covering explainability in terms of gesture next week, or the difference between an 'evaluation gap' and an 'execution gap' in debugging practices. But going straight through Ribes is a solid plan, considering I need to brush up on my CSCW.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T08:54:37.763Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T08:54:37.763Z" class="date">2024-09-17 08:54:37</a> <div class="message"><p>Like <a href="http://akkartik.name/about">Kartik Agaram</a>, I am a bit confused about the roles. I see the issues you raise every day in academia, between scientists from different backgrounds and also between researchers and management. But if academics are "experts", then we have no "professionals" in this situation. I see researchers taking both roles, though not on the same subject.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T16:05:36.326Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T16:05:36.326Z" class="date">2024-09-17 16:05:36</a> <div class="message"><p>Hmm, the tricky thing with researchers is that everyone I've met in academia wears at least four different hats. Multiple inheritance, y'know? Perhaps a set of 'partial roles' e.g. domain practitioner / literature expert / institutional administrator is called for.</p>
<p>Absolutely, this means the incentive structures for each role are actually more complex than 'metrics vs. critique'. Otoh, incentives aren't necessarily blended between multiple roles, because people will take on jobs they weren't hired to do on paper. Therefore, within the context of  <em>how do I form a stable niche in my institution</em> , it might actually become a simple taxonomy of roles again? Albeit, rather cynical.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T05:14:35.384Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T05:14:35.384Z" class="date">2024-09-18 05:14:35</a> <div class="message"><p>Four hats may be true. That's actually an aspect of academia that I like. It's a more diverse environment than the typical business with its more sharply defined roles. And it provides more individual freedom.</p>
<p>And yet, as I said, the core observation of your post applies to academia as well. Maybe the incentive structure matters less than we think? Or is more complex than often described?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T15:55:40.173Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T15:55:40.173Z" class="date">2024-09-18 15:55:40</a> <div class="message"><p>Yes, absolutely. It needn't be a complex set of institutional incentives, even; but your response is not knowable to me, thus you can form a niche that I wouldn't be able to predict. See, if I ascribe someone a fixed utility function, then - first off, that says more about me than about them. But let's say the point of a given role is that I can predict that person's utility function, i.e. what kinds of resource and relationship I can offer in exchange for their labor.</p>
<p>Now if you've got four hats, then I don't know what your switching condition is. Maybe you want to work from home because of family commitments; or conversely, maybe those are pushing you to the office. And all that gives you freedom from the simplifying gaze of post-Fordism and (ugh) scientific management, in terms of being able to defy its expectations. (Not as in being able to make money outside of it.)</p>
<p>Now a really important corollary of the 'freedom of multiple hats' is the ability to switch between metrics, critique, and other evaluation strategies. That's going to make up the part of my tenure packet, or grant proposal, that I can actually design on the spot. It's critical that my strategy be legible to the manager, or the funding source, or whoever is evaluating that. And that's how I hit the impasse where some methods are respectable right now, and some other methods are actually productive for my questions.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T15:59:50.969Z" class="reply"><span class="user">Jasmine Otto</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T15:59:50.969Z" class="date">2024-09-18 15:59:50</a> <div class="message"><p>Which is not to say that just browbeating the managers into respecting humanistic inquiry is a reasonable solution for getting grants. (Or conversely, to argue that research artifacts themselves act as repositories of knowledge.) But there's a version of our institutions that rewards broader knowledge than a manager 'really needs' to have, and is capable of addressing the long-running <em>n-cultures problem</em> .</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2024-09-17T10:36:32.396Z" class="post"><span class="user">Misha A</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T10:36:32.396Z" class="date">2024-09-17 10:36:32</a> <div class="message"><p>What is "program"? essentially, conceptually.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2024-09-17T11:32:25.880Z" class="reply"><span class="user">Denny Vrandeƒçiƒá</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T11:32:25.880Z" class="date">2024-09-17 11:32:25</a> <div class="message"><p>What is the ontology that you accept for answering the question?</p>
<p>It can go from "it is a sequence of instructions" to "it is the human-readable specification of an application that can be executed on a chip" to "it's a valid string according to the grammar of a specific programming language". Is a "program" the same as an "app" or the same as a "source code"? Without context, it is difficult to even start answering the question.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T17:24:56.503Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T17:24:56.503Z" class="date">2024-09-17 17:24:56</a> <div class="message"><p>from a system-centric pov, a program is just a message to a system that modifies the system's behavior. incidentally, data is the same.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T18:01:30.415Z" class="reply"><span class="user">Misha A</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T18:01:30.415Z" class="date">2024-09-17 18:01:30</a> <div class="message">
<blockquote><p>Without context, it is difficult to even start answering the question.</p>
</blockquote>
<p>fair.</p>
<p>I have a strong lasting feeling that most of daily programming routines I do as developer ‚Äì are incidental complexity‚Ñ¢.</p>
<p>So I am trying to figure out what is the essential complexity‚Ñ¢ of programming.</p>
<p>Assuming mapping from program to how-to-run-it-on-hardware is factored out ‚Äì what is left?</p>
<p>Can that execution mapping  <em>really</em>  be factored out?</p>
<p>Is there a language for "what is left"?</p>
<p>is it eg. Prolog? TLA+?</p>
<p>What should that language help with?</p>
<p>My take on it so far is "program is mapping from state to state". Which makes it a function?</p>
<p>Is "real" program different from a function only because it is also "mapped onto hardware"? Or is there something else missing?</p>
<p>If program is a function, then programming language is a tool for "convenient" description of state-to-state mapping?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T18:56:10.463Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T18:56:10.463Z" class="date">2024-09-17 18:56:10</a> <div class="message"><p>no the state-to-state thing is not important IMHO. IO i.e. stdin/stdout, thats the important bit. Moving state around a RAM chip is not useful, its only when the computer is between keyboard and monitor that it becomes useful and interesting. IO, the side-effects, is the point, to me anyway. So I do think the hardware mapping is the important bit.</p>
<p>When considering the internals, I think the state-to-state bit is useful when domain mapping, converting between domain representations and abstraction levels. Then thats when the computer becomes a tool for the mind (coz it unburdens you from doing domain mappings in your head)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T22:32:48.150Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T22:32:48.150Z" class="date">2024-09-17 22:32:48</a> <div class="message"><p>I‚Äôll just drop in some commentary I made on another forum:</p>
<blockquote><p>It‚Äôs sort of ‚Äúfolk wisdom‚Äù in some of my social circles that it is actually very hard to define programming, or to draw clean lines between programming and not-programming.</p>
</blockquote>
<p>For example, ‚Äúprogramming = writing textual code‚Äù breaks down because of visual programming languages, structured editors, etc. The broader ‚Äúprogramming = manipulating symbolic representations roughly equivalent to textual code‚Äù breaks down because of Drawing Dynamic Visualizations / Wrangler / programming-by-demonstration.</p>
<p>So sometimes I go for ends rather than means, like ‚Äúprogramming = authoring dynamic artifacts‚Äù. But lol what are dynamic artifacts? Oh, they‚Äôre ‚Äúartifacts that respond differently to changing inputs / interactions / circumstances‚Äù, in contrast to ‚Äústatic artifacts‚Äù. But </p>
<pre><code>n = 0

for i in range(10):

  i += n

print(n)</code></pre><blockquote><p>only ever produces one output value... Is it a dynamic artifact? Is a HTML website that responds to changing screen size with CSS rules a dynamic artifact? Which of these are programming?</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-17T22:53:57.526Z" class="reply"><span class="user">Shalabh</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-14&amp;toDate=2024-09-20&amp;channel=thinking-together&amp;filter=#2024-09-17T22:53:57.526Z" class="date">2024-09-17 22:53:57</a> <div class="message"><p>state-to-state is one model of behavior and in general a program is a representation of some subset of system behavior.</p>
<p>a typical 'program' is missing a lot of aspects. notably any notion of persistence is absent. data lives on longer than programs. newer programs have to contend with data left over by old programs (or earlier versions). this is why i think the typical notion of a program as this transient entity you run, which computes something and then is done, does not get close to covering the entire span of system behavior.</p>
<p>there is a fair bit of incidental vs accidental complexity discussion in the past in this slack if you search the history. there was also the related tarpit episode <a href="https://futureofcoding.org/episodes/063.html">futureofcoding.org/episodes/063.html</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T04:15:27.680Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T04:15:27.680Z" class="date">2024-09-18 04:15:27</a> <div class="message"><p><a href="https://twitter.com/qualmist">Joshua Horowitz</a> movies support moving pictures but you can freeze an image or even go to black. Analogously, it seems to me that the dynamism is a possibility the medium provides, whether or not any particular work uses it.</p>
<p>I gather people were making stage plays in the new medium for decades while gradually understanding dawned of all the new possibilities that it opened up.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T09:25:45.837Z" class="reply"><span class="user">Joshua Horowitz</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T09:25:45.837Z" class="date">2024-09-18 09:25:45</a> <div class="message"><p><a href="http://akkartik.name/about">Kartik Agaram</a> I don‚Äôt think that quite gets at what‚Äôs interesting to me about the Python test case. I don‚Äôt see that script as, like, a degenerate program, in the same way that a single-frozen-frame movie would be a degenerate movie. I think that script DOES take advantage of the dynamism the medium provides. But its output is entirely static! This means you shouldn‚Äôt judge something to be a ‚Äúprogram‚Äù or a ‚Äúdynamic artifact‚Äù solely on the basis of its externally visible behavior treated as a black box. Sometimes you care about how the externally visible behavior responds to edits in the artifact itself. But I don‚Äôt know how to pin this down.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-18T09:49:24.016Z" class="reply"><span class="user">Duncan Cragg</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-15&amp;toDate=2024-09-21&amp;channel=thinking-together&amp;filter=#2024-09-18T09:49:24.016Z" class="date">2024-09-18 09:49:24</a> <div class="message"><p><strong>@Misha A</strong> I think you've basically nailed it in what you said there. This is exactly how I started my journey: looking for "the essence of programming". I described it as seeking a "Target and Domain Independent" programming language: one that was unconstrained by having to execute it on specific hardware Target, and untarnished by the needs of any given Domain. My conclusion was exactly what you're saying: that programs move one state to the next. That's basically it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-19T02:27:11.583Z" class="reply"><span class="user">Misha A</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-16&amp;toDate=2024-09-22&amp;channel=thinking-together&amp;filter=#2024-09-19T02:27:11.583Z" class="date">2024-09-19 02:27:11</a> <div class="message"><p>re: state vs. IO</p>
<p>it seems to me that IO is state too. The question is: at what point it becomes more useful/convenient to start distinguishing between the two.</p>
<p>What would be the difference?</p>
<p>Should  <em>the</em>  programming language treat them as the same, but let user introduce the difference when necessary. Or should the difference be baked in already?</p>
<p>What is the difference, again?</p>
<p>What other differences between seemingly same things are better ("better" when, for whom?) to be baked into  <em>the</em>  language?</p>
<p>It seems that the programming languages game is all about designing syntax(tool) convenience proportionally to task frequency. Seeing a lot of same things as different ‚Äì breeds proliferation of tools. So maybe seeing similar things as the same would reduce tools ... "fragmentation"? (e.g. java's classes with their personal new-every-time-DSLs vs clojure's "everything is a map, but these several functions is all you ever have to learn")</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-20T22:19:24.838Z" class="reply"><span class="user">Mark Dewing</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-17&amp;toDate=2024-09-23&amp;channel=thinking-together&amp;filter=#2024-09-20T22:19:24.838Z" class="date">2024-09-20 22:19:24</a> <div class="message"><p>Related to the 'incidental complexity' question - sometimes I get frustrated with all the code it seems to take to do even simple tasks.  I question why there are so many lines of code?  Why can't the computer just do what I intend?  I've thought about categorizing the lines of code in some of my programs to see what all those lines are doing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-21T01:04:10.143Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-18&amp;toDate=2024-09-24&amp;channel=thinking-together&amp;filter=#2024-09-21T01:04:10.143Z" class="date">2024-09-21 01:04:10</a> <div class="message"><p>I've heard this line of reasoning before, and it's worth questioning the premise. For some arbitrary computing task, how do we know how simple it is? I don't think we can, short of building it from scratch for ourselves. And so we can't really make any assumptions about the level of essential/incidental complexity of a task without a lot of careful effort and analysis. It's tedious, error-prone, intricately-detailed work.</p>
<p>It's definitely a common reaction, and I've been guilty of it myself. My best guess these days is that it's a cognitive fallacy related to <a href="https://en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec's Paradox</a>. People just have really poor intuitions when it comes to computation. Simple things a child can learn without us grown-ups exerting any effort require tremendous quantities of effort for a computer to "learn". And the human reaction is repeated disbelief. That can't be right!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-21T03:24:33.112Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-18&amp;toDate=2024-09-24&amp;channel=thinking-together&amp;filter=#2024-09-21T03:24:33.112Z" class="date">2024-09-21 03:24:33</a> <div class="message"><p>Here's how I see it:  <em>everything</em>  is complicated...</p>
<p>The idea of creating general purpose languages is a loser...</p>
<p><a href="https://open.substack.com/pub/programmingsimplicity/p/programming-is-too-complicated?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true">open.substack.com/pub/programmingsimplicity/p/programming-is-too-complicated?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-21T03:35:10.189Z" class="reply"><span class="user">Kartik Agaram</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-18&amp;toDate=2024-09-24&amp;channel=thinking-together&amp;filter=#2024-09-21T03:35:10.189Z" class="date">2024-09-21 03:35:10</a> <div class="message"><p><a href="http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail">Reality has a surprising amount of detail.</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-22T07:00:28.754Z" class="reply"><span class="user">Misha A</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-19&amp;toDate=2024-09-25&amp;channel=thinking-together&amp;filter=#2024-09-22T07:00:28.754Z" class="date">2024-09-22 07:00:28</a> <div class="message"><p>For some reason I get "then it does not matter" from "everything is complicated" comments.</p>
<p>If everything is complicated, why not deal with essential complexity instead of incidental one?</p>
<p>Feels like comparable amount of work, but radically different outcomes.</p>
<p><a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">The Thirty Million Line Problem</a></p>
<p><a href="https://youtu.be/rX0ItVEVjHc?t=1372">Mike Acton "Data-Oriented Design"</a></p>
<p>Sometimes treating different things the same way makes things easier or even simpler.</p>
<p>Sometimes treating similar things differently does.</p>
<p>but it seems to me, scanning this space of variations is more tractable from the root tree-side, where combinatorics haven't really kick in yet.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2024-09-23T15:49:43.853Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-20&amp;toDate=2024-09-26&amp;channel=thinking-together&amp;filter=#2024-09-23T15:49:43.853Z" class="date">2024-09-23 15:49:43</a> <div class="message">
<blockquote><p><a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">The Thirty Million Line Problem</a></p>
</blockquote>
<p>I watched this several years ago and deeply disagree with the conclusion. IIRC, Moratori blames USB Plug'N'Play on the exponential rise in complexity in software development. He bases his conclusion on a graph that shows the correlation between complexity and the invention of USB Plug'N'Play. Basic science says that correlation does not imply causation. The fact that the hockey stick curve of complexity jumps upwards at the same time as USB Plug'N'Play was invented does not necessarily mean that USB Plug'N'Play  <em>caused</em>  the rise in complexity. In fact, a different explanation for this particular correlation might be as a manifestation of incidental complexity caused by something much deeper and invented much earlier (hint: over-use of the function-based paradigm).</p>
<p>[Note that this, also, ties in with bicycles-for-the-mind thread. Programmers have forgotten how the hardware works and have veered off into believing that there is only one way to program hardware - i.e. with lines of code written in programming languages buttressed by operating systems.]</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">The Thirty Million Line Problem</a></p>
<p><img src="https://i.ytimg.com/vi/kZRE7HIO3vk/hqdefault.jpg" alt="The Thirty Million Line Problem"></p>
</blockquote>
</div> <div class="files"></div></div></div></div><div id="2024-09-19T19:13:22.938Z" class="post"><span class="user">Christopher Shank</span> <a href="https://history.futureofcoding.org/?fromDate=2024-09-16&amp;toDate=2024-09-22&amp;channel=thinking-together&amp;filter=#2024-09-19T19:13:22.938Z" class="date">2024-09-19 19:13:22</a> <div class="message"><p>I like this metaphor of translucent software both as a callback to the translucent hardware aesthetic of the 2000s, but also to progressively display the underlying mechanisms of software  ~<em><em>if</em></em>~  you want to see it.</p>
<p><a href="https://x.com/lesliexin/status/1836643348490187183">x.com/lesliexin/status/1836643348490187183</a></p>
</div> <div class="attachments">
<blockquote><p>üê¶ <a href="https://x.com/lesliexin/status/1836643348490187183">leslie (@lesliexin) on X</a>: Finally got around to building this :) </p>
<p>Try it at <a href="https://t.co/S82Yp0nkKw">https://t.co/S82Yp0nkKw</a></p>
<p><img src="https://pbs.twimg.com/ext_tw_video_thumb/1836643326537129984/pu/img/WHwkOV9cVDHOiUQZ.jpg:large" alt="Tweet Thumbnail"></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div>
    </div>
  </body>
</html>
