*[2020-04-25 06:43:01]* **Unknown User**:

MSG NOT FOUND


> *[2020-04-26 22:08:04]* **Achraf Kassioui**:

There's a rule in the CoC that I very much like: "Discuss politics, economics, representation, social movements and dynamics, and other maters of society".

It means there is no point in abstracting away from politics. Ideologies all over. One ideology has been freely expressed above: "the lack of gender diversity reflects structural inequalities and oppression across society". I reacted calling it "group identity politics". Others have reacted too. But those reactions got deleted, and only those reactions.

I will elaborate: I don't even buy into the premise of "we need more women in here". Maybe I am a woman. Maybe my female partner is enjoying the conversations in here every week. Maybe my daughter is currently learning how to program and is inspired by many posts and links posted here. Or maybe not. The point being: I wish to not correlate people's identity with their gender, or to single them out in that way ("look it's a woman!"). I'm not saying gender or ethnicity or religion are not important identity holders. I'm saying that they may or may not be. People have various paths in life.

My ideology is that I wish to build a path toward a situation where everyone, indeed, can afford to say what I've had just said. I.e. that I can express myself without defensively adjusting for a thousand prejudices due to my gender or ethn.. wait never mind.

And so we get to the topic of style and tacit rules. A community has clearly a dominant style. For example, some communities like banter, others have little taste for it. There are certainly ways of talking and writing that pervade this community. The very concept of an asynchronous board is not obvious to everyone (nor is Slack). If someone (who happens to be a woman, but not necessarily) stumbles across this forum and feels uncomfortable to contribute, why would you attribute that to the community being all male? Or worse even, as has been said in another thread: a community of "comfortable white men". Why do you feel the need to bring gender into this? Or race?

I am sure that intentions here are good. I even believe that the author of the phrase "the lack of gender diversity reflects structural inequalities" means well. I question however the tactics used to act on those good intentions. The first tactic is to define groups of people by gender and such, which to me utterly defeats the whole point. The second tactic is to silence whomever expresses opposition to the first tactic.


> *[2020-04-27 00:44:12]* **Shalabh Chaturvedi**:

(I'm not a moderator but I want to add my voice as one member of the community, and I'll try to be direct here.)
I completely fail to see how actual efforts towards improving diversity would adversely affect anyone here in particular. Like, if you don't think it's a worthy goal, you don't have to participate in any real efforts (no different than any other project!). All I (and I think the CoC) would ask is to don't make statements or take actions that would discourage any group based on the diversity definitions.

If all you want the ability to say anything and everything, offend and put-down, make any statement without any regard to sensitivity of other folks and social groups, sorry you are not welcome here.  You can make your statements in your personal blogs or plenty of other places. In that sense this is no different than any workplace or other community (or indeed, society itself.) It's true that the boundary of what's ok and not ok isn't always clear cut - this is no different than how the law works as well. We try our best to be fair and balanced, even though it's never one-size-fits-all. This is why we have moderators and a process to report and handle incidents.

This connects to the Paradox of Tolerance and Popper, etc. E.g. "I'm offended by diversity and what about me and my group? How come you want to exclude us?". Well then sorry, this is not the place for you. If you're not offended by diversity but are not particularly interested in it then there's no problem, is there? Participate in all the non-diversity related discussion (which is most of the slack) and try not to sabotage the diversity efforts. If there are things that offend you, then please speak up! Either directly to the moderators or in public, as you feel comfortable.


> *[2020-04-27 04:48:53]* **Vladimir Gordeev**:

Given:
1. Discussing politics is allowed by CoC
2. Various members reason in left-wing terms, thinking that it is the only way
3. Objecting to reasoning in left-wing terms(group identity) is not welcome
4. Arguing that left-wing reasoning is not the only way is not welcome either
Computes to:

Gradual removal of all members of community that don't align politically with left-wing ideas in the long term.

Am I wrong in my reasoning? **Shalabh Chaturvedi**


> *[2020-04-27 08:43:32]* **Ivan Reese**:

**Achraf Kassioui** â€” It is not okay that this community is predominately male, _because lots of people, women and men, have expressed that it makes them unhappy_. That's what this "diversity" stuff is about, at the end of the day. I think that's plenty good enough reason to do it.

**Vladimir Gordeev** â€” You're generalizing, and sensationalizing, which makes it hard to respond to you constructively.

Arguing against our diversity initiatives _in this thread_ is not welcome, because I started the thread to talk about the podcast and survey, and I asked for folks to take the diversity discussion back to **`#meta`**. It didn't happen. It just sucks that it looks like we don't get to have a discussion about the survey now. There are a ton of other interesting things we could learn from it.

I have elsewhere said something to the effect of.. further objection to the diversity initiatives is not welcome. That was a mistake on my part. Of course people need to be able to say, "Hey, this particular diversity initiative is not a good idea. I have suggestions for how we could do something better." And while I don't like it, it's not against any rules to say, "I don't think we should do diversity initiatives at all, because [for example] they'll drain resources from other initiatives, and I think that there's going to be a bigger problem if that happens." What I should have said is: There are a lot of people who are unhappy about the composition and tenor of the community, and it would be very hurtful to say that we shouldn't at least try to help them, so I will kindly ask that you not do that openly.

**Achraf Kassioui** and **Vladimir Gordeev** â€” I didn't delete your comments because of politics. Please stop simply labeling things as "left-wing" and instead explain what you mean by it. The term "left-wing" is too vague and open to interpretation because of how many different ways its used in the broader world, so if you want to make your arguments carry weight, you should instead use your own words. You're also stating that things are left-wing as though that's inherently a reason to not do those things. If that's a point that you intend to make, you'll need to explain why that is.

So again, it's not about politics for me â€” I deleted Vladimir's comment because, after reflecting on it for _hours_ and in my judgment as community moderator, I felt it was sexist in a way that'd cause harm. And since I was going to delete that comment, I decided to remove the other comments that had moved this thread in a hostile direction. Achraf, you characterized our interest in diversity as an _infection_. That's not against the rules, but it's absolutely mean spirited. Jack's comments were not mean spirited, so they remain.


> *[2020-04-27 14:18:22]* **Duncan Cragg**:

Maybe start another thread for the survey, Ivan? ðŸ˜Š


> *[2020-04-27 19:04:59]* **Ivan Reese**:

I'm going to take a break from this stuff for a few days. This has eaten up about 15 hours of my weekend, which I was looking forward to spending on Hest. What I may do from there, if I feel up to it, is start a new thread about one of the many interesting new things I've learned about our community from the survey, like the fact that my attempt to categorize what FoC topics we are interested in was way more controversial than I expected (but like.. controversial in a good way, haha), and there's probably a lot I could learn from hearing how people would have.. you know what, I'll start that thread now. Thanks for the suggestion. <3


> *[2020-04-27 23:05:52]* **Ivan Reese**:

New thread here: <https://futureofcoding.slack.com/archives/C5T9GPWFL/p1588014850297100>

---

*[2020-04-25 18:30:10]* **Unknown User**:

MSG NOT FOUND


> *[2020-04-26 23:16:00]* **Emmanuel Oga**:

A great discussion on on visual programming is found on  one of Harel's statecharts papers. He introduces the idea of topology being more fundamental than geometry


> *[2020-04-26 23:16:22]* **Emmanuel Oga**:

> When it comes to visuality, encapsulation and sideby-side adjacency are topological notions, just like edge connectivity, and are therefore worthy companions to edges in hierarchical extensions of graphs. Indeed, I believe that topology should be used first when designing a graphical language and only then one should move on to geometry. Topological features are a lot more fundamental than geometric ones, in that topology is a more basic branch of mathematics than geometry in terms of symmetries and mappings. One thing being inside another is more basic than it being smaller or larger than the other, or than one being a rectangle and the other a circle. Being connected to something is more basic than being green or yellow or being drawn with a thick line or with a thin line. I think the brain understands topological features given visually much better than it grasps geometrical ones. The mind can see easily and immediately whether things are connected or not, whether one thing encompasses another, or intersects it, etc


> *[2020-04-26 23:16:34]* **Emmanuel Oga**:

<http://www.wisdom.weizmann.ac.il/~harel/papers/Statecharts.History.pdf>


> *[2020-04-27 03:06:10]* **Edward de Jong**:

I think it best to avoid using vague terms like topology and geometry. The nested expression  f(g(h(j(k)))) can be represented in some notations as a sequence of chained operations like j(k) | h | g | f, so what was inside becomes a linear flow. Conceptually you are taking the output of a subprocedure and sending onwards to another subprocedure. Is this topology or geometry? in the classic sense of the words neither. And if some of these processes operate in parallel, then how do you notate that? Mathematics which is thousands of years old evolved from single values and calculations, and a notation that matched that, and there is very little in math history to help us when we encounter synchronized parallel processes. Really its a new offshoot of discrete math we are exploring here, and a new notation needs to be invented, because all the unicode symbols that we already have are fairly useless! I know i sifted through the 1000 of them, hoping to find some good stuff, but they mostly render poorly because typographically the graphic artists not knowing any math, designed them to be the same EM width as regular letters, making them mostly useless. Don't get me started on the problems with TeX.

The inability of the regular structures of the past, most notably the n-tuple and the matrix, were insufficiently general for my needs, hence the graph database inside Beads language, which subsumes n-tuples, matrices, and also eliminates the relational database, which i loathe.


> *[2020-04-27 03:37:32]* **Emmanuel Oga**:

Topology and Geometry are pretty well defined terms... when talking about visual programming the questions on the geometry of the objects presented on screen are front and center, and I think the main objection of ppl is that the resulting programs are hard to follow and understand because they become a tangle of nodes and arcs between them


> *[2020-04-27 03:39:23]* **Emmanuel Oga**:

I refrain from trying to "defend" or elaborate on Harel quote since my topology knowledge is so weak at the moment... it just makes sense to me intuitively that visual representations are not always the best way to attack every problem. Math has many examples of things that are very treatable on textual form but almost impossible to represent visually


> *[2020-04-27 03:44:30]* **Emmanuel Oga**:

does not mean I'm not excited about visual programming advances, feels like there's a lot of room for exploration in  the area and innovation to come. Also I feel like the answer will be a heavy mixture of textual representation sprinkled with a few diagrams here and there, much like when you open the Topology wikipedia page ðŸ™‚


> *[2020-04-27 06:42:46]* **Edward de Jong**:

My point was that much of math, especially topology, is extremely abstract, and super high abstraction is actually the opposite of what visual programming is trying to do, which is make things easier to understand. State transition diagrams as shown in the Harel notes are actually much harder to understand than some purely textual finite state transition syntaxes.  The more wires you have the worse the graphical form evolves into a hairball. That's why dependency charts of programs are often useless; above a certain crosslink percentage you get a hairball again, which provides near zero insights beyond the fact that you have made a mess of your program.

I studied many abstract mathematics branches hoping to find some great unused branch, and unfortunately what i found is that Mathematicians in general are so unconcerned with practical things that they go off into outer space, and often spend their time proving that all X is Y, or that there are only 3 solutions to Z, or that if A is true then B cannot be true, or that there are an infinite number of solutions to things. Existence, counting, classifying are their main preoccupations, and in computer programming we know what we want to do exists, and the count is based on the user input data, and classifying things gets us not much, so the intersection with pure mathematics is surprisingly weak.

---

*[2020-04-02 20:53:59]* **Unknown User**:

MSG NOT FOUND


> *[2020-04-27 01:22:12]* **Cyrus Omar**:

**Will Crichton** I think I've told you about my work on typy but it sounds up your alley so I'll plug it again ðŸ™‚

---

*[2020-04-26 19:29:52]* **Unknown User**:

MSG NOT FOUND


> *[2020-04-27 14:05:00]* **Jared Windover**:

The author makes two (on the surface) contradictory claims: redundancy generally leads to inefficiency, and db administrators introduce redundancy to increase efficiency. I think in the first case, theyâ€™re referring to developer/user efficiency, and in the second computer (db server) efficiency. Other ways that we can trade off between those two efficiencies spring to mind: low-level vs. high-level languages, simple vs. complex UI. Pretty unrelated to the content of the article, but I thought it was a little interesting.


> *[2020-04-27 18:56:13]* **Emmanuel Oga**:

I found the comment on inefficiency weird too... denormalization is wasteful in terms of storage requirements but it is usually done to avoid joins, so it ends up being a trade-off, the main problem it causes is not inefficiency but data inconsistency

---

*[2020-04-27 18:27:10]* **Scott Anderson**:

[https://adactio.com/journal/16811](https://adactio.com/journal/16811)


> *[2020-04-27 18:27:50]* **Scott Anderson**:

Users, even over authors.
Authors, even over implementors.
Implementors, even over specifiers.
Specifiers, even over theoretical purity.


> *[2020-04-27 18:28:42]* **Scott Anderson**:

HN titled it Developer efficiency prized above all else


> *[2020-04-27 18:38:56]* **Kartik Agaram**:

Yeah, that was so strange. The submitter so titled it. I'm sure somebody from HN will come along and fix it soon enough.. But I can't comprehend how anyone gets that from the post.


> *[2020-04-27 18:45:44]* **Scott Anderson**:

HN discussion [https://news.ycombinator.com/item?id=22997134](https://news.ycombinator.com/item?id=22997134)


> *[2020-04-27 18:47:13]* **Kartik Agaram**:

Ah, from OP:

> Sadly, I think the current state of â€œmodernâ€ web development reverses that principle. Developer efficiency is prized above all else.
Explains something, at least. Still strange to make it the title.


> *[2020-04-27 18:55:58]* **Scott Anderson**:

User experience, even over developer experience, sums up the article, although I'm sure in FOC there will be a lot of "why not both" I strongly agree with this. I actually think environment and language should take the experience of the end user who the software is being developed for into account and encourage developers to build good software for user. possibly by encouraging good robust performant implementation by default


> *[2020-04-27 19:02:32]* **Kartik Agaram**:

I think the conventional rhetoric about UX over DX actually impacts UX in the long run. So it feels short-sighted. If you take a long view of UX, I believe you naturally optimize for DX as well. Then again, thinking this way is what got me deep into my current yak-shave ðŸ˜„


> *[2020-04-28 17:00:48]* **Tom Lieber**:

You mean bad DX leading the software to crystallize in some suboptimal form?


> *[2020-04-28 18:59:29]* **Kartik Agaram**:

Yeah, partly. Bad DX may make more things difficult and so make feature requests seem harder.

But the more urgent part for me: bad DX can stunt potential collaborators in the 'user' stage of development for a tool. Then you get feature requests like, "can you add a preference for this so that I don't have to put up with your crappy build+install process to modify it for myself?" which further complicate the codebase.

The eco-system for Vim (and probably other text editors) shows this problem so much. You start out with a text editor that's easy to build. As it gets harder to build you get rc (settings) files, then turing-complete rc files, then plugin architectures for rc files, then plugins for plugins. And all this time people are getting increasingly discouraged from just hacking on the editor to learn how to help themselves in ways others may not have anticipated. Here's a concrete example: <https://mastodon.social/@akkartik/103994830568601931>

---

*[2020-04-27 19:14:10]* **Ivan Reese**:

One of the things that I learned while making the 2020 Community Survey is that... it was very hard for me to categorize our interests in a way that produced useful data. This question, "What FoC topics interest you most?" was my attempt at it, and it was a bit of a disaster!

I think it would be exhausting to list _all_ our possible interests, but grouping some them together also seems to have caused issues. The more we lean on the fill-in answers, the less we'll be able to identify shared interests because the way we describe them will be different. If we let people select as many answers as they want, we'll have a harder time visualizing the result set because we have to decide how to weight each selection. But if we limit the number of selections, Duncan gets really mad, and (sigh) rightfully so.

I hope it's clear what I was interested in learning from this, but I think I bungled the execution. It'd be super interesting to hear how _you_ would go able trying to structure this question. How would you build a survey that attempted to figure out what our most _central_ interests were, and to what degree we were interested in those things? The things to maximize are: how much can we learn, and how efficiently and painlessly can we collect that data from people?


> *[2020-04-27 19:17:03]* **Will Crichton**:

I wouldnâ€™t call it a disaster! What a cool graph. Even if incomplete, itâ€™s nice to see what people are interested in.

Perhaps a next iteration needs to be informed by: how do we want to use the data? If more people care about mind bicycles than blockchains, does that translate into any kind of action/policy/new slack channel/etc.?


> *[2020-04-27 19:22:22]* **Chris Maughan**:

Maybe just ask people to pick their favourite paper on [worrydream.com](http://worrydream.com) ;)


> *[2020-04-27 19:42:17]* **Duncan Cragg**:

Yeah don't be so hard on yourself. That's my job.


> *[2020-04-27 19:42:36]* **Duncan Cragg**:

ðŸ˜„


> *[2020-04-27 19:43:32]* **Duncan Cragg**:

I'm pleasantly surprised to see End-user programming so high up


> *[2020-04-27 19:44:02]* **Duncan Cragg**:

It's a good chart. And many many thanks for all your work doing this survey


> *[2020-04-27 20:10:35]* **Ivan Reese**:

**Will Crichton** â€” I can't exactly remember how I was intending to handle the outcome from this. I certainly would have had plans, but they were forgotten in the intervening months.

The one thing I do remember is that I was going to use this to help gauge what podcast subjects might be of interest. I enjoy loudly stating my biases here â€” visual programming FTW â€”Â but I am ultimately very interested in making episodes that people get a lot out of, so being able to gauge community interests (and disinterests) really helps.


> *[2020-04-27 20:39:22]* **Scott Anderson**:

It's interesting to see things lower down on the list that come up in discussion or still feel pretty fundamental


> *[2020-04-27 20:40:38]* **Scott Anderson**:

Compilers and parsing and debugging are good examples


> *[2020-04-27 23:06:51]* **Ivan Reese**:

Yeah, hey? I feel there's a really interesting story yet to be uncovered behind this question.. just not sure quite how to do that.


> *[2020-04-27 23:08:54]* **Ivan Reese**:

So many stories. Eg: Blockchain just can't catch a break. Oh well!


> *[2020-04-27 23:14:44]* **Will Crichton**:

For me, I picked topics at the intersection of {donâ€™t get enough attention} x {potential impact}. Compilers has impact, but is a huge research field so I donâ€™t need more of it from FoC.


> *[2020-04-27 23:20:14]* **Scott Anderson**:

I figured most people would have a similar heuristic


> *[2020-04-27 23:48:53]* **Scott Anderson**:

Visual programming "feels" like it should be better, I know every visual programming discussion ends up in someone bringing up that visual programming has existed for a long time, that there are already successful visual programming environments in wide use (or alternatively that it "just doesn't work"), but most examples are node and wire, and there is a feeling that even node and wire could be much better


> *[2020-04-28 00:20:53]* **Doug Moen**:

I think this would benefit from a multi-dimensional categorization, instead of a single linear list. Identify some mostly-orthogonal axes, then partition each axis into mostly-non-overlapping topics.


> *[2020-04-28 00:25:11]* **Dan Cook**:

I wonder if categories would be clearer with separation between problem-space (e.g. making computing accessible) and solution-space (e.g. through drag and drop block languages)


> *[2020-04-28 16:51:35]* **Alex Wein**:

I took a stab at visualizing the overlaps in interests. <https://observablehq.com/@a-lexwein/what-future-of-coding-topics-interest-you-most>.  Shout-out to my fellow lurkers who are into data visualization and spreadsheets!


> *[2020-04-28 17:05:53]* **Ivan Reese**:

Awesome! I had tried something like that, but using circle radius instead of color, and it was a mess. This is much nicer.


> *[2020-04-28 17:06:27]* **Tom Lieber**:

Awesome, Alex. Looks like we shouldn't hold our breath for blockchain compilers or type-assisted video game editorsâ€¦


> *[2020-04-28 17:11:44]* **Ivan Reese**:

I shared it to the main channel to boost visibility. I'll also add this to the episode page, and probably tweet it out â€”Â if that's cool with you, **Alex Wein**


> *[2020-04-28 17:12:08]* **Ivan Reese**:

(If you want me to include a plug, for your website or something, DM me the link)


> *[2020-04-29 22:43:07]* **David Piepgrass**:

Regardless of what kind of election it is, I always prefer "approval voting" ("Which of these do you like?") over "first-past-the-post" ("Which is your favorite?"). One way to look at it is that, if there are 16 questions, "Which is your favorite" gathers 4 bits of information while "which of these do you like?" gathers 16 bits: it is more informative, both theoretically and practically.

You can do even better with Score Voting: "On a scale of 0 to 10, how interested are you in each of these topics?"

P.S. How come I didn't know that a community survey exists?


> *[2020-04-30 02:58:08]* **William Taysom**:

One thing with "first-past-the-post" voting as **David Piepgrass** called it is that similar things end up competing.  This could explain why Visual Programming is high and Block Languages is low.


> *[2020-04-30 02:59:12]* **William Taysom**:

If we do choose a different way to ask questions next time, it might make sense to also have the old way to offer continuity.


> *[2020-04-30 15:57:10]* **Ivan Reese**:

**David Piepgrass** Agreed â€” this survey question allowed people to make up to 12 selections. Not perfect, but better than "pick your 1 favourite".

As for how you would have missed the survey... It ran in January, and I posted about it in **`#general`** something like 3 or 4 times, and mentioned it in the podcast. And it was mentioned in the newsletter at least once, maybe twice? I think you would have been around then, since we did a meetup in Jan IIRC. So.. who knows!

---

*[2020-04-27 23:50:36]* **Paul Butler**:

I've been thinking lately about a genre (for lack of a better word) of coding pedagogy that involves presenting the learner with a series of tasks of escalating difficulty with _very little_ new content to read/study in between. Some examples I consider to fall under this are:
â€¢ Project Euler (number theory / recreational math)
â€¢ [rosland.info](http://rosland.info) (bioinformatics)
â€¢ [exercism.io](http://exercism.io) (language-specific tracks)
Are there examples of this style of learning in other programming domains? (e.g. 3d graphics, core CS, etc.) Other thoughts on this style of learning?


> *[2020-04-28 00:35:03]* **Shalabh Chaturvedi**:

Have you looked at [executeprogram.com](http://executeprogram.com) from  Gary Bernhardt? It's not quite a series of tasks,  but the increments are pretty small. Does it fit this category?


> *[2020-04-28 00:50:36]* **Paul Butler**:

I had not -- but it does look like a good example!


> *[2020-04-28 01:03:18]* **S.M Mukarram Nainar**:

This is not really programming, but there is a book called Probability through Problems by capinski that follows this approachâ€”it's more or less self contained and the bulk of the theory is worked out in the problems


> *[2020-04-28 01:04:29]* **S.M Mukarram Nainar**:

Anyway other examples may be:
[https://cryptopals.com/](https://cryptopals.com/)
[http://mightybyte.github.io/monad-challenges/](http://mightybyte.github.io/monad-challenges/)


> *[2020-04-28 01:35:57]* **Ivan Reese**:

Video game tutorials (the good ones, at least) often do this. For example, the game SpaceChem, which sort of doubles as a programming environment, teaches the game mechanics (which are, basically, the concepts of its programming system) in a very gradual, incremental way.


> *[2020-04-28 03:16:16]* **Charlie Roberts**:

Flexbox Froggy is fantastic in this regardâ€¦ one new CSS concept per level. I always assign playing it when teaching webdev classes. <https://flexboxfroggy.com/>


> *[2020-04-28 03:20:31]* **Charlie Roberts**:

I have a student working on a similar style project for a p5 library she wrote for generating geometric patterns with polar coordinates: <https://liz-peng.github.io/p5.Polar/>


> *[2020-04-28 03:22:36]* **Charlie Roberts**:

actually, sheâ€™s currently collecting (very basic) feedback if anyone is willing to participate: <https://forms.gle/YECi8w8xDk4xaSEK9>


> *[2020-04-28 06:22:41]* **Edward de Jong**:

The gentle ramp is often called the Nintendo Ramp or the "Miyamoto Ramp", which is one of the great secrets of the Nintendo programming philosophy. Nintendo as you all know is the most consistently high quality, successful game company on the planet, and inside those games each level is carefully graduated as to have no serious bumps, so that one progressively gets harder tasks but the slope of the increase is almost imperceptible.  A highly effective method. In the area of paper books, the mathematics series called "Keys to Algebra" from Key Curriculum Press Berkeley (owned by Springer) is a fantastic series. There are other subjects covered in Math as well from that series.


> *[2020-04-28 07:43:31]* **Mariano Guerra**:

the book "the little schemer" comes to mind


> *[2020-04-28 08:07:53]* **Robin Allison**:

Another possible example, although I haven't looked much into it, the "natural number game" for learning the Lean proof assistant: <https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/>


> *[2020-04-28 09:59:57]* **Jack**:

Barbara Ericson's work on dynamic and adaptive parson's problems is relevant here <https://scholar.google.com/citations?hl=en&user=U09MSV8AAAAJ&view_op=list_works&sortby=pubdate>


> *[2020-04-28 10:18:09]* **yoshiki**:

Havenâ€™t done it since I lack the prerequisite math background, but I believe [https://quantum.country/](https://quantum.country/) does this. Worth reading this companion piece too: [https://numinous.productions/ttft/](https://numinous.productions/ttft/)


> *[2020-04-28 10:20:01]* **yoshiki**:

To echo **Ivan Reese**, the video game Braid does this really well too.


> *[2020-04-28 13:55:40]* **U010RH58PL7**:

I collected some of these here <https://csed.substack.com/p/the-best-online-interactive-learning>, including executeprogram and flexbox froggy (â¤ )

Others worth a look:
â€¢ [Cant Unsee](https://cantunsee.space/)Â - Game for building design intuition by choosing the better of two side-by-side designs.
â€¢ [CSS Diner](https://flukeout.github.io/)Â - Learn CSS Selectors interactively, by using them to select food from plates.
â€¢ [Method of Action](https://method.ac/)Â - Five different interactive design games. My favorites areÂ [Type Method](https://type.method.ac/), andÂ [Boolean Method](https://boolean.method.ac/), but maybe theÂ [Bezier game](https://bezier.method.ac/)Â is more important if youâ€™re actually a designer. I am not a designer, so I canâ€™t tell!
â€¢ [Vim Adventures](https://vim-adventures.com/)Â - Build muscle memory and intuition for how to get around in the Vim text editor by moving a character around in a game.
â€¢ [SQLBolt](http://sqlbolt.com/)Â - Learn a significant portion of what might be the most important coding language in a few hours.
â€¢ [RegexOne](https://regexone.com/)Â - From the same creator as SQLBolt, a terrific guided explanation of Regular Expressions, with lots of opportunities for practice.
â€¢ [Git Immersion](http://gitimmersion.com/)Â - Guided tutorial through the fundamentals of Git, on your own machine.


> *[2020-04-28 14:13:05]* **Jared Windover**:

The video game Baba Is You does this well also.


> *[2020-04-28 20:01:51]* **Don Abrams**:

This is a favorite of mine: [http://clojurescriptkoans.com/](http://clojurescriptkoans.com/)


> *[2020-04-28 20:03:17]* **Don Abrams**:

The quintessential is logo though, with a bunch of research behind it


> *[2020-04-30 00:43:43]* **Paul Butler**:

Thanks all for these examples -- some really cool work in this area that I wasn't aware of!


> *[2020-04-30 00:49:57]* **Paul Butler**:

U010RH58PL7 this is a really useful post, do you mind if I share a link to it? (I'm not sure what the etiquette is with substack deep links because I understand it to be unindexed content ðŸ™‚)


> *[2020-04-30 14:05:49]* **U010RH58PL7**:

Please do share it! My substack is free - it's just a nice way to manage an email list, and add payment in later if and when it feels right.


> *[2020-05-01 03:31:12]* **Mark Dewing**:

I'm curious if there's a standard approach to making programming tutorials and some tools to help make them?  It would help to have a guide so each project doesn't have to build it from scratch.  For a format for presenting code in a gradually-building style, I have a small project to explore this. <https://github.com/markdewing/programming_tutorial_maker>

---

*[2020-04-28 17:07:44]* **Ivan Reese**:

One of our lurkers, **Alex Wein**, whipped up this _beautiful_ interactive display based on the community survey. I think you'll enjoy playing with this.

<https://observablehq.com/@a-lexwein/what-future-of-coding-topics-interest-you-most>


> *[2020-04-28 21:27:22]* **Roben Kleene**:

It's interesting to me that Tools for Thought / Mind Bicycles is the most popular, because that's one of the least specific to programming. What does everyone make of that?


> *[2020-04-28 21:31:53]* **Ivan Reese**:

I think a lot of the people here are fond of the Doug Engelbart line of thinking: computers are tools for augmenting human intellect, for which programming is just a means to an end. How we all arrived at that thinking, I don't know. I arrived there via Bret Victor.


> *[2020-04-28 21:32:21]* **Ivan Reese**:




> *[2020-04-28 21:36:14]* **Ivan Reese**:

(small n, I know, but there _might_ be something to this)


> *[2020-04-28 21:55:16]* **Scott Anderson**:

Its also crazy how many lurkers we have, most people that responded to the survey are lurkers!


> *[2020-04-28 21:59:44]* **Ivan Reese**:

I don't think that's the case..


> *[2020-04-28 21:59:59]* **Ivan Reese**:




> *[2020-04-28 22:00:03]* **Ivan Reese**:

(see the pie chart)


> *[2020-04-28 22:00:34]* **Ivan Reese**:

The survey showed that there are more non-lurkers than lurkers... but the Slack stats..


> *[2020-04-28 22:00:46]* **Ivan Reese**:




> *[2020-04-28 22:01:01]* **Ivan Reese**:

Show that, you are correct, we have a lot of lurkers.


> *[2020-04-28 22:01:56]* **Ivan Reese**:

In the podcast, I theorized â€”Â the people who have the time and interest to post are probably also more likely to have the time and interest to fill out a survey.


> *[2020-04-29 04:03:19]* **Emmanuel Oga**:

is there data about current tools and languages people in here are using?


> *[2020-04-29 04:06:17]* **Emmanuel Oga**:

ah I think it wasn't part of the survey


> *[2020-04-29 04:06:22]* **Emmanuel Oga**:

maybe for the next one ðŸ™‚


> *[2020-04-29 04:29:49]* **Ivan Reese**:

That's an interesting thought. Something like, "What programming language(s) are you using to build your FoC project(s)?"


> *[2020-04-29 14:38:22]* **Roben Kleene**:

Love the programming language question. It would also be cool to do a question about tools for thought in general, but I'm struggling to figure out how to ask it in a useful manner. Maybe someone else can figure out a good way. Here's how I would phrase the problem: When you say "Tools for thought", I personally don't even quite know what that means. E.g., if you were to write a (SEO-title ready) blog post, here are the top ten tools for thought, what would be on that list?


> *[2020-04-29 19:16:25]* **Will Crichton**:

hah, love that the intersection of {PL theory, compilers} x {bret victor} seems to be the smallest

---

*[2020-04-29 18:53:49]* **Jared Windover**:

Lately Iâ€™ve been working on and thinking about gui layout. Iâ€™m building a gui builder, and Iâ€™m trying to figure out what the interface should be between parent and child components to allow for maximum flexibility of layouts while still having things mostly just work when they get combined. Iâ€™ve been taking inspiration from the existing gui toolkits (html/css, QT, GTK, WinForms), and from more fanciful gui designs (the iron man interfaces, rainmeter skins). Iâ€™m trying to understand what tradeoffs are being made in these systems in a holistic way. Like, what layouts are expressible. I would like to generalize away from are the heavy focus on rectilinearity. Things Iâ€™ve been imagining are force-based layout algorithms, and some sort of path-based deformation/matching between child and parent, but theyâ€™re just thoughts for now. Has anybody come across any literature on these sorts of topics? The only thing Iâ€™ve come across is constraint-solvers.


> *[2020-04-29 18:58:31]* **Ivan Reese**:

Here's a question that has usefully guided my thinking on the subject: Have you ever seen a force-directed GUI layout that looked good?

I haven't, so what I've pivoted toward is "make the tools really good, so it's easy to design a nice layout" rather than "make the layout happen automagically".

Not sure if you'd find this framing helpful, but it might help you narrow what sort of research is relevant. To me, a force-directed layout is appropriate for something like data-viz, where you can be a little loosey-goosey about where things end up. In a GUI, you generally care a lot more about getting a result that _feels good_ in a way that's hard to encode algorithmically.


> *[2020-04-29 19:11:24]* **Ivan Reese**:

As for literature... <https://www.youtube.com/watch?v=KfxE99eN44c> and <https://www.youtube.com/watch?v=0msyWHrw40A> were posted here (IIRC) a few months ago. Kevin Lynagh was also doing a lot of research in this area for <https://subformapp.com>, so he might be worth reaching out to. (He was also on the podcast: <https://futureofcoding.org/episodes/025>)


> *[2020-04-29 19:17:50]* **Jared Windover**:

Nice links! Will definitely take a look at those. I guess the thing thatâ€™s leading my thinking in a more automatic direction is Iâ€™m picturing an ecosystem and sort of appstore of components. I want somebody to be able to develop a parent component without knowing what type of components itâ€™s going to contain, and somebody else to develop a child component without knowing what type of container it will be put inside (or what siblings it will have), and for that to _just work_. Or I want to figure out why thatâ€™s wrong.


> *[2020-04-29 19:35:56]* **Ivan Reese**:

Follow-up question â€” when you say "path-based deformation/matching", what do you mean by path? Like, the conceptual path to the element in the hierarchy (like CSS selectors) or some sort of visual path in the layout (like aligning things to splines)?


> *[2020-04-29 20:01:12]* **Jared Windover**:

Along the non-rectilinear idea, a parent telling the child, I can give you this shape to display yourself in (maybe a rectangle, maybe something else), and the child either rendering according to that, or saying, Iâ€™d really like to be this shape, and some sort of middle ground being achieved. Path in the visual path/SVG sense.


> *[2020-04-30 02:29:20]* **Emmanuel Oga**:

can you do away with the notion of parent-child? perhaps you could think in terms of clustering things, scrolling, zooming, connecting, etc. All components could live at the same level instead of being nested in one another


> *[2020-04-30 02:30:16]* **Emmanuel Oga**:

since you are thinking ironman your screen would be potentially infinite... you would have to find a way to focus the desired cluster inside the viewport


> *[2020-04-30 03:09:22]* **William Taysom**:

The trick with constraint layout systems is that they're often too complicated to reason about reliably.  You don't know who is in charge: the container or the content.  Simultaneously, they are often too rigid.  You discover you want two things to lineup cross-hierarchy, and your kind of out of luck.  What to do then?  Give feedback.  Explain why a thing ends up the way it does.  Then make it easy to give examples of what you want, which may be realized in more than one way.

Browsers have been getting better with explaining CSS, but not without eliminating rage inducing headaches.  For instance, it might be hard to select a border in order to determine where it is coming from.


> *[2020-04-30 08:37:45]* **Edward de Jong**:

The Iron Man interfaces are wonderfully entertaining pieces of graphic art. There are just a few people in hollywood who know how to make those things. They are mixture of 3D and 2D animations, always using glowing lines and very few colors so it looks terrific. But as a user interface it would be horrible because all the buttons look alike, and the font sizes are microscopic. So although they are sexy from a distance, if you had one in front of you, it would be confusing, hard to use. A lot of music software is enraptured with sub-6pt fonts, and microscopic icons. So i would be wary of chasing Hollywood's ideas.  Remember Star Trek next generation, with their buttonless screens that would be sure to create carpal tunnel syndrome in record time? A lot of the futuristic stuff is unergonomic, and possibly harmful to the human body, and presumes a magical artificial intelligence that just graduated from CalArts and spent 1000 hours making a screen that appears in the movie for 2 minutes. A 100 million motion picture is a time compression device, where 50,000 man hours go into making something that lasts 2, so a 25,000 : 1 ratio there. By all means see what you can come up with, but don't hold yourself to unattainable graphic standards that are the work of genius graphic designers who are at the top of a very specialized field (i.e. fake UI's for futuristic films). Hollywood has a long history of faking the future; Irwin Allen was a famous TV producer who loved banks of flashing lights and nutty rubber monsters. I think you are better off studying from the great masters of the Renaissance, who used proportions to draw everything, and also the great book "Designing for people" by Henry Dreyfuss, the greatest industrial designer in the history of the world. Everyone who does any design work should know that man's output because he was so great. He didn't do computer interfaces, but he had a systematic way of attacking every problem that resulted in an optimal final design. It is his methodology that is still useful today.


> *[2020-04-30 09:30:50]* **Stefan Lesser**:

I come to realize again and again that great design comes from building something over and over again, exploring different options and putting in what you learned from the last time you built it. Great designers build lots of prototypes to figure out what works and what doesnâ€™t. 

In software engineering we often see design more as planning, as that one time we think a little about architecture and then we just have to implement it. Sometimes that works and it good enough. But if you really want to build something great, youâ€™ll likely have to build it several times.


> *[2020-04-30 09:42:13]* **Stefan Lesser**:

Tying this back to the original question: Iâ€™m most familiar with Appleâ€™s explorations of layout systems over the last few decades. They went from a very simple to understand and just powerful enough â€œStruts and Springsâ€ model in Cocoa to a somewhat more refined version of that as part of Core Animation, then a constraint solver based â€œAuto Layoutâ€ model plus some layout-specific components like UITableView and UICollectionView, and are now exploring some new ideas with SwiftUI.

Given the way Apple _designs_ their APIs, and their experience having built several widely used layout systems over the years, there should be some good material to be inspired by.


> *[2020-04-30 11:58:40]* **U0119RRB1MK**:

I have an open source library for plotting widgets on the screen according to inequalities
<https://github.com/samsquire/inequality-solver>


> *[2020-04-30 14:54:35]* **Jared Windover**:

> can you do away with the notion of parent-child?
This is the kind of outside-the-box thinking I was looking for (pun-intended). Iâ€™m not sure. I think containers are inherent, but maybe a model where a container is just a set of constraints over some children with no graphical presence itself would be possible. This deserves more thought.
> You donâ€™t know who is in charge: the container or the content.
This is very much the issue Iâ€™m running into. I keep thinking of these fairly naive systems where its either parent-driven or child-driven, or possibly there is a point in the tree where it switches, but I donâ€™t know how to rectify them into something consistent and intuitive. I guess thatâ€™s why constraint-layout is a thing.
**Edward de Jong** Great points. I think thereâ€™s an element of me being suckered into thinking these interfaces would be more useful than they really would be (and I will definitely be reading Designing For People). Part of my goal, though, is to just avoid baking in too many assumptions about what makes for a useful/ergonomic/good UI. Which is perhaps itself naive.
> great design comes from building something over and over again
Absolutely. Part of my goal with this system is for things to get forked and redesigned and reshared by end users over and over again. I think even a great designer canâ€™t anticipate an individualâ€™s idiosyncracies as well as the individual can tweak and reshape something to fit their own brain.


> *[2020-04-30 23:39:45]* **Jamie Brandon**:

The Flutter layout model is very simple and expressive - <https://youtu.be/UUfXWzp0-DU?t=201>. The proposed model for extensible layouts on the web uses almost exactly the same api.

Many immediate-mode gui libraries don't have a concept of parent-child relations. Instead widget functions take a rect that tells them where to draw themselves, and there are a bunch of convenience functions for splitting rects in different ways. Eg page 31 of <https://ourmachinery.com/docs/writing-tools-faster/index.html>


> *[2020-05-01 01:34:18]* **Emmanuel Oga**:

Tangent: slide 31:
```No need for "layout managers" -- instead we split rects directly in code```
I understand the sentiment but dismissing automatic layout seems wrong. In a database analogy, would be like doing away with SQL and performing all queries programmatically with lower level API calls and for loops. Makes me think there must be a different way to layout graphics that is to CSS as Datalog is to SQL ðŸ™‚


> *[2020-05-01 04:36:28]* **William Taysom**:

Speaking of movie UIs... <https://www.youtube.com/watch?v=4-yFRjqn9Tc>


> *[2020-05-01 06:49:54]* **Jamie Brandon**:

**Emmanuel Oga** I think of it more as not having *one* layout manager. The widget functions just want a rect. You can write the rect out by hand, or write some simple layout calculation, or import a layout manager library if you want, or use multiple different layout algorithms in different places. But the widget libraries don't care.


> *[2020-05-01 20:03:34]* **Jared Windover**:

I spent some time looking into flutter. They have this RenderObject base class that is almost exclusively used through a RenderBox subclass, but in their examples they also have a RenderSector subclass, which does polar coordinate widgets. This was my strawman non-rectilinear example that I was thinking about. So I think their RenderObject interface is probably more or less what I was looking for in terms of layout generality.


> *[2020-05-01 20:05:43]* **Jared Windover**:

For anybody who's curious and doesn't want to install the flutter sdk, this is what their sector layout looks like


> *[2020-05-01 20:10:37]* **Jared Windover**:

**Jamie Brandon** do you have a link to the extensible web layouts proposal? I havenâ€™t been able to find it.


> *[2020-05-01 20:32:01]* **Edward de Jong**:

Flutter to my understanding is a unique beast among graphical layers. It renders the entire UI into bitmap form, and sends the bitmaps to the underlying OS. So It is effectively its own virtual machine that interfaces with the world by emitting bitmaps. Only an entity with Google's money would attempt such a huge task. My own Beads project maps my language concepts into the lower layers, which for web apps is JS.  Flutter is its own universe, and of course is rather tied to the Dart language.


> *[2020-05-01 23:19:37]* **Jamie Brandon**:

**Jared Windover** Nope, I can't find it either. I remember it was part of a collection of proposed extensions aiming to un-hardcode some of the lower levels of the web.

---

*[2020-04-30 16:02:21]* **Roben Kleene**:

Recently there's been some discussion about how people mainly use spreadsheets for making lists (e.g., according to **Chris Granger** and **Jonathan Edwards**, most users have never even made a formula). If that's true, than what is the state of the art for end-user programming? Does the 1% of users that have created a formula still trump everything else? Or does that mean there's another model that we should consider more successful? And even if the spreadsheet is still the most successful model, what's the second most successful? Because the gap between the first and the second is in reality much smaller than many of us assumed.


> *[2020-04-30 16:08:20]* **Chris Granger**:

I couldn't get a committed number and 1% sounds low to me. But even if we assume that's correct, that's still on the order of 8 million people, or ~50% the size of professional developers!


> *[2020-04-30 16:08:49]* **Ivan Reese**:

Depending on how fuzzy you want to make your definition of "programming", I'd like to propose one possibility for _most widely-used_, with a degree of dynamism in between making a list and making a formula: turning some text into a hyperlink.

Which would make the WWW the most successful, which kinda feels right.


> *[2020-04-30 16:10:41]* **Chris Granger**:

For the question to be useful, I think you need an explicit definition of programming, like Ivan said.


> *[2020-04-30 16:12:12]* **Chris Granger**:

E.g. if we're willing to remove computers from programming, then the most successful version is "management" in all its forms, where processes are broken down and procedures are given to individual agents (whether that's in a factory, or at home with the kids + dishes)


> *[2020-04-30 16:13:36]* **Chris Granger**:

everyone in the world programs to some degree effectively every day, they just may not do so with a computer


> *[2020-04-30 16:18:34]* **Mariano Guerra**:

I think there may be 3 levels of the most basic kind of programming:
â€¢ automating some repetitive calculation with a formula
â€¢ adding conditionals
â€¢ some sort of iteration (in excel this one is so easy that it may come before conditionals)


> *[2020-04-30 16:19:11]* **Mariano Guerra**:

I consider an "advanced excel user" to users who use excel functions and maybe conditionals.


> *[2020-04-30 16:20:30]* **Mariano Guerra**:

in some paper someone mentioned that they went through all the emails of some big corporation (I think it was enron) because they were made public in a trial and they searched for attached excel spreadhseets and ran some analysis on those. That may be an "easy" way to get some tangible numbers


> *[2020-04-30 16:25:31]* **Roben Kleene**:

Just adding where I got the 1% number, I wasn't sure if this was supposed to be interpreted literally <https://futureofcoding.slack.com/archives/CLYCGTCPL/p1573916033110200?thread_ts=1573703587.087300&cid=CLYCGTCPL>


> *[2020-04-30 16:33:00]* **Jonathan Edwards**:

Personal communication from someone at MIcrosoft Research 


> *[2020-04-30 16:37:20]* **Jonathan Edwards**:

Donâ€™t sneer at making lists. Look at all the code it takes to build TodoMVC.


> *[2020-04-30 16:54:55]* **U010SQSJGLS**:

The Enron spreadsheet corpus is useful fodder for analysis. But the difficulty is that spreadsheets are used by lots of different people for lots of different things.


> *[2020-04-30 16:55:31]* **U010SQSJGLS**:

So yes, some are used for making lists, but the beauty of the spreadsheet is the gradual transition from data storage to data organization to computation.


> *[2020-04-30 16:57:54]* **Roben Kleene**:

Heh, I definite wasn't looking down on lists, I love lists.

Here's another relevant personal anecdote: For the first half of my career I was a UI designer, I then I switched to iOS development, and I started easily making far more money than I ever made as a designer. One of the things that baffles me about this, is that I find the job of a programmer in many ways easier than being a designer. For one, your definition of success is more straightforward (does your program work?), but I also just find searching for solutions to problems to just be easier for programming. E.g., I'd take searching for a solution to a programming problem on Stackoverflow over trying to figure out how to do something in Adobe Illustrator any day of the week. In other words, I also generally find the technical minutiae of being a programmer easier than being a designer. So it's confusing to me that programmer's are paid so much more.


> *[2020-04-30 16:58:30]* **Roben Kleene**:

That might only seem tangentially related, but the point is that using application like Excel really well seems to me just as complicated as programming.


> *[2020-04-30 17:30:16]* **Kartik Agaram**:

> Donâ€™t sneer at making lists. Look at all the code it takes to build TodoMVC.
**Jonathan Edwards** Doesn't that conflate building software with using software? The term "make a list" could be rewritten "use list-making software"?


> *[2020-04-30 17:49:58]* **Kartik Agaram**:

**Chris Granger**

> everyone in the world programs to some degree effectively every day, they just may not do so with a computer
Oh yes. From the notes I shared here last year from Bonnie Nardi's _"A small matter of programming"_: People engage with formal systems all the time. Baseball scorecards. Knitting patterns. Following the rules of a game or sport. The book describes several others.

<http://akkartik.name/post/nardi>


> *[2020-04-30 17:52:23]* **Chris Granger**:

Yeah, it's a great book ðŸ™‚


> *[2020-04-30 18:04:27]* **Steve Dekorte**:

Could part of the barrier to progress in this area be due to the perspective that the problem to be solved is one of â€œprogrammingâ€? Even calling this group â€œFuture of Codingâ€ sort of implies that â€œno codeâ€ isnâ€™t part of the future.

For example, I donâ€™t think the spreadsheet was invented with the intent of it being programming tool, though it has arguably become the most popular programming tool. Iâ€™d guess it was invented to help people do a class of things they would otherwise have to hire programmers to do.


> *[2020-04-30 19:08:08]* **Ivan Reese**:

I think it's no secret that a lot of folks here aren't making programming tools in the traditional sense. Eg: I'm making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: "oh, code!"


> *[2020-04-30 19:11:30]* **Alex Wein**:

>  If that's true, than what is the state of the art for end-user programming?
I think a lot of people use spreadsheets, but I have no sense of the relative proportions.  For data work, "end" users are also working with text-based coding (often in notebooks) and some well made GUI tools. I haven't used all the products below, but all of them have happy users:
â€¢ For wrangling rectangles of data: Pandas in Python, dplyr in R (my personal favorite)  and SQL, and GUI tools like Alteryx and Trifacta.
â€¢ For data visualization: Javascript/R/Python all have increasingly powerful and easy-ish to use options for viz, there are chart chooser tools like DataWrapper and Flourish, and GUI tools with sophisticated grammars of graphics like Tableau.



> *[2020-04-30 19:32:13]* **Jared Windover**:

Wrt most users never writing a formula, I think thereâ€™s a couple of different interpretations worth sussing out.
â€¢ Most users never write a formula and spend time laboriously copying out data and doing calculations
â€¢ Most users never write a formula and pay other users to develop custom â€œprogrammedâ€ sheets that they then enter data into
â€¢ Most users never write a formula and are still fantastically productive with spreadsheets.
Thereâ€™s some overlap here, but the fact that a system has a powerful component that doesnâ€™t get used isnâ€™t necessarily a failure of that system, even in a context where we think providing that power is good. What I think would constitute a serious criticism of spreadsheet software is users occasionally try to write a formula, but get confused and frustrated and give up.


> *[2020-04-30 20:46:37]* **Ivan Reese**:

Let's get into the weeds â€” I personally know a handful of folks who have learned that you can type `=` and then band-select a number of cells to produce a sum. That's all they know. I suspect that puts them on the edge between the 1% and the 99%, though which side of that edge and how wide the edge is, who's to say.


> *[2020-04-30 21:07:20]* **Kartik Agaram**:

**Ivan Reese**

> Sneaking code in through the back door
One example I've periodically noodled on is a more powerful email filter. By the time you provide the capability to inspect attachments and perform n-gram analysis you start naturally needing to treat existing emails as a test corpus.


> *[2020-05-01 04:31:45]* **William Taysom**:

Part of the challenge is just what's ready-to-hand.  I recall sitting next to an analyst who, while working on an Excel sheet, would also use the four function calculator on his desk.  Why?  Well, the calculator works even when he isn't in Excel or on the computer, and since the sheet was already configured to show something else, there wasn't a good scratch spot to put the needed formula.


> *[2020-05-01 07:53:38]* **Dan Swirsky**:

Not sure how much of Nardi's book covers this paper ([Spreadsheets and end-user programming: Nardi, et al.](https://www.miramontes.com/writing/spreadsheet-eup/)), but I found it to be a great look at spreadsheets and programming


> *[2020-05-02 02:32:21]* **Steve Dekorte**:

**Ivan Reese** â€œI think itâ€™s no secret that a lot of folks here arenâ€™t making programming tools in the traditional sense. Eg: Iâ€™m making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: â€œoh, code!â€œâ€

Right, and that might be appropriate for your problem, but Iâ€™m suggesting that evaluation/code may not be needed for many/most of the tools which would allow people to do the things they are currently hiring programmers to do.

That is, the range of the things people typically want to make may be small enough for them to build from a well abstracted set of primitives in a no code way.


> *[2020-05-02 07:36:45]* **William Taysom**:

**Steve Dekorte** I love it, "oh, code!"  That's perfect.  Definitely modeling tools give me a feel of "fuck it: take the cartesian closure of this and call it a day."  (The reference here is to category theory where a Cartesian Closed Category is, basically, one with structures, unions, and functions.)  For example, you add a little bit of parametric modeling.  You think it would be nice to nest these so that parameters to a big model can be passed into its parts.  Then the next thing you know, you want to be able pass models as parameters.  Why not?


> *[2020-05-02 18:40:35]* **Ivan Reese**:

**William Taysom** :)

**Steve Dekorte** We're making the same point, I think. Excel is an "Oh, code" tool. So is Factorio. So is Zapier. These are things that don't look like "programming", but it turns out you use them to build dynamic, logical systems. You're doing programming, there's still evaluation, but it's an experience that's been designed for _you_, not for _programmers_ (eww).

My beef with "no code" (well, one of my beefs) is that many of these tools are just... frustratingly superficial non-textual programming environments. Given that the distinction between "coding" and "programming" colloquially is basically nil, it feels like "non-fat" all over again â€”Â sure, you've removed the text-code, but you've substituted it with something much worse! What you really want is ~good fat~ a full & rich programming environment, but created for non-programmers.

Aside: The name of this community is a poor fit, and that's probably just going to have to be a meme that we relish in.

---

*[2020-04-30 23:31:53]* **Jamie Brandon**:

"On the usability of editable software"
<https://flak.tedunangst.com/post/on-the-usability-of-editable-software>
<https://lobste.rs/s/qkpwpa/on_usability_editable_software>

Lots of room for thinking about how language design affects the ability to customize software without the anticipation of the original developer. Eg emacs lisp allows redefining functions without having to fork the original library. Eg languages with private/public settings that are enforced by the compiler completely prevent that kind of reuse/rediting, forcing the user to fork which is a pretty heavy-weight operation.


> *[2020-05-01 00:06:40]* **Kartik Agaram**:

I don't follow why public/private prevent 'rediting' (nice coinage there). Isn't it just a simple edit to change 'private' to 'public'?

Redefining functions that weren't really designed to be extended is just as much a reason to fork as anything else, because you often want to reuse some part of the body of the function. It becomes a game of Russian Roulette if you start updating the library without updating your copy of the redefined function. So the leap from editing copies of things to editing things in place isn't that big, I think.

The key here is to make forking a lightweight operation. And version control systems have already done a lot of heavy lifting for us by refining the erstwhile-heavyweight operation of branching into something light and inexpensive. I suspect making forking lightweight is mostly just a switch in mindset. There are no chains here except those we place on ourselves.


> *[2020-05-01 00:53:45]* **Jamie Brandon**:

>  rediting
Been a long day ðŸ˜„
> don't follow why public/private prevent 'rediting'
The distinction I was getting at is editing something "from the outside" vs having to fork. Eg if there is a function in a libary whose behavior I want to change in...
â€¢ ...Julia, then I define a new method of that function in my code
â€¢ ...Rust, then I search for the repo, checkout the correct version as a git submodule, change the Cargo entry to point at my local repo, edit the code in the repo, then rebase my changes when I want to upgrade the library
The end result is that same - I've changed some logic and I have to maintain that diff. But in the latter case there is a *lot* more busywork involved.

Making forking more lightweight would definitely help, but I think there is an additional point of friction in maintaining the diff as text vs maintaining the diff as a language mechanism. Eg if the code gets moved around a bunch in the file then rebasing the diff is painful, whereas nothing has to change with the override. Also version control and package managers don't play together very well at the moment. If the original version of the package gets updated the rust package manager won't even warn me about it, let alone help me rebase my changes.

I think we're agreeing in principle - we both want forking to be a lightweight mechanism. You could come at this from either end - a version control system that understands the language and helps you manage forks, or a language with built-in mechanisms for composing code with changes.

This kinda sounds like <http://akkartik.name/post/wart-layers> - did you continue working on that idea?


> *[2020-05-01 00:55:05]* **Jamie Brandon**:

I guess <https://www.unisonweb.org/> has gone pretty far done this road - providing builtin tools for editing a function and updating all of it's callsites to point to the new version.


> *[2020-05-01 01:16:05]* **Kartik Agaram**:

I still use layers in my projects. But the idea with layers is to emphasize convenience and rely on the programmer to preserve composability-related properties. In other words, you can easily make changes to a function that create arbitrarily-difficult-to-debug holes for yourself. I rely on the people using layers to use them tastefully.

I think this is an irreducible trade-off. If you want extending functions to always be nice and safe, you'll be restricted in the number of places the safe mechanism is available to you.

In my current project I instead focus on catching any possible breakage in the project using some combination of tests, types and correct-by-construction design. This is the _top_ priority, and I give up as much as possible while preserving it. Now others can modify functions all they want, safe in the knowledge that _something_ will complain if they break something when forking a function.


> *[2020-05-01 01:32:40]* **Kartik Agaram**:

I absolutely agree with this:

> I search for the repo, checkout the correct version as a git submodule, change the Cargo entry to point at my local repo, edit the code in the repo, then rebase my changes when I want to upgrade the library... there is a *lot* more busywork involved.
To me this is the lethal problem with packages: by making them easy to consume we make them harder to modify. And that seems like a hard, black-or-white, us-vs-them trade-off. And if that's right, if there's no place for compromise here, I prefer keeping it easy to modify. Even if that is a harder sell, even if it means most people will gravitate towards the competition.

Same goes for binary distributions of anything. Always keep source along for the ride, have the binary rebuild automatically if the source ever changes. Anything else makes the world a worse place, IMO. (I've been feeling a lot more strongly about this in the past couple of months.)


> *[2020-05-01 04:08:26]* **Kartik Agaram**:

I â¤ every single one of your comments on that [Lobste.rs](http://Lobste.rs) thread, **Jamie Brandon**. We are of absolutely one mind here.

I responded to a few comments there, but I have nothing to add to yours.


> *[2020-05-01 05:00:03]* **Chris Granger**:

**Jamie Brandon** the system Josh and I are working on revolves entirely around a remixing model ðŸ™‚


> *[2020-05-01 05:04:56]* **Chris Granger**:

Not sure if you remember, but this was one of the footnotes in my essay on modeling: <https://www.chris-granger.com/2015/01/26/coding-is-not-the-new-literacy/#fn4>


> *[2020-05-01 05:29:54]* **S.M Mukarram Nainar**:

**Kartik Agaram**
> I feel very cynical/fatalistic about Emacs/Lisp/Smalltalk lately. Yes, the core design choices exhibit a high trust for users. But then it seems to be inevitable that the layers on top start chipping away at this trust. Vim's package managers introduce hurdles for anyone who wants to modify sources. (See my recent war story.) How does the Emacs eco-system compare? Is it really common for people to modify packages? Racket's raco feels the same, additional complexity between me and the libraries they want me to â€˜use'.
> 
(Responding here since I don't have a lobsters account)
When I first started using emacs I had the same thought, since it's really hard to override a package with the default package manager `package.el`, but there is actually a quite sane package manager that makes modifying packages trivial, `straight.el`, it's based on the nix/guix model, but it's even simplerâ€”to edit a package, you just edit the files in the git checkout it creates, that's it. maintaining your own branch is as simple as... making a git branch, and so on. Recently I had a problem when I upgraded my packages, and to switch to an older version, I just checked an older version of the package from git, and the package manager handled rebuilding and everything automatically. It felt very nice.
In a way, it's like the package manager uses git metadata as its database, so you don't need extra cruft on top.


> *[2020-05-01 05:33:43]* **Kartik Agaram**:

<https://github.com/raxod502/straight.el>

Wow, look at that Readme! Thanks for showing me this.


> *[2020-05-01 06:51:21]* **Jamie Brandon**:

**Chris Granger** Are you guys still at rai?


> *[2020-05-01 06:55:12]* **Jamie Brandon**:

Wow, straight.el does address a lot of the things we were complaining about.


> *[2020-05-01 12:13:25]* **Konrad Hinsen**:

**Kartik Agaram** Easy to consume and easy to modify lead to almost opposite criteria for software architecture. I see that as the essence of Knuthâ€™s reusable vs. re-editable.


> *[2020-05-01 15:01:38]* **Chris Granger**:

**Jamie Brandon** nope! We stepped away at the beginning of the month. Going to try our own thing for a bit and take it from there. ðŸ™‚


> *[2020-05-01 15:19:16]* **Roben Kleene**:

This is another great comment from the [Lobste.rs](http://Lobste.rs) thread <https://lobste.rs/s/qkpwpa/on_usability_editable_software#c_qxnh4i>

> User modifications in computer games are a lot more common than other software types and are even possible in some big budget proprietary software. I think this can offer some insight into how this can work for other software.
> The most basic version is to move all content/assets (3d models, textures, sound files, etc.) into its own subfolder tree and give it clear human readable names. Users can then simply swap out files.
> The next level is to abstract how the metadata for high level objects that use these assets is stored out to a text based format like json or xml so that the assets can be reused and new high level objects defined.
> This can be extended to more and more engine content, including defining behaviours and simple functions in json/xml


> *[2020-05-01 15:28:29]* **Roben Kleene**:

After text editors and terminals (which have the unfair advantage of explicitly targeting programmers, who are the best position to do the editing),
computer games might be the most widely-edited software there is?

I did an analysis of the most popular creative apps across industries, and one of the patterns is extensibility  (<https://blog.robenkleene.com/2019/08/07/apples-app-stores-have-failed-creative-apps/>). Now that I look for it I start seeing it everywhere, for example as far as I can tell, this chain is possible: Open an After Effects project, add a Cinema 4D 3D model to it via a plugin, then open a Houdini project in Cinema 4D via a another plugin, then render it all via a third-party renderer like Redshift. Now I'm not sure if all of that would actually work, but it's fascinating how flexible the workflows for professional creative apps are, especially compared to consumer software. Like compare that to just trying to get something like Apple Notes to talk to Excel...

---

*[2019-09-30 18:09:30]* **Unknown User**:

MSG NOT FOUND


> *[2020-05-01 01:06:34]* **Jamie Brandon**:

<https://scattered-thoughts.net/writing/imp-solving-functions/>

---

*[2020-05-01 04:29:36]* **yoshiki**:

Anyone know of programs for visualizing and understanding assembly and/or CPUs? Thinking kind of what Bret Victor does with Learnable Programming and Inventing On Principle but applied to lower level code. I am guessing thereâ€™s industrial software in this general category but am especially interested in programs with a pedagogical angle.


> *[2020-05-01 04:38:46]* **Kartik Agaram**:

Are you thinking real-world processors? There's a long tradition from SPIM to TIS-100 of designing simple make-believe processors for pedagogical purposes, but I'm sure you know all that..


> *[2020-05-01 04:52:07]* **Edward de Jong**:

I haven't seen an assembly language simulator in a long time but i know they exist somewhere. There are simpler processors than the Intel architecture (which is a pretty messy thing), like Z80, etc. The Motorola 68000 was a very regular instruction set, and there is probably some wonderful old stuff out there. Highly instructive to learn assembly language, well worth doing.


> *[2020-05-01 05:16:05]* **Nick Smith**:

There's a HUGE difference between assembly languages and CPU hardware. They're only weakly linked: one encodes computations and the other executes computations. Intel and AMD CPUs haven't executed x86 directly for decades; they compile it into microcode on-the-fly. And CPUs do insanely complex things with scheduling, memories and caches.

I would LOVE a good, modern (abstract) CPU emulator that could execute a Wasm program and show me what was happening with scheduling and caches. People have tried this kind of stuff before but I don't know of any nice tools. I've been thinking I will have to make my own (simplistic) simulator at some point if I'm ever going to make a "great" compiler. Otherwise I'll just be applying/benchmarking heuristics "black box"-style and hoping they work well.


> *[2020-05-01 05:22:41]* **Scott Anderson**:

Maybe a disassembler like binary ninja or Ida pro?


> *[2020-05-01 05:22:45]* **Scott Anderson**:

[https://binary.ninja/](https://binary.ninja/)


> *[2020-05-01 05:50:57]* **Vitorio Miliano**:

<http://visual6502.org/> has live JS simulations of a few chips


> *[2020-05-01 05:51:59]* **Vitorio Miliano**:

<https://floooh.github.io/visual6502remix/> is an alternative version


> *[2020-05-01 07:58:45]* **Mariano Guerra**:

<https://twitter.com/diodesign/status/1248975584647995394>


> *[2020-05-01 08:13:12]* **Edward de Jong**:

wow those chip simulations are incredibly detailed. I would think for most people just learning about opcodes, registers, and the difference in speed between register-register operations vs. register memory would be highly instructive. Given that a memory access can take 100 clocks, we are now in an era where it is crucial to use as many registers as possible.


> *[2020-05-01 08:23:57]* **Emmanuel Oga**:

<https://www.nand2tetris.org/software> is a bit rudimentary but the book is amazing. Would be great if there was a web version of Nand2Tetris


> *[2020-05-01 08:29:13]* **yoshiki**:

**Kartik Agaram** would love to hear more! I'm not super familiar with processors!
**Nick Smith** sure. I should clarify that I'm interested in visualizations that elucidates that bridge between machine code and transistors.
**Scott Anderson** Thanks for the link, that is really cool! I've seen those box-and-arrow visualizations of jumping before, is that a pretty common feature in disassemblers?


> *[2020-05-01 08:32:22]* **yoshiki**:

**Vitorio Miliano** that 6502 visualizer is so cool. But I wonder if the physical circuit diagram alone is really that useful for _building_ an understanding from scratch. I wonder if we could provide different levels of perspective and views over it, sort of a logical analogue to what Bret does for circuit diagrams in Media For Thinking The Unthinkable:


> *[2020-05-01 08:34:59]* **yoshiki**:

**Emmanuel Oga** I love nand2tetris. Did the hardware + VM half of it myself(the compiler part wasn't quite as well-done imo). But the software they provide could be so much more. Would love to see an integrated curriculum where the software seamlessly blends with the learning material.


> *[2020-05-01 09:37:26]* **Stefan Lesser**:

Not sure if thatâ€™s what youâ€™re looking for, but there is this: [http://www.visual6502.org/](http://www.visual6502.org/)

Fun fact: it seems still impossible to simulate a 1 Mhz 6502 like this in real-time on contemporary hardware; see [https://github.com/mist64/perfect6502/blob/master/README.md](https://github.com/mist64/perfect6502/blob/master/README.md)


> *[2020-05-01 09:37:44]* **Stefan Lesser**:

For learning 6502 assembly I quite enjoyed this one: [https://skilldrick.github.io/easy6502/](https://skilldrick.github.io/easy6502/)


> *[2020-05-01 10:05:39]* **Nuno Leiria**:

I've had ideas about creating something for the purpose of teaching low level concepts all the way up to how they connect to the higher level (languages and programs we use every day).

It would have many layers, each layers one concept, and it would show just one concept at a time, but in a zoomable map. It would start by showing the highest level layer - a game running.
Then it would zoom in super fast until it reaches the lowest layer - how registers and caches work. Now the user has to go through every layer until they reach the highest layer again.
All layers are explained visually.

From how the CPU executes instructions, to how it fetches them from registers, to caches, to how the MESI protocol works to keep caches coherent, to how data is fetched from RAM when it isn't in the cache and how slow this is, to how  data needs to be fetched from disk, how the CPU feeds data to the GPU, to how all of these systems intertwine together through buses. From this level we should have a pretty good architectural view of how all the systems work together at a low level.

From here we zoom out into a higher level to driver land and then to OS land and to how a runtime works to load a PE/ELF into memory. Then we go on to show what is inside an executable and how the data got there - from assembler to compiling and linking to tokenizing and parsing to actual code.
At this point there should be a good view of how code actually gets executed.

Then we zoom out again to show how code is structured into platform independent layers to abstract networking protocols, file systems, multi-threading, etc. Then how this is used to build core systems for memory allocation, maths, debugging and profiling, etc. Then on to resource systems for textures, materials, 3D models, etc, to the low level renderer where the rendering commands are being dispatched, how data is fetched from the different resources to achieve this. On to the above layers of scene graph management, animation, post processing, HUD, and finally gameplay.

This gets us all the way back to the highest layer where the game is running. From this point forward the user is free to go to any layer and play around with some parameters to see how the layers above and below are affected.


> *[2020-05-01 14:16:34]* **Brit Butler**:

The closest thing I can think of today in this vein is <https://8bitworkshop.com/> but that is coming at it more from the game programming / content creation side of things. I think the platform _might_ support the observability you are looking for though.

I have written a few NES emulators myself (one in CL, one in Reason) with a goal of tracing the running application and visualizing it in a useful way â€¦ but they are nowhere near finished ðŸ™ƒ

Still, I think the notion of using runtime tracing to build-up a CFG for a game or ROM and allowing the user to inspect the graph/code rather than just sprites or nametables as most emulators do is promising.


> *[2020-05-01 18:10:46]* **Chris Knott**:

Came across this the other day which is quite neat <http://thlorenz.com/visulator/>


> *[2020-05-01 18:11:39]* **Chris Knott**:

> Would be great if there was a web version of Nand2Tetris
Absolutely. It's been on my fantasy todo list since I took that course


> *[2020-05-02 10:23:14]* **yoshiki**:

**Nuno Leiria** I love this vision. It's something I've wanted for a while too: a comprehensive description of a whole stack, simulated in media, approachable from very basic knowledge with a smooth path to global understanding.

---

*[2020-05-01 13:58:25]* **Doug Moen**:

Tangible Functional Programming by Conal Elliott
â€¢ apps are user-friendly (usable, concrete, visual) but limit functionality, aren't composable
â€¢ software libraries are programmer-friendly (composable, abstract, syntactic)
The dream is: unlimited access to functionality, usably and composably. How?
â€¢ Unix pipes are a composable text-mode UI, but we lose the GUI.
â€¢ A Tangible Value is a typed value (model) paired with a GUI (view, controller). GUIs are composable whenever their underlying values are composable: eg unix-like pipelines, function composition.
<http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability>


> *[2020-05-01 15:00:51]* **Doug Moen**:

Note: Conal is not providing a ready to use GUI framework like Flutter or Morphic. He is giving design principles for composable GUIs. An algebra of GUIs. There is hard work remaining to design a general purpose GUI framework based on these principles. Or consider the GUI primitives in your system, and think about whether they could be redesigned for composability.


> *[2020-05-01 16:40:54]* **Doug Moen**:

There's been lots of research on GUI layout mechanisms (you might call this spatial composability), and on ways to mitigate callback hell in the original imperative GUI frameworks. But Conor is asking us to think about a new topic: semantic composability. When you compose two "meanings" (denotations, values), a new GUI is generated for viewing/editing/invoking this composite meaning.

I didn't have the proper vocabulary for even thinking about this issue before.


> *[2020-05-01 21:20:31]* **Brian Hempel**:

**Edward de Jong** Iâ€™d recommend a second look at Conalâ€™s work. Tangible Functional Values is not about GUI-building. Itâ€™s about value/product/output creation. The aim is to make the programming experience tangible and more approachable for non-linear thinkers. The non-composability of Unix pipes is one of the motives for the workâ€”instead of the (untyped) single-output-single-input of pipes, Tangible Functional Values lets any (type-compatible) output feed into any (type-compatible) input. More importantly, this isnâ€™t accomplished by a nodes-and-wires interface, but by a manipulable display of the values (the output), i.e. a display of â€œwhat you haveâ€. So you feel like you are manipulating the things rather than the computation. Conalâ€™s goal wasnâ€™t to create a usable system, but to reduce this idea to its core elements, and he did so admirably. Centering values/outputs in the programming experience is moderately rare in FoC systems (and is perhaps a key feature of spreadsheets!). I like to call this mode of programming â€œvalue-centricâ€ (as opposed to algorithm-centric or AST-centric). Of the value-centric programming systems Iâ€™m aware of, Conalâ€™s is always the example I think of first because of its elegant simplicity (even if it is missing a few features to make it practical!).


> *[2020-05-01 23:00:12]* **Doug Moen**:

**Brian Hempel** Thanks for the spreadsheet analogy. Although watching the video, I didn't see see the equivalent of "editing the equation".

Can you suggest related work that I should look at? I'm trying to understand these ideas well enough to implement them in a system for creating 3D models using pure functional programming.


> *[2020-05-02 01:04:33]* **Brian Hempel**:

Well thereâ€™s no text editing in Conalâ€™s Eros as originally conceived so youâ€™re right to wonder where it is. But Eros and spreadsheets both display values more prominently than code and invite manipulation on those values.


> *[2020-05-02 06:28:24]* **Edward de Jong**:

Value-based programming has some niches where it makes sense, like audio/video signal processing where the work product are data streams, and there is often a continuous flow to these streams you don't stop and think about them and wait for some input from the user. In graphical interactive software you have a lot of state, lots of widgets, and management of 500 things on the screen at the same time becomes a major chore. Even the portfolio management system i worked on in FORTRAN back in the day on mainframes did batch processing that included a fair amount of state as we were always accumulating numbers into buckets for sorting and categorizing purposes. None of the projects i have worked on would be convenient at all inside a data centric world. I understand Doug's art generation language would benefit from this, but i consider this area a very specialized niche.

I think of a spreadsheet as a poor-man's database. It is fundamentally a 3.5 dimension system; you have a 2D sheet, which you can break into sub-rectangles, so i call that 2.5 dimensions, and the 3rd dimension is the array of named sheets you can have. As long as your data can fit into that dimensionality it works okay; especially since MS beefed up Excel to support about a million rows. But showing the data and hiding all the formulas makes most spreadsheets unauditable  black magic systems, and really quite dangerous. It is a well known thing in business consulting to find out that some part of a company's fundamental processes have been automated via Excel. There is no question in my mind that a very robust data editor coupled with a graph database could give  Excel a run for its money, but going up against the MS machine is an expensive process. Just like IBM they use the F.U.D. technique for suppressing competition.


> *[2020-05-02 07:29:54]* **William Taysom**:

And honestly Excel doesn't scale so well.  As for the MS machine, I did not learn until visiting Microsoft (a good many years back now) how they had a real value proposition in supporting business seemingly separate from their role as a pedler of, iffy to my eyes, software.


> *[2020-05-02 08:03:49]* **Edward de Jong**:

At $12 a month per person, for an Office 365 license, MS has an almost insurmountable advantage. Google has been doing their best to cut off their air supply by gradually beefing up Google Sheets, and it is having some effect, but as a programming system once you go beyond simple stuff Excel is pretty ugly. But fully understand why people stay in Excel, because the current popular programming stack, HTML/CSS/JS/Frameworks is more than 10x the effort to learn.


> *[2020-05-02 12:28:47]* **Doug Moen**:

**Edward de Jong** Imperative programming (and shared mutable state) was a reasonable idea in the 1950's, 60's and 70's, when programs were small, processors had a single core, and internet-related security holes were not a concern. But imperative programming doesn't scale. The legacy of imperative and shared-mutable-state programming is responsible for our current software crisis. The future of coding is pure functional programming and immutable values.

Large programs with shared mutable state can't be fully understood or debugged. This problem becomes much worse with multiple cores. The imperative programming community's response to multi-core programming was mutable state shared between threads and processor cores, guarded by mutexes. This is a catastrophically bad programming model. You can't understand or debug the code. The solution is to eliminate shared mutable state.

Imperative programming doesn't scale to large numbers of cores--mutual exclusion mechanisms steal most of your performance. The solution is to eliminate shared mutable state. Machine learning with TensorFlow is an important example of massively multi-core programming. What makes it possible is that TensorFlow is a pure functional language. Unfortunately it has to be embedded in Python, because we don't have a mainstream pure functional language yet.

As an aside, I find it tragic that my personal computer has a 1000 cores (most in the GPU), and most of these cores must remain idle because my system software and apps are written in weak, stone age imperative languages that don't provide a simple and efficient way to distribute computation across a huge number of cores.

Imperative programming is a catastrophy for software security. In the imperative model, any function call can change any state in the entire system. This is the root cause of most security flaws. A sort function can encrypt all your files, display a ransom message, and phone home to an internet malware server. And we are seeing these kinds of exploits in supply chain attacks on open source software repositories. Pure functional programming puts security first: functions cannot have side effects, and functions have no access to data that isn't passed as an argument. The type system can trivially guarantee that a sort function will not intentionally spawn a bitcoin miner, or accidently corrupt shared mutable state outside of the array that you are sorting. A common response to the inherent insecurity of imperative code is sandboxing. It's a backwards approach. What if architects built buildings out of contact-sensitive explosive materials, then attempted to mitigate the resulting safety issues using a complex system of nested blast barriers. Imperative programming is inherently insecure, and pure functional programming is the answer.


> *[2020-05-02 14:16:07]* **U010328JA1E**:

**William Taysom** In what ways do you think Excel doesn't scale? Thinking of 1) Having all values at all times on the screen, 2) Obfuscation and debuggability of logic 3) 1 million rows limit 4) Slow updates for big files. ...?


> *[2020-05-02 16:15:54]* **William Taysom**:

U010328JA1E (4) is what I had in mind though having just opened a 400,000 row file I happened to have handy to time some operations, I find Excel laggy but less laggy than remembered.  (Could be new hardware or some performance improvement with tables.  This is macOS mind you.)

---

*[2020-05-02 19:39:14]* **Edward de Jong**:

**Doug Moen** Spending most of my day every day dealing with 100 million intrusion attempts each 24 hours, i am only too familiar with internet security flaws. However, it is the basic protocols of the internet that are at fault, not how they are implemented. It is a fact that the early internet had zero concern with security, given that it ran on private leased lines between the universities.  I remember visiting MIT at the dawn of the internet, and there was a terminal hooked between boston and berkeley. You could chat back and forth; it was fairly useless until the WWW came along.

You are perhaps not familiar with Modula-2 which was Prof. Wirth's 10 year later sequel to Pascal. In Modula-2 you can specify whether or not a called function has access to modify data, and along with other clever and simple features you can make rock solid programs that are as tight as it can be. And to claim that pure functional program is the answer to anything is not factual. If you are building a Chess game program, the state of the board is going to change, and any attempt to evade changing the state of the board is merely hiding the state changes somewhere. Minimizing the number of state variables, and making sure there is no redundancy (which is the source of many errors) is a virtue, but to pursue utter purity in avoiding state makes your program unable to do any useful work. John Backus who invented FP, who gave a lecture i attended in 1973 on his Functional language called Red at the time, was unable to finish his work, and his prior creation FORTRAN did battle with COBOL (and losing to an inferior language). He had the goal of interchangeable parts, but did not achieve it.

There is little evidence that FP is bringing about an era of interchangable parts, and making it easier to maintain large programs, two of the most important unsolved problems in computer engineering. My own project revolves around using deduction, something nearly forgotten as it was last seen in the 70's in PROLOG. Since all programs must eventually map their syntax into the underlying instructions of the Intel or ARM processors, the only difference between 2 languages can be the convenience, conciseness, shareability, and maintainability of the notation. There are languages like FORTH that trade everything for brevity, but nobody programs in FORTH because it is unmaintainable. The ability to share components in the FP languages I have seen is not exemplary. The idiocy of having millions of programmers reinvent the same programs over and over is quite absurd. Look at Google's code pile; they must be close to 10 billion lines, it is ridiculous. I can't recall a time when i found some nice chunk of code on Github and was able to use it. There are billions of lines there, but it is all disorganized, full of dependencies i don't want to carry, and of unknown quality and reliability. So to ensure things work i end up writing almost everything myself. People like me are part of the problem, but i don't have access to a marketplace of nice little widgets like Apple's iTunes App Store has for full apps. That would be a really useful thing.

---

*[2020-05-02 20:53:13]* **Stefan Lesser**:

If youâ€™re not yet locked in to either side of the imperative-vs.-functional debate, this podcast interview might have some thought-provoking ideas about where modern programming languages are headed: 
[https://www.swiftbysundell.com/podcast/71/](https://www.swiftbysundell.com/podcast/71/)


> *[2020-05-02 21:06:01]* **Stefan Lesser**:

As Kevlin Henney likes to point out in many of his presentations, a fundamental problem is mutable shared state. Sure, pure functions are one solution to this and they are extremely useful, but there are other ways that can be useful too. Better ways to handle value and reference semantics, for instance. Iâ€™m excited for what is being explored in Swift and Rust (and C++).

---

*[2020-05-03 00:01:15]* **Edward de Jong**:

to my knowledge the original designer for Swift left Apple, and they are now pursuing a kitchen sink approach to the language, with each version adding more crap. Swift used to be a pretty modest language, but is turning into a monster. Apple is pursuing a strategy of constant enhancement to the language perhaps so as to indirectly block Swift from stabilizing and becoming an Android platform language.  Not that there was much danger, because a great deal of the language is dictated by the Cocoa underpinnings of OSX API sets. At least it has a very tight spec; the old ObjectiveC language that Jobs used at NextStep lacked a manual, and the spec was "whatever the compiler does". I wonder what the author of Swift will come up with next; not being tethered to OSX would give you a lot of freedom.


> *[2020-05-03 03:32:51]* **Ivan Reese**:

> I wonder what the author of Swift will come up with next
There was a fun interview with Lattner on the Accidental Tech Podcast a few weeks ago about just that: <https://atp.fm/episodes/371>

The short versionÂ â€” working at Google (previously) and the RISC-V company SiFive (now), creating a new superset of LLVM IR called MLIR, which (he claims) will allow for Swift to be used with TensorFlow (et al.) to great effect.


> *[2020-05-03 05:25:59]* **Steve Dekorte**:

Does this not count as a manual? [http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf](http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf)


> *[2020-05-03 10:41:55]* **Stefan Lesser**:

Swift comes with that strong Apple flavor that puts some people off without even looking at it. However, if youâ€™re interested in the future of programming and youâ€™re ignoring Swift, youâ€™re definitely missing out on some cutting edge language design developments.


> *[2020-05-03 21:16:56]* **Yoz Grahame**:

â€¦ such as: <https://tryolabs.com/blog/2020/04/02/swift-googles-bet-on-differentiable-programming/>


> *[2020-05-03 21:23:58]* **Yoz Grahame**:

Itâ€™s worth skimming the Google teamâ€™s doc explaining why they picked Swift ( <https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md> ). Itâ€™s not that Swift has any special features, more that it has the right mix of strictness, usability and popularity.

---

*[2020-05-03 19:41:28]* **Mariano Guerra**:

I'm archiving 2019 and it seems this slack started October 11th?


> *[2020-05-03 20:34:15]* **Mariano Guerra**:

welp, can't see past october 11th from the api ðŸ˜•


> *[2020-05-03 21:31:01]* **Yoz Grahame**:

The FoC Slack is on the free plan, no? If so, thatâ€™s why. <https://slack.com/help/articles/115002422943-Message-file-and-app-limits-on-the-free-version-of-Slack>