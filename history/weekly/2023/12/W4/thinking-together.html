
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2023-12-19T20:04:19.139Z" class="post"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2023-12-16&amp;toDate=2023-12-22&amp;channel=thinking-together&amp;filter=#2023-12-19T20:04:19.139Z" class="date">2023-12-19 20:04:19</a> <div class="message"><p>A large codebase is a realm ruled by the iron fist of legalism. In addition, it is a patchwork of many different jurisdictions, each with their own overlapping but subtly different laws. And it's incredibly easy to spawn a new jurisdiction!</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-12-20T17:18:18.645Z" class="reply"><span class="user">Denny Vrandeƒçiƒá</span> <a href="./?fromDate=2023-12-17&amp;toDate=2023-12-23&amp;channel=thinking-together&amp;filter=#2023-12-20T17:18:18.645Z" class="date">2023-12-20 17:18:18</a> <div class="message"><p>It is easy because the terrain is often only vast and multidimensional. And instead of tending to existing areas, people love to conquer new terrain.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-24T11:08:04.404Z" class="reply"><span class="user">Beni Cherniavsky-Paskin</span> <a href="./?fromDate=2023-12-21&amp;toDate=2023-12-27&amp;channel=thinking-together&amp;filter=#2023-12-24T11:08:04.404Z" class="date">2023-12-24 11:08:04</a> <div class="message"><p>To a programmer, sure, a small intimately familiar codebase offers much escape from legalism, by making it realistically achievable to change the rules.</p>
<p>But it's also an interesting question what can we do for "end users", or even other programmers who are reluctant to invest in learning our piece of the terrain.</p>
<p>Do you think for a  <em>given user task,</em>  building it with less legalism for users correlates with smaller codebases? ü§î</p>
<p>[The question is unfair, because achieving same "functionality" with less legalism is actually very valuable and should count as "more functionality"...  Very hard to quantify.]</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-24T11:14:24.236Z" class="reply"><span class="user">Beni Cherniavsky-Paskin</span> <a href="./?fromDate=2023-12-21&amp;toDate=2023-12-27&amp;channel=thinking-together&amp;filter=#2023-12-24T11:14:24.236Z" class="date">2023-12-24 11:14:24</a> <div class="message"><p>The "conquer new terrain" metaphor is apt.  People don't go off merely because we're too selfish to "tend to existing areas"; to some degree we enjoy it  <em>because</em> it lets us make our own jurisdiction!  Whereas putting up with other people's rules (and being careful not to break their use cases) is genuinely hard.</p>
<p>=&gt; Conjecture: any techniques for building less legalistic software might benefit programming itself by reducing NIH tendencies and encouraging positive-sum code reuse??</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-24T18:19:21.690Z" class="reply"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2023-12-21&amp;toDate=2023-12-27&amp;channel=thinking-together&amp;filter=#2023-12-24T18:19:21.690Z" class="date">2023-12-24 18:19:21</a> <div class="message">
<blockquote><p>Do you think for a given user task, building it with less legalism for users correlates with smaller codebases? 
ü§î</p>
</blockquote>
<p>Proprietary programs and websites tend towards power for the authors, laws for users. Open source programs tend towards power for insiders (who can modify them), laws for outsiders. I want my small, open source Freewheeling programs to provide power for people, laws for the computer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-24T20:30:53.202Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-12-21&amp;toDate=2023-12-27&amp;channel=thinking-together&amp;filter=#2023-12-24T20:30:53.202Z" class="date">2023-12-24 20:30:53</a> <div class="message"><p>... (yet again, sorry) my deep belief is: insiders and authors (and researchers and assembler programmers) think that "programming" MUST consist of step-wise sequencing of electronic machines, whereas people don't want to know about programming and think in terms of free will (aka true asynchronousity, not step-wise simultaneity) .  Any UX that presents tools that need to be sequenced in a step-wise (synchronous) manner will not be understood by people, and will remain in the domain of the ivory towerists. The trains will run on time, but, the tools will not be appreciated by the majority ...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-24T21:16:15.783Z" class="reply"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2023-12-21&amp;toDate=2023-12-27&amp;channel=thinking-together&amp;filter=#2023-12-24T21:16:15.783Z" class="date">2023-12-24 21:16:15</a> <div class="message"><p>Isn't lots of asynchronous orchestration also too complex for people? Orchestration is just inherently difficult to model in one's head.</p>
<p>Conversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.</p>
<p>So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-25T04:06:43.470Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-12-22&amp;toDate=2023-12-28&amp;channel=thinking-together&amp;filter=#2023-12-25T04:06:43.470Z" class="date">2023-12-25 04:06:43</a> <div class="message">
<blockquote><p>Isn't lots of asynchronous orchestration also too complex for people? </p>
</blockquote>
<p>Lots yes.  Some no.</p>
<p>Let's take away the big words and observe what remains.</p>
<p>People - Western, English speaking people - draw diagrams on whiteboards and flip charts.  The diagrams read from left to right, top to bottom.  Usually the diagrams consist of boxes with some words on them, and arrows with some words on them.</p>
<blockquote><p>Orchestration is just inherently difficult to model in one's head.</p>
</blockquote>
<p>For programmers, yes, for people, not so much.  As long as the result is not "too busy".  I.E. diagrams cannot contain too much detail. If they want to express more detail, they flip to the next blank page and draw another not-so-busy diagram. And so on.  Drawing  <em>everything</em>  on a single diagram is anathema.  Good powerpoint slide decks are like that.  One point per slide, advance to next slide if more detail is required.</p>
<blockquote>
</blockquote>
<p>Conversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.</p>
<p>Yes.  And your kids have no problem saying "while the potatoes cook, cut up the carrots". They don't invoke monads or futures or awaits to say this, they just say it.  When they draw it on a whiteboard, it's pretty clear - one box branches out to two boxes.  Left to right.  Then, the two branches join back together into a single box.  No rules. The person drawing the branches gets to say when the branches join. The toolmaker doesn't get to dictate. The toolmaker provides a recursive canvas (a flip-chart, or an erasable whiteboard) and provides the dry-erase markers. The person doing the drawing uses the tools to say what they mean.</p>
<p>Not everyone expresses what they mean in a good way. The people who do this well are promoted to "Architect" status, the rest don't get promoted.</p>
<blockquote><p>So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.</p>
</blockquote>
<p>In a way, yes, in a way, no. My feeling is that this is quite simple and doesn't need to be complicated further.  Encapsulate units, make the units be totally independent. Function-based programming  languages do only half of the job.  It is trivial to do the rest of the job.  Preserve time-ordering and left-to-rightness and top-to-downness. Allow composition of such units (aka LEGO-ification).  Current programming languages lean solely on the LIFO meme (stack).  Simply adding a LIFO meme (queue) can break out of the step-wise (synchronous) paradigm. This is nothing new - networking protocols already do this kind of thing.  I think that we can push network protocol-ization down to the programming level.  Easily.</p>
<p>Don't use one at the exclusion of the other. Use both. LIFO and FIFO. CALL/RETURN and SEND.</p>
<p>LIFO is good for expressing the innards of components, FIFO is good for expressing inter-component communication.</p>
<p>Input and output queues are good for preserving time-ordering of data arrival and data generation.</p>
<p>"Programming" is the whole enchilada. Innards and inter-component communication.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-12-25T07:21:12.508Z" class="reply"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2023-12-22&amp;toDate=2023-12-28&amp;channel=thinking-together&amp;filter=#2023-12-25T07:21:12.508Z" class="date">2023-12-25 07:21:12</a> <div class="message"><p>The question of "why not use both?" makes sense to me. But I don't think things will be any better if we start using both. I think architects will still continue to make the same sorts of messes they do today. I think you're comparing apples and oranges, the current messy state of the status quo vs the idealized pristine state of your idea. But people will start making a mess with it one microsecond after they adopt it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
