
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2023-05-24T12:10:23.294Z" class="post"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:10:23.294Z" class="date">2023-05-24 12:10:23</a> <div class="message">
<ul><li>Are games more robust than other kinds of end-user software?  Why?</li><li>Are games in 2023 more robust than games in 1980?  Why?</li></ul></div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-05-24T12:16:47.327Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:16:47.327Z" class="date">2023-05-24 12:16:47</a> <div class="message">
<ul><li>Are games more robust than other kinds of end-user software?  Why?</li></ul><p>Not sure if this counts as “robust” — but I think games usually need to be “explainable” and easy(ish) to understand in a way that other software isn’t. The biz logic of some industry program can become complicated beyond the point of reason, as long as it still “works,” whereas a game, at some level, always has to make its logic known. Known to both devs and folks playing the game.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T12:19:40.930Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:19:40.930Z" class="date">2023-05-24 12:19:40</a> <div class="message"><p>(also, love love love this line of questioning! learning to QA games I think totally changed the way I approached software design/dev/and testing — it influences a lot of what I do these days for work)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T12:21:54.839Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:21:54.839Z" class="date">2023-05-24 12:21:54</a> <div class="message">
<ul><li>Are games in 2023 more robust than games in 1980?  Why?</li></ul><p>Thinking of your second question — can you define a bit more what you mean by “robust?”</p>
<p>At first blush, I’m want to say “no, not really” — but I think I’m conflating “robust” and “resilient”</p>
<p>Modern games are rife with dependencies on external systems, beefy hardware, other folks, whereas games from the 80s got to be shipped “done.” No updates for a cartridge.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T12:34:12.604Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:34:12.604Z" class="date">2023-05-24 12:34:12</a> <div class="message"><p>My MacBook laughtop starts acting weird if I don’t give it a weekly preventative reboot.  Wasting my time and effort and destroying my carefully set up environment.</p>
<p>I consider myself to be completely ignorant of gaming and production of game software.  But, I get the impression that gamers don’t experience an annoying UX.</p>
<p>If so, then FoC can learn something from game software design and development and production.</p>
<p>By “robust” I guess I mean anything that affects the UX.  You’ve already stretched my knee-jerk thoughts about this.</p>
<p>What does “QA” of games mean in practice?  Any other revelations about the development of games?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T12:42:14.386Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T12:42:14.386Z" class="date">2023-05-24 12:42:14</a> <div class="message"><p>Observation: “Modern games are rife with dependencies...“.  This seems to say that “more type checking” won’t help as much as “getting rid of dependencies” will.  Does that mean rethinking of packages, package managers, make, the structure of software apps, etc, etc?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T13:26:08.183Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T13:26:08.183Z" class="date">2023-05-24 13:26:08</a> <div class="message">
<blockquote><p>But, I get the impression that gamers don’t experience an annoying UX.</p>
</blockquote>
<p>Alas, this isn’t true — many games are rife with bad UX. There are many reasons for this, but one of the biggest reasons I see for bad UX in games is when a game is ported from 1 system to another, and the input methods aren’t well considered. You see this especially for a lot of games that start out life on desktop, but that then move to consoles. The UI elements end up being filled with small text, and tiny touch targets that are difficult to find or navigate through using a controller.</p>
<p>…but this isn’t like every game by any means.</p>
<p>Something that I think many moderns games get “right” is how they lead a player through an even open-ended environment through well crafted spaces.</p>
<p>Lots of modern software can be difficult to navigate for the first time, and doesn’t always do heaps to suggest a way through — many games are able to lean on tools provided by classical art and expanded throughout art history to suggest a path through a space.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T13:32:10.203Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T13:32:10.203Z" class="date">2023-05-24 13:32:10</a> <div class="message">
<blockquote><p>What does “QA” of games mean in practice? Any other revelations about the development of games?</p>
</blockquote>
<p>Once upon a time,  I used to approach QA tasks by strictly comparing some finished thing to the spec./requirements.</p>
<p>Sort of like deconstructing  a finished cake by magically un-baking it, extracting all of the flour, sugar, eggs, milk and oil to ensure that the recipe was followed to the “T.”</p>
<p>Learning to QA games, I realized that  <em>everything is state</em> . And that another approach is to not focus on the ridged bits of the program (what you built, and what is spec’d) but to focus instead on all the ways state flows through that thing you built…because state is what is often harder to control, and difficult to reason about.</p>
<p>I think Rich Hickey would say it is to be avoided, but in my experience state is unavoidable — what needs to be done instead of avoiding it is to realize you don’t always control it, and make sure your program can deal with totally unforeseen types of state</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T13:34:20.459Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T13:34:20.459Z" class="date">2023-05-24 13:34:20</a> <div class="message">
<blockquote><p>Observation: “Modern games are rife with dependencies...“. This seems to say that “more type checking” won’t help as much as “getting rid of dependencies” will. Does that mean rethinking of packages, package managers, make, the structure of software apps, etc, etc?</p>
</blockquote>
<p>The dependencies are usually external from the programming systems. In the 1980s a game was a game was a game. When you loaded a cartridge into a nintendo it started what was on that cartridge and you were off.</p>
<p>Today, when you start a game many of them have to connect to a web service, or are thin clients to a thing running on a server somewhere, or exist in a world that is contingent on the actions of other player factions at the level of a “season.”</p>
<p>What I say “dependencies” in this context, i mean stuff like hardware and services, not so much other people’s code</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T14:30:08.019Z" class="reply"><span class="user">Christopher Patti</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T14:30:08.019Z" class="date">2023-05-24 14:30:08</a> <div class="message">
<blockquote><p>Are games in 2023 more robust than games in 1980?  Why?</p>
</blockquote>
<p>Generally speaking I think not. As entertainment, the stakes tend to be lower. Add in the economics around how games are developed and sold and the immense complexity of modern AAA titles, and you wind up with an intensely challenging testing story.</p>
<blockquote><p>Are games in 2023 more robust than games in 1980?  Why?</p>
</blockquote>
<p>Almost surely not. It's a matter of complexity and scale. The average Atari 8 bit home computer video game cartridge is  <em>8k</em> .  That's not just 8k code, that's 8k code, assets, the whole enchilada. Compare and contrast with  <em>No Man's Sky</em>  which clocks in at 6 gigabytes! Admittedly the majority of this is assets, but I can only imagine the code size is quite a bit bigger than 8k.</p>
<p>How can a creature of such size and complexity possibly be more robust than &lt; 8k of lovingly hand crafted 6502 assembler?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T15:43:47.039Z" class="reply"><span class="user">Ibro C.</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T15:43:47.039Z" class="date">2023-05-24 15:43:47</a> <div class="message">
<blockquote><p>Are games more robust than other kinds of end-user software?  Why?</p>
</blockquote>
<p>Depends how you define robust? The potential actions that can be taken are planned in  advance for a game. so if robust  = no. of features / functionality then no. OTOH, the development process for games tends to focus on shipping a complete product rather than MVPs and continuous improvements in other software. So if robust = complete then yes.</p>
<blockquote><p> Are games in 2023 more robust than games in 1980?  Why?</p>
</blockquote>
<p>This is harder to answer because there's such a big gap between indie and AAA in 2023. Modern progress and expectations have given game studios more opportunity to shoot themselves in the foot. I don't think that's a good enough argument for modern games being less robust. Hardware and tools are more robust than in 1980. Some of that, as performance always does, gets wasted and some of it goes into making better games.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-24T15:46:30.989Z" class="reply"><span class="user">Ibro C.</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T15:46:30.989Z" class="date">2023-05-24 15:46:30</a> <div class="message"><p>Another thought for the second question is, I'm not sure to what degree 1980s game did not have bugs and glitches versus YouTube not being around to make them go viral. I imagine the total number is lower than today, but much higher than we'd guess.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-25T14:36:28.661Z" class="reply"><span class="user">Christopher Patti</span> <a href="./?fromDate=2023-05-22&amp;toDate=2023-05-28&amp;channel=thinking-together&amp;filter=#2023-05-25T14:36:28.661Z" class="date">2023-05-25 14:36:28</a> <div class="message"><p>There was no Youtube, but as someone who lived through that era I can assure you there was community 🙂 There were dial-up BBSes and messaging networks like FIDONet and WWIVNet so larger distributed communities were a thing, and we discussed all the games of the time down to the most minute detail! Even if we couldn't post streaming video showing each glitch.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2023-05-24T20:57:42.316Z" class="post"><span class="user">Jason Morris</span> <a href="./?fromDate=2023-05-21&amp;toDate=2023-05-27&amp;channel=thinking-together&amp;filter=#2023-05-24T20:57:42.316Z" class="date">2023-05-24 20:57:42</a> <div class="message"><p>I am going to need to come up with a more robust way to allow my users to edit legislative text in a way that is user friendly, and forces them to stick to a predefined data structure. I'm wondering if anyone has tried to use tools like slate.js or ProseMirror for that sort of thing, or have other suggestions. It's legislation, so I want the editing environment to be as text-like as I can manage.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-05-27T10:42:36.093Z" class="reply"><span class="user">greg kavanagh</span> <a href="./?fromDate=2023-05-24&amp;toDate=2023-05-30&amp;channel=thinking-together&amp;filter=#2023-05-27T10:42:36.093Z" class="date">2023-05-27 10:42:36</a> <div class="message"><p>I’ve had great experiences with codemirror. It allows you to describe a syntax with a package called Lezer. It can be a bit of a nut to crack but the creator is incredibly responsive.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-30T16:20:22.674Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2023-05-27&amp;toDate=2023-06-02&amp;channel=thinking-together&amp;filter=#2023-05-30T16:20:22.674Z" class="date">2023-05-30 16:20:22</a> <div class="message"><p>Thanks for that, Greg. Hadn't heard of Lezer, so I will check it out. I've been playing with ProseMirror a little further, and it looks really promising. People have been working on automating generating ProseMirror configurations (partly) from XML schema documents, which is an enormous upside for me, so I'll probably dig deeper. Do you know if they are related to each other other than in name? The prosemirror system has a very syntax-centric method of configuring it, so it wouldn't totally surprise me.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>📷 <a href="http://history.futureofcoding.org/history/msg_files/F05/F05A47J6P2N.png">image.png</a></p>
</blockquote>
</div></div><div id="2023-05-30T16:26:24.574Z" class="reply"><span class="user">greg kavanagh</span> <a href="./?fromDate=2023-05-27&amp;toDate=2023-06-02&amp;channel=thinking-together&amp;filter=#2023-05-30T16:26:24.574Z" class="date">2023-05-30 16:26:24</a> <div class="message"><p>Looks like it’s the same developer! </p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2023-05-28T14:14:38.761Z" class="post"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-05-25&amp;toDate=2023-05-31&amp;channel=thinking-together&amp;filter=#2023-05-28T14:14:38.761Z" class="date">2023-05-28 14:14:38</a> <div class="message"><p>Software Engineers do not write code.</p>
<p>Implementors (coders) write code.</p>
<p>Engineers think (deeply) about what code needs to be written, and, what trade-offs need to be made to simply make the system work.</p>
<p>Production Engineers think about making trade-offs so that the system is “efficient” along one or more dimensions (speed, space, cost, etc.), but, only after the initial system is working and shown to satisfy end-users’ needs.</p>
<p>Current popular programming languages, like Rust, Haskell, Python, etc., conflate all of these issues together, thus,  making the code more difficult to design.  Conflating issues together like this has a name: “cottage industry”.</p>
<p>Then, there’s Software Architecture, Maintenance, Testing, Q/A, Security, etc., etc.</p>
<p>The above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.</p>
<p>Note, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.).</p>
<p>Note, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-05-28T15:17:14.275Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-25&amp;toDate=2023-05-31&amp;channel=thinking-together&amp;filter=#2023-05-28T15:17:14.275Z" class="date">2023-05-28 15:17:14</a> <div class="message">
<blockquote><p>The above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.</p>
</blockquote>
<p>Note, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.).</p>
<p>do you think that software development has any actual similarities to construction in the arc of it's actual praxis when removed from business contexts?</p>
<p>By this question I mean: it seems that a lot of folks readily reach for architectural/engineering analogs when talking about software dev., but, when I think it through I struggle to see the actual similarities outside of how projects are run...and how projects are run, to my mind, has little to nothing to do with producing good outcomes and everything to do with leaning on known business processes.</p>
<p>What if a software team was run more like a kitchen, or software dev was thought of as being more akin to weaving at a loom?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-28T15:22:02.146Z" class="reply"><span class="user">Eli Mellen</span> <a href="./?fromDate=2023-05-25&amp;toDate=2023-05-31&amp;channel=thinking-together&amp;filter=#2023-05-28T15:22:02.146Z" class="date">2023-05-28 15:22:02</a> <div class="message">
<blockquote><p>Note, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages.</p>
</blockquote>
<p>I think this bit is true, but missing some nuance in that a lot of software that is developed isn't developed exclusively by programmers using programming languages -- there are designers using design tools, there may be researchers using various research methods, etc.</p>
<p>Those different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-05-28T16:46:20.838Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2023-05-25&amp;toDate=2023-05-31&amp;channel=thinking-together&amp;filter=#2023-05-28T16:46:20.838Z" class="date">2023-05-28 16:46:20</a> <div class="message"><p>Yes, I believe that software development should be like The Film Industry (or Construction, or ...)</p>
<p>But, I believe that software development - in its current form - cannot be easily stratified into layers.  The wrong questions are being asked, emphasis is not being placed on layered processes and technologies.</p>
<p>Engineering processes were not created by business.  Engineering processes were created by Engineering.  Business capitalized on this structure, later.</p>
<p>” ... Those different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another. ...”</p>
<p>Software libraries, though, are not wholly isolated.  This limits growth and prevents a Moore’s Law for Software from existing and prevents Christopher Alexander-like Patterns from being applied (easily).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-06-01T18:48:03.348Z" class="reply"><span class="user">Zach Kimberg</span> <a href="./?fromDate=2023-05-29&amp;toDate=2023-06-04&amp;channel=thinking-together&amp;filter=#2023-06-01T18:48:03.348Z" class="date">2023-06-01 18:48:03</a> <div class="message"><p>I think the follow-up question is how to create these layers or different roles, rather than just that they should exist. Because your posts are more a question than an answer.</p>
<p>My first concern is that people will blur the boundaries between roles. For example, my day job is in deep learning and we have this somewhat defined separation that engineers build deep learning frameworks in C++ and then research scientists use them from Python. But too many people cross the boundaries where scientists need to change libraries that I'm not sure this separation was good for the field. As another example, front end engineers might contribute to designs and back end engineers might contribute to the architecture. So while these separations should probably exist, I would rather them be a soft separation rather than a hard one.</p>
<p>One part of my own work that might be relevant is this piece I call <a href="https://blog.zachkimberg.com/programming%20languages/doing-things-well/">choice</a>. The goal was to separate correctness from optimization and it can be used to separate say implementers and engineers from production engineering. But it also makes it easier to build layers that combine with greater possibilities. Do you see something like this as helping in creating some level of separation of layers or roles?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-06-03T11:51:03.009Z" class="reply"><span class="user">David Alan Hjelle</span> <a href="./?fromDate=2023-05-31&amp;toDate=2023-06-06&amp;channel=thinking-together&amp;filter=#2023-06-03T11:51:03.009Z" class="date">2023-06-03 11:51:03</a> <div class="message"><p>You've likely read this already, but Hillel Wayne wrote a good series titled <a href="https://www.hillelwayne.com/post/are-we-really-engineers/">Are We Really Engineers</a> <em>?</em>  interviewing many engineers-who-became-programmers comparing the fields — though, upon glancing at it again, I thought he had discussed the layers that other professions have (i.e. architect, engineer, construction, etc.) and I don't see it. Still a good read.</p>
</div> <div class="attachments"><blockquote><p>📝 <a href="https://www.hillelwayne.com/post/are-we-really-engineers/">Are We Really Engineers?</a></p>
<p>This is part one of the Crossover Project. Part two is here and part three is here.
I sat in front of Mat, idly chatting about tech and cuisine. Before now, I had known him mostly for his cooking pictures on Twitter, the kind that made me envious of suburbanites and their 75,000 BTU woks. But now he was the test subject for my new project, to see if it was going to be fruitful or a waste of time.</p>
</blockquote>
</div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
