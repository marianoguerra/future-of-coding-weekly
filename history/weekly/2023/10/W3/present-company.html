
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2023-10-10T15:34:22.537Z" class="post"><span class="user">David Alan Hjelle</span> <a href="./?fromDate=2023-10-07&amp;toDate=2023-10-13&amp;channel=present-company&amp;filter=#2023-10-10T15:34:22.537Z" class="date">2023-10-10 15:34:22</a> <div class="message"><p>I was curious this morning: my na√Øve view of compiler history is that they used to be very small (due to performance constraints) and have gotten very complicated over the years in order to support multiple platforms and in order to employ more and more optimizations. Is that generally a fair take? What are the big changes to compiler architectures from the early days? Does something like LLVM produce enough better code to justify its complexity? Are there any blog post- or paper-length history of compilers articles out there? (I'm not quite so curious as to be ready to read a whole book, but if you've got a good recommendation‚Ä¶)</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-10-10T21:05:00.506Z" class="reply"><span class="user">Mark Dewing</span> <a href="./?fromDate=2023-10-07&amp;toDate=2023-10-13&amp;channel=present-company&amp;filter=#2023-10-10T21:05:00.506Z" class="date">2023-10-10 21:05:00</a> <div class="message"><p>One change is that companies don't need to build their own complete compiler anymore.  Previously, each company might buy a front end (e.g. EDG) for parsing, but the rest of the compiler they had to build in-house (or go complete open and extend gcc).  In addition to hardware performance constraints, the compiler size (and complexity) was limited to what size compiler team a company was willing to fund.  With LLVM, companies can focus on the pieces specific to their needs.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-11T09:12:39.901Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T09:12:39.901Z" class="date">2023-10-11 09:12:39</a> <div class="message"><p> The question ‚Äúis it worth it‚Äù is pretty hard to answer. There can be different assessments of the cost of LLVM being such a big project, and there are debates about how much the optimizations in LLVM matter, compared to a smaller compiler (see the discussion around Daniel Bernstein‚Äôs ‚Äúthe death of optimizing compilers‚Äù).</p>
<p>Throat clearing done, Bernstein is wrong, and the answer is ‚Äúyes, it‚Äôs worth it.‚Äù</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2023-10-11T14:49:16.918Z" class="post"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T14:49:16.918Z" class="date">2023-10-11 14:49:16</a> <div class="message"><p>A question that came up in a discussion this morning:</p>
<p>Suppose you want to publish a command-line utility program, meant to be easy to use. Doing Web retrieval and some post-processing. Around 500 lines in a typical scripting language, but with dependencies (in that language plus C libraries).</p>
<p>It looks like packaging such a tool for all popular platforms (i.e. package managers) will be a lot more work than actually writing the code.</p>
<p>True? Any way to avoid this?</p>
<p>Ideas so far: don't use a scripting language, but something with a compiler that can produce portable executables for every major platform. Recommendations in that category so far: Go, Rust, Racket, Common Lisp. I have doubts that all of these can handle "plus C libraries", but it's a start.</p>
<p>Does anyone here have actual experience with this kind of project?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-10-11T15:02:23.534Z" class="reply"><span class="user">Tom Lieber</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T15:02:23.534Z" class="date">2023-10-11 15:02:23</a> <div class="message"><p>Do you just want a package, or do you wanted it listed in all the registries for installation by name?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-11T15:46:05.774Z" class="reply"><span class="user">Benji York</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T15:46:05.774Z" class="date">2023-10-11 15:46:05</a> <div class="message"><p>It's relatively new, but if you're open to experimenting, take a look at <a href="https://pkgx.sh/">pkgx.sh</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-11T16:48:53.969Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T16:48:53.969Z" class="date">2023-10-11 16:48:53</a> <div class="message"><p>I can‚Äôt actually evaluate whether it‚Äôs a good idea, but <a href="https://justine.lol/ape.html">justine.lol/ape.html</a> exists</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-11T16:58:36.929Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T16:58:36.929Z" class="date">2023-10-11 16:58:36</a> <div class="message"><p>I think runnable fat .jar is probably the best bet, like the Apache Tika standalone app. It has about a million dependencies under the hood but the user experience is just to download a single executable that runs on all platforms (that have java)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-11T17:17:39.305Z" class="reply"><span class="user">Tudor Girba</span> <a href="./?fromDate=2023-10-08&amp;toDate=2023-10-14&amp;channel=present-company&amp;filter=#2023-10-11T17:17:39.305Z" class="date">2023-10-11 17:17:39</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> did you consider Pharo+C?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T06:44:40.041Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T06:44:40.041Z" class="date">2023-10-12 06:44:40</a> <div class="message"><p><a href="https://twitter.com/girba">Tudor Girba</a> Briefly. I have never seen a command-line tool written in Pharo in the wild, so I can only speculate how that would be distributed. For plain Pharo code, I imagine a tarball containing the VM and the image, plus a script that takes care of running the VM with the right parameters to find the image. The obstacle I see is the C dependencies. For macOS and Windows, I could add the binaries to the tarball. For Linux, there is too much heterogeneity to distribute binaries, so I'd have to find a way to make the Pharo code find the libraries wherever the system package manager has put them. And that's something that only the package manager knows for sure.</p>
<p>Scientific computing environments are particularly challenging because "Linux" really means "anything with a Linux kernel". There's high-performance computing centres running prehistoric CentOS versions ("we prefer known bugs to unknown bugs"), nerd laptops with the latest exotic distribution, and in between more standard installations such as Debian or Ubuntu, in any versions from ten years ago to bleeding edge.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T12:05:47.074Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T12:05:47.074Z" class="date">2023-10-12 12:05:47</a> <div class="message"><p><a href="https://x.com/borkdude/status/1712073551992307852?s=20">x.com/borkdude/status/1712073551992307852?s=20</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://x.com/borkdude/status/1712073551992307852?s=20">(Œª. borkdude) :seedling: on X</a></p>
<p>You can now create self-contained binaries from #babashka (from development) using an uberjar</p>
</blockquote>
<p><a href="https://t.co/xPq4vsbwng">https://t.co/xPq4vsbwng</a></p>
<p>Give it a spin if you're interested in this!</p>
<h1>clojure</h1></div> <div class="files"></div></div><div id="2023-10-12T12:06:10.150Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T12:06:10.150Z" class="date">2023-10-12 12:06:10</a> <div class="message"><p>There are a thousand things to optimize over in this question, but this is one way.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T13:32:48.120Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T13:32:48.120Z" class="date">2023-10-12 13:32:48</a> <div class="message"><p>That looks nice, thanks!</p>
<p>It doesn't mention C dependencies though...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T14:26:51.058Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T14:26:51.058Z" class="date">2023-10-12 14:26:51</a> <div class="message"><p>There‚Äôs FFI, but you still have the problem of whether the libs you want to use are installed. The maximally safe case is to static link everything into a platform specific binary using, zB  <code>go</code> .</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T16:18:22.229Z" class="reply"><span class="user">Arcade Wise</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T16:18:22.229Z" class="date">2023-10-12 16:18:22</a> <div class="message"><p>Cosmopolitan C is surprisingly powerful! </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T16:47:53.814Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T16:47:53.814Z" class="date">2023-10-12 16:47:53</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> It's either that, or integration of my code into whatever build system the target platform uses. Both options require a lot of overhead effort.</p>
<p><strong>@Arcade Wise</strong> Found it (<a href="https://justine.lol/cosmopolitan/">justine.lol/cosmopolitan</a>) - that's amazing! Not sure I'd be willing to write my code in C in order to use it, but it's pretty cool :-)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T16:48:35.224Z" class="reply"><span class="user">Arcade Wise</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T16:48:35.224Z" class="date">2023-10-12 16:48:35</a> <div class="message"><p>Yeah! It‚Äôs wild. I wonder how hard it would be to make a language that compiles to and has bindings for cosmo C</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-12T16:51:37.095Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-09&amp;toDate=2023-10-15&amp;channel=present-company&amp;filter=#2023-10-12T16:51:37.095Z" class="date">2023-10-12 16:51:37</a> <div class="message"><p>Not so much a language but a toolchain, right? Any language that can be compiled to C should be adaptable rather easily. That includes C++, Fortran, Scheme, Common Lisp, and probably many others.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-13T22:50:47.297Z" class="reply"><span class="user">Mike Austin</span> <a href="./?fromDate=2023-10-10&amp;toDate=2023-10-16&amp;channel=present-company&amp;filter=#2023-10-13T22:50:47.297Z" class="date">2023-10-13 22:50:47</a> <div class="message"><p>Node with WebAseembly? <a href="https://nodejs.dev/en/learn/nodejs-with-webassembly/">nodejs.dev/en/learn/nodejs-with-webassembly</a> I don't have direct experience with WASM in Node, but many platforms can run Node.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-14T12:16:44.696Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2023-10-11&amp;toDate=2023-10-17&amp;channel=present-company&amp;filter=#2023-10-14T12:16:44.696Z" class="date">2023-10-14 12:16:44</a> <div class="message"><p>But is it possible to create stand-alone binaries? If users have to install node, installation is too complicated.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-10-14T17:21:29.878Z" class="reply"><span class="user">Mike Austin</span> <a href="./?fromDate=2023-10-11&amp;toDate=2023-10-17&amp;channel=present-company&amp;filter=#2023-10-14T17:21:29.878Z" class="date">2023-10-14 17:21:29</a> <div class="message"><p>Looks like there's experimental work, but yeah I wouldn't depend on that yet. <a href="https://nodejs.org/api/single-executable-applications.html">nodejs.org/api/single-executable-applications.html</a>. There is however, pkg: <a href="https://medium.com/@tech_girl/deploy-your-node-js-application-as-a-single-executable-4103a2508dd7">medium.com/@tech_girl/deploy-your-node-js-application-as-a-single-executable-4103a2508dd7</a> I may experiment with this myself, it looks interesting. The binary will be fairly large of course, since it's the whole JavaScript VM + your app üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
