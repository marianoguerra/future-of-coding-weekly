
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2021-06-05T08:39:32.038Z" class="post"><span class="user">Konrad Hinsen</span> <a href="#2021-06-05T08:39:32.038Z" class="date">2021-06-05 08:39:32</a> <div class="message"><p>This is a great episode, with touches on many topics. One of them was so much in collision with my own ideas for the future of coding that I am tempted to launch a discussion on it. It's the notion of an "escape hatch" from a programming environment.</p>
<p>Overall, there's too much of a "let's build a universe" attitude in computing, and the idea of a programming environment ideally being complete and mostly closed is a reflection of it. I don't want  an escape hatch for going elsewhere if I absolutely have to. I want bridges to other programming environments, for my own use and for connecting with other people's work.</p>
<p>My idea of the future of coding is more like living in physical space. I live in a house, which has multiple rooms. In some rooms, I do things alone, in others with family members. The house is part of a neighborhood, where I do things with neighbours. The neighborhood is part of a town, and so on. Each compartment provides just the right environment for some activity, but none locks me in, wishing for an escape hatch.</p>
</div> <div class="attachments"><blockquote><p>[June 4th, 2021 3:26 AM] ivanreese: &lt;<a href="https://futureofcoding.org/episodes/050|Episode">https://futureofcoding.org/episodes/050|Episode</a> 50&gt; (:birthday:) of the Future of Coding podcast is out now.</p>
<p>Today, the guest is &lt;<a href="https://maryrosecook.com|Mary">https://maryrosecook.com|Mary</a> Rose Cook&gt;, among whose thousand-and-one side projects you'll find <a href="http://islalanguage.org|Isla">http://islalanguage.org|Isla</a> and &lt;<a href="http://codelauren.com|Code">http://codelauren.com|Code</a> Lauren&gt;. Both are experimental programming environments with their own bespoke languages, focussed on learnability and visualization. In the case of Code Lauren, we also see another theme of Mary's work ‚Äî taking the largely invisible processing done by compilers / interpreters and making it visible and interactive. Mary also made a totally awful game that I hate so much, but to find out what that is you'll just have to listen to the show (or read the largely unedited transcript ‚Äî again, sorry Jack).</p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2021-06-05T14:32:28.039Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-06-05T14:32:28.039Z" class="date">2021-06-05 14:32:28</a> <div class="message"><p>Do you want existing software to have this room property? Or do you want some set of independent universes to choose "standards for interoperability"? I think we have the second already, and to the extent it fails it's because of the first problem. So let's talk about the first problem.</p>
<p>Building a passage/wormhole between two rooms/universes is hard. Even for the programmers who built this one room you're in now. Nobody wants to make it easier, because that's even harder. Nobody wants it enough to put in the work, because everybody grew up living in a single room just like you. So it won't happen until somebody somewhere starts building it into software they didn't write, without asking for permission. We have to make it scalable to hack on unfamiliar codebases in incompatible ways.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-05T14:54:27.039Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-06-05T14:54:27.039Z" class="date">2021-06-05 14:54:27</a> <div class="message"><p>What I am hoping for as a first step is a change of attitude. Stop talking about escape hatches, start talking about bridges.</p>
<p>Yes, interoperability is hard, even more so if you want to retrofit it. So let's start with new environments, which is what many us in this space are working on or dreaming of.</p>
<p>It's actually happening. A nice example: <a href="https://github.com/JuliaInterop"></a><a href="https://github.com/JuliaInterop">https://github.com/JuliaInterop</a>. What I want is more of that. More effort for making systems interoperable.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/JuliaInterop">Julia Interop</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-05T15:55:56.039Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-06-05T15:55:56.039Z" class="date">2021-06-05 15:55:56</a> <div class="message"><p>That library looks like an example of my second option. That can certainly work! It becomes a problem more of social organization, learning about n black boxes, getting them to interoperate, opening issues. Submitting patches to n black boxes has some scaling issues for most people.</p>
<blockquote><p>let's start with new environments</p>
</blockquote>
<p>Did you mean new environments interoperating with existing ones? That still has scaling issues if you care about multiple existing ones.</p>
<p>New environments interoperating with other new ones = hard yes! If anyone cares.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-05T18:44:01.040Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-06-05T18:44:01.040Z" class="date">2021-06-05 18:44:01</a> <div class="message"><p>I think "new interoperating with existing ones" is the most reasonable starting point, because the new players have the highest motivation to connect to the "old world". As in the case of Julia. And yes, this has scaling issues. But if it leads to competitive advantages ("I picked Julia because it has all those nice bridges to other languages"), it can lead to the change of attitude that is needed.</p>
<p>All-to-all bridging without scaling issues requires infrastructure support, and then adoption of that infrastructure. The only attempt I am aware of is Oracle's GraalVM/Truffle combo. Which requires re-implementing all languages, but apparently makes this relatively straightforward for JVM languages.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-05T20:51:14.041Z" class="reply"><span class="user">Chris Knott</span> <a href="#2021-06-05T20:51:14.041Z" class="date">2021-06-05 20:51:14</a> <div class="message"><p>I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like. He was a language Cake which I haven't looked at but at first glance looks a bit like Cambria</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-05T22:33:17.041Z" class="reply"><span class="user">J. Ryan Stinnett</span> <a href="#2021-06-05T22:33:17.041Z" class="date">2021-06-05 22:33:17</a> <div class="message">
<blockquote><p>I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like.When I first read Stephen's paper, it was quite an eye-opening moment for me... üòÑ It pushed me to start a community to share and discuss ideas like this around user control and interoperability. Perhaps some other resources in the catalog there (<a href="https://malleable.systems/catalog/"></a><a href="https://malleable.systems/catalog/">https://malleable.systems/catalog/</a>) will be of interest as well.</p>
</blockquote>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://malleable.systems/catalog/">Catalog | Malleable Systems Collective</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-05T22:43:25.042Z" class="reply"><span class="user">J. Ryan Stinnett</span> <a href="#2021-06-05T22:43:25.042Z" class="date">2021-06-05 22:43:25</a> <div class="message"><p>There's a painful absence of tooling for the "integration domain" (as Stephen calls it) in software today. Such tools would connect and unify existing languages, ecosystems, and modules, just like the wires in circuit design: they unify parts from many different sources into something new without requiring coordination or agreement between the parts themselves.</p>
<p>If it were (on the order of) adding wires from module / language A to B, we'd see an explosion of software reuse. It should not matter what language some useful bit of code is written in, but unfortunately today, language boundaries create high walls.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T08:36:54.044Z" class="reply"><span class="user">William Taysom</span> <a href="#2021-06-06T08:36:54.044Z" class="date">2021-06-06 08:36:54</a> <div class="message"><p>To bridge to C, SWIG has served me well.  <a href="http://swig.org/"></a><a href="http://swig.org/">http://swig.org/</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-06-06T11:48:42.044Z" class="post"><span class="user">Mariano Guerra</span> <a href="#2021-06-06T11:48:42.044Z" class="date">2021-06-06 11:48:42</a> <div class="message"><p>How much intersection/overlap do you think there is between Future of Coding and Tools for Thought "movements"?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-06-06T13:16:32.045Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2021-06-06T13:16:32.045Z" class="date">2021-06-06 13:16:32</a> <div class="message"><p>Feels like quite a bit. Why?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T13:27:42.045Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-06-06T13:27:42.045Z" class="date">2021-06-06 13:27:42</a> <div class="message"><p>I was thinking how much computation is in tools of thought and how much knowledge management there is in future of coding</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T13:28:28.045Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-06-06T13:28:28.045Z" class="date">2021-06-06 13:28:28</a> <div class="message"><p>I think the intersection of both may be the most interesting part</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T14:24:35.048Z" class="reply"><span class="user">David Pomerenke</span> <a href="#2021-06-06T14:24:35.048Z" class="date">2021-06-06 14:24:35</a> <div class="message"><p>Yes! In my opinion development environments could be a lot more like Roam Research and the like: We have functions, each function references other functions and is referenced by other functions, thus shaping a graph of functions. So why not make this graph the structure of the environment, rather than some more or less arbitrary folders and files.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T15:45:43.049Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-06-06T15:45:43.049Z" class="date">2021-06-06 15:45:43</a> <div class="message"><p>This thread seems relevant (thanks <a href="https://twitter.com/stefanlesser">Stefan Lesser</a>): <a href="https://twitter.com/vgr/status/1401253631073034241"></a><a href="https://twitter.com/vgr/status/1401253631073034241">https://twitter.com/vgr/status/1401253631073034241</a></p>
</div> <div class="attachments">
<blockquote><p>üê¶ <a href="https://twitter.com/@vgr">Venkatesh Rao</a>: I once attended a talk about ‚Äúcoding kata.‚Äù I don‚Äôt think the idea ever took off. It works even worse with hardware. </p>
<p>Something about engineering seems to defy learning through abstract formal exercises of growing combinatorial complexity. Like music scales or kata. Wonder why.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-06T16:03:11.049Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2021-06-06T16:03:11.049Z" class="date">2021-06-06 16:03:11</a> <div class="message"><p>For me the future of programming is about making it simpler for everyone, especially people without technology backgrounds, to take advantage of computation and the powerful devices we carry around with us all the time.</p>
<p>I consider a tool for thought something that literally helps us think. Not attempting to do the thinking for us, or automate away thinking, but augmenting and enhancing our capabilities to understand, ideate, and explore. We stay in control, and our cognitive abilities are amplified.</p>
<p>After all, people who use tools like Roam Research are ‚Äújust‚Äù modeling certain parts of their individual thinking process and the tool gives them an environment to structure their thoughts in, which is remarkably similar to designing a data model, except that it requires much more flexibility and dynamism than what we computer people think of when we talk about a ‚Äúdata model‚Äù.</p>
<p>From that perspective the overlap is huge. I do acknowledge, however, that this is just a narrow definition of both tools for thought and the future of programming, and there are plenty of other areas to explore in both.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T16:45:07.051Z" class="reply"><span class="user">Christopher Galtenberg</span> <a href="#2021-06-06T16:45:07.051Z" class="date">2021-06-06 16:45:07</a> <div class="message"><p>I'd suspect both communities (FoC ToT) feel a nigh hopeless mess swirling in their head, and simultaneously a borderline New Age faith in breakthroughs that are available in that very same head ‚Äì if they could just locate a catalyst, a seed crystal</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T19:58:03.051Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2021-06-06T19:58:03.051Z" class="date">2021-06-06 19:58:03</a> <div class="message"><p>I don't know the Tools for Thoughts movement very well, but I guess that it can help improve programming activities which are still too often limited to raw text code editing, even if you can write some specification doc, with design and system architecture represented visually, etc. But as programming activity is - hmm - a thought process, it has to be improvable with better tools for thoughts.</p>
<p>So one can dream of a programming environment that provides tools for the "thinking" of the programming artifacts that are being created, and the way the thoughts are recorded/shown to be deeply connected to the actual programming artifacts.</p>
<p>I mean, when we start a new relatively complex project, we often start by discussing and thinking by drawing sketches on a whiteboard. Then we move to our computer writing code to bring the architecture/design to life. But the connection between the "thoughts artifacts" and the system is lost. Why not having tools that help us keep the too connected?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T21:56:19.052Z" class="reply"><span class="user">em</span> <a href="#2021-06-06T21:56:19.052Z" class="date">2021-06-06 21:56:19</a> <div class="message"><p>Is there a Tools for Thought community (slack, discord, etc.)? Seems a little more broadly spread out between different app communities like Roam etc.</p>
<p>The overlap is as pointed out substantial, but the approach of either side look like they start from different philosophies. Projects that show up in Future of Coding seem to emphasize tangible experimentation with the process of engineering, often from a bottom-up approach (i.e. what are the small composable pieces and the processes that construct them). On the other hand, Zettelkasten systems and other such approaches are more top-down, in the style of trying to understand or create a specification, and in general maneuvering in graph-like space of ideas rather than lower-level processes with causal chains.</p>
<p>Meeting in the middle is the natural next step, but I wonder where the emphasis should be placed. Are we missing an interface between thought and implementation, due to the tremendous difficulty of translation as pointed out by many already? Are the two sides not melded enough, or instead are they not well-separated enough? Is there a missing calculus of thought somewhere floating in this space? Would love to explore these areas with anyone interested, or hear about any other interesting endeavors along these lines.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T22:52:40.065Z" class="reply"><span class="user">Andrew F</span> <a href="#2021-06-06T22:52:40.065Z" class="date">2021-06-06 22:52:40</a> <div class="message"><p><a href="https://twitter.com/galtenberg">Christopher Galtenberg</a> I feel personally attacked. :D</p>
<p>But seriously, I agree the intersection is very large. To me, they're both fundamentally about representing (and manipulating) ideas in digital form. I've been thinking about them as different aspects of the same problem for a while now.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-06-06T13:38:42.046Z" class="post"><span class="user">Rob Haisfield</span> <a href="#2021-06-06T13:38:42.046Z" class="date">2021-06-06 13:38:42</a> <div class="message"><p>What do you gain from being able to run a program in reverse? Just looking at <a href="https://twitter.com/spiralganglion">Ivan Reese</a>‚Äôs Hest but curious more generally</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-06-06T14:33:48.049Z" class="reply"><span class="user">Chris Knott</span> <a href="#2021-06-06T14:33:48.049Z" class="date">2021-06-06 14:33:48</a> <div class="message"><p>You can go from a bug (or any effect), to it's cause</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-06T21:43:52.052Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-06-06T21:43:52.052Z" class="date">2021-06-06 21:43:52</a> <div class="message"><p>There's full-blown reverse execution, which is code that can run forwards and backwards. This is hard.</p>
<p>Then there's just rewind (as I call it), which is just capturing and restoring past program states. (This is what the game Braid does, and what I'm planning to do for Hest, and I believe what omniscient debuggers do, and what you can easily do with immutable data structures a la Elm's time-travel debugging.)</p>
<ul><li>Both would let you run some code, stop, rewind a bit, make some changes, go forward again, rewind again, make more changes, etc. It would give you a programming experience that's sort of like editing music in a DAW, or editing a video in a <a href="https://en.wikipedia.org/wiki/Non-linear_editing">nonlinear editor</a>.</li><li><strong>@William Taysom</strong> had a neat idea (hope this is okay to share) about using reverse execution as a way to start with some data in a desired final form, and to build backwards towards the inputs needed to get it in that form, interactively.</li><li>A difficult thing about pure reverse execution is that you can't have a function that would return the same result for two different inputs. For example, you can't have a function that does a multiply by zero (because you'd get the same result for any finite input). You need each input to uniquely map to an output. But ‚Äî and this is wild ‚Äî&nbsp;if you can achieve this property in hardware, reversible computers can be <a href="https://en.wikipedia.org/wiki/Reversible_computing#Reversibility">vastly more energy efficient</a> than non-reversible computers, because of thermodynamics: less information is being "lost", so there's less heat (entropy) as a result. (Vast simplification ‚Äî others here could probably summarize this better than me)</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-07T01:21:40.065Z" class="reply"><span class="user">William Taysom</span> <a href="#2021-06-07T01:21:40.065Z" class="date">2021-06-07 01:21:40</a> <div class="message"><p>Been summoned. üòà  Often a person wants to answer "how did this happen?"  Reverse execution is one way to go back, which suffers from having too much detail usually.  So it's good to take the, usually incorrect, "how can is this even possible" value and just follow its data-flow but with surrounding context because (1) you're probably looking for a control flow branch not taken and (2) the data-flow tree itself is liable to be extra bushy yet easily pruned.  In contrast, stepping forward has the problem that a lot of initialization/configuration happens, especially in framework code, which is noisy and mostly irrelevant.</p>
<p>And for pure reverse execution, the trick is to automatically lift functions so that they pass whatever data is necessary to run in reverse in a hidden channel.  In general <code>f' x = (f x, x)</code> works, but sometimes you can use shortcuts.  But then you might as well use checkpoints like most people do.  And the <code>f'</code> above isn't so useful since it's referentially transparent and the whole point is that you want to look inside <code>f</code>.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
