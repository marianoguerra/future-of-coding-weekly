
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2021-06-23T08:32:41.147Z" class="post"><span class="user">Nick Smith</span> <a href="#2021-06-23T08:32:41.147Z" class="date">2021-06-23 08:32:41</a> <div class="message"><p>All modern programming languages apart from Rust (and I guess Swift, with its reference-counting) rely on garbage collection: a "background thread" locates memory the process has forgotten about and marks it as available for re-use. However, this doesn't seem to be a sensible scheme in a distributed system where multiple processing devices each have local memories. That begs the question: if you want to design a programming language that can be transparently distributed over multiple devices, does it need to have a fancy type system (like Rust's) that enforces correct manual memory management?</p>
<p>One reason I'm thinking about this: most upcoming AI chips are using a "network-on-chip" architecture, which could also be called a "distributed system on a chip". A garbage collection algorithm on these chips would have to involve a message-passing protocol wherein different parts of the chip communicate to identify forgotten memory. This seems like an unnecessarily complicated and expensive approach to memory management.</p>
<p>Thoughts? ü¶Ñ</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-06-23T09:47:55.148Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2021-06-23T09:47:55.148Z" class="date">2021-06-23 09:47:55</a> <div class="message"><p>Like the sentiment and think Rust and Swift are on a better path, mainly because they manage memory deterministically, but if people don't find garbage collection wasteful today in basic single-threaded CPU-bound scenarios, I doubt it'll stop anybody from bringing it to a distributed environment.</p>
<p>Classic garbage collection makes a lot of sense for a simpler, centralized memory model, like a heap. I don't know how to adapt it to a massively parallel execution environment, but I'm sure it can be done somehow, likely involving an order-of-magnitude increase in (wasted) memory along the way, but it'll be much more convenient to use I'm sure.</p>
<p>I don't know much about "AI chips", but if they are optimizing for parallel execution and work anything like modern GPUs they probably already manage memory quite differently from CPUs with explicit descriptors (a form of type system), buffer hierarchies, and thread grouping with localized access to buffers. That way memory gets bound to certain computations (shaders) and freed once these computations are finished. Well, it's a little more complex as these are subdivided into workgroups, thread groups, and subgroups, but you'll get the idea.</p>
<p>If you squint your eyes you might see some parallels to Rust's ownership model and why deterministic memory management is so attractive, even in languages that mainly target CPUs. The future is more value (move/copy) and fewer reference semantics ("objects") with clear ownership to help avoid, or at least minimize, shared state, so we can reap the benefits of parallel processing. That's a promising approach to keep complexity in check, even though it might not quite feel like that yet when you're trying to configure a shader execution pipeline today.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-23T12:32:48.148Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-06-23T12:32:48.148Z" class="date">2021-06-23 12:32:48</a> <div class="message"><p>Pony's Garbage Collection sounds the closest I can think of: <a href="https://tutorial.ponylang.io/appendices/garbage-collection.html"></a><a href="https://tutorial.ponylang.io/appendices/garbage-collection.html">https://tutorial.ponylang.io/appendices/garbage-collection.html</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-23T12:34:23.148Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-06-23T12:34:23.148Z" class="date">2021-06-23 12:34:23</a> <div class="message"><p>There are some papers and talks about it</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-23T14:19:40.148Z" class="reply"><span class="user">Deech</span> <a href="#2021-06-23T14:19:40.148Z" class="date">2021-06-23 14:19:40</a> <div class="message"><p>Nim &amp; ATS do this as well.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-23T15:54:40.149Z" class="reply"><span class="user">William Taysom</span> <a href="#2021-06-23T15:54:40.149Z" class="date">2021-06-23 15:54:40</a> <div class="message"><p>In my limited (yet significant) experience making a distributed system, the challenge wasn't so much garbage as ferrying relevant partial results between compute nodes.  So an ownership model may match bandwidth constraints better than potentially costly deferences.</p>
<p>I guess it's an eager/lazy distinction.  I mean GC is certainly a performance win if you never need to actually collect it.  Granularity matters.  A lot of programs operate in a sort of loop with a lot of objects allocated per frame or per request.  So then it makes sense to have an allocator that only tracks when references cross the boundary.  Squint and you can think of that as an eager generational collector.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-23T18:30:08.149Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2021-06-23T18:30:08.149Z" class="date">2021-06-23 18:30:08</a> <div class="message"><p>I'm not sure I understand the problem‚Äîyou can have actor-local heaps and run gc independently while communicating via message-passing. Erlang does this</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-24T00:57:13.149Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-06-24T00:57:13.149Z" class="date">2021-06-24 00:57:13</a> <div class="message"><p><a href="https://git.sr.ht/~sm2n/">S.M Mukarram Nainar</a> That's a solution if your programming model is the actor model. By "transparent distribution" I mean something more implicit: your programming language doesn't have a means to talk about "nodes" and "messages", so there are no clear boundaries for a garbage collector.</p>
<p>Note that in Erlang, you essentially have automatic memory management (GC) within an actor, and manual memory management between actors. If you have an actor that is holding data that will later be queried by other actors, you need to know when it is safe to delete the data (or even the entire actor), i.e. you need to know when other actors are no longer holding "references" to it (of some kind).</p>
<p>It seems like Pony has an approach for inter-actor memory management. Thanks <a href="https://twitter.com/warianoguerra">Mariano Guerra</a> for the link. Though as I said before, the distribution model is still not quite as implicit as I had in mind üôÇ. I don't think you want to program a 1000-core AI chip with the actor model. ML models don't want to be written as actor systems, and general-purpose programs even less-so.</p>
<p>I'm bringing up AI chips because some of them will be capable of running general-purpose programs. Think of them as the next step beyond GPGPU. <a href="https://www.tenstorrent.com/">Tenstorrent</a> is an example. From their FAQ:</p>
<ul><li>"Our computers are optimized for neural network inference and training. They can also execute other types of parallel computation."</li><li>"Network communication hardware is present in each processor, and they talk with one another directly over (on-chip) networks, instead of through DRAM."</li><li>[Compared to GPUs] "Our computers are easier to program, scale better, and are excellent at handling run-time sparsity and conditional computation."</li></ul><p>Hopefully that answers your question <a href="https://twitter.com/stefanlesser">Stefan Lesser</a>: the programming model is very different to that of GPUs.</p>
<p>Note the irony that Tenstorrent's chips are an actor model at the hardware level, yet you're unlikely to want to program them using the actor model because of the sheer number of cores. What is our programming model for these machines? As stated in my original post, I think memory management needs to be explicit in the language (Rust-style), because you don't want all 1000+ cores to be running a distributed garbage collection scheme alongside the primary computation. It becomes less and less feasible the more cores you add. Tenstorrent is planning to have their chips plug directly together using high-bandwidth &amp; low-latency interconnects so that you can have 100,000 cores or more. Imagine running a garbage collector on that. Seems very much the wrong direction to go in.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-24T07:04:39.165Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2021-06-24T07:04:39.165Z" class="date">2021-06-24 07:04:39</a> <div class="message"><p><a href="https://twitter.com/NickSmit_">Nick Smith</a> Oh, interesting! Do you have any other pointers to more technical resources from them or about other ‚ÄúAI chips‚Äù? Their FAQ isn‚Äôt going very deep and the website strikes me as very marketing/VC oriented.</p>
<p>I don‚Äôt get the sense that their programming model is ‚Äúvery different‚Äù to that of GPUs, more like they‚Äôre building on top of that model, but maybe that‚Äôs what you mean? And they clearly know about what makes GPU programming complicated and try to differentiate themselves from it ‚Äî I‚Äôm vary of their marketing lingo‚Ä¶</p>
<p>As they mention PyTorch one way to leverage multiple independent units could be <a href="https://pytorch.org/docs/stable/notes/ddp.html"></a><a href="https://pytorch.org/docs/stable/notes/ddp.html">https://pytorch.org/docs/stable/notes/ddp.html</a>.</p>
<p>This also points towards things like <a href="https://mlir.llvm.org/"></a><a href="https://mlir.llvm.org/">https://mlir.llvm.org/</a>. In other words, more power to the compiler (and yes, fancy type systems)! :) </p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://mlir.llvm.org/">MLIR</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-24T13:33:46.166Z" class="reply"><span class="user">U025PBD75TM</span> <a href="#2021-06-24T13:33:46.166Z" class="date">2021-06-24 13:33:46</a> <div class="message"><p>Do you have an example application in mind? For instance if you want a generally responsive language, memory use efficiency, perhaps some convenience routines for objects going out of scope (e.g. automatic closing of file descriptors, sockets), predictable runtime and memory use, then reference counting seems like a better fit. OTOH:: scope exit becomes slower, and is potentially unbounded (imagine reclaiming a giant graph of data), overall runtime is higher because of all the accounting busywork and cpu cache disruption (can be as much as ~30% slower but it's complicated), and concurrency becomes harder: child processes will trigger copy on write (you can minimize the impact by storing the refcount in a small object header and storing all headers in a contiguous memory block), refcounts are also a contention issue for POSIX threads.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-24T14:42:03.167Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2021-06-24T14:42:03.167Z" class="date">2021-06-24 14:42:03</a> <div class="message"><p>You might want to read up on the various languages designed for the <a href="https://en.wikipedia.org/wiki/Thinking_Machines_Corporation">Thinking Machines</a> CM series, including *Lisp and CM Lisp. I worked on one of these with 768 cores, but the top models had 65,000+ cores running in a parallel machine with perfectly pleasant high level language support.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-24T22:59:14.167Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-06-24T22:59:14.167Z" class="date">2021-06-24 22:59:14</a> <div class="message"><p><a href="https://twitter.com/stefanlesser">Stefan Lesser</a> There are some interviews and videos of Tenstorrent online. Here's a recent one <a href="https://www.anandtech.com/show/16709/an-interview-with-tenstorrent-ceo-ljubisa-bajic-and-cto-jim-keller">with Anandtech</a>. Here's a long <a href="https://www.youtube.com/watch?v=G4hL5Om4IJ4">podcast episode with the CTO</a> where he talks about a bunch of computing-related stuff, including hardware architectures for AI. Here's <a href="https://www.youtube.com/watch?v=Uls3-UWm-sY">a short technical presentation</a> on how their chips work.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.anandtech.com/show/16709/an-interview-with-tenstorrent-ceo-ljubisa-bajic-and-cto-jim-keller">An Interview with Tenstorrent: CEO Ljubisa Bajic and CTO Jim Keller</a></p>
<p>üé• <a href="https://www.youtube.com/watch?v=G4hL5Om4IJ4">Jim Keller: The Future of Computing, AI, Life, and Consciousness | Lex Fridman Podcast #162</a></p>
<p>üé• <a href="https://www.youtube.com/watch?v=Uls3-UWm-sY">Tenstorrent: Relegating the Important Stuff to the Compiler</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-24T23:14:29.168Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-06-24T23:14:29.168Z" class="date">2021-06-24 23:14:29</a> <div class="message"><p><strong>@U025PBD75TM</strong> You're mentioning a lot of issues on conventional hardware architectures (cache and thread contention) and sure, there are some trade-offs when choosing between reference counting and tracing GCs in that context. But I'm focusing more on massively-parallel architectures, which I think changes the rules a bit. For example, Tenstorrent's chips have no shared memory, no caches, and no threads. Instead they have a grid of compute units, each with a dedicated SRAM (not a cache) and capable of doing parallel matrix/tensor operations. This is my "application" if you like: writing programs that can run on this type of machine. Why? Because they're going to offer up 100x the compute power of CPUs and are more suited to heterogeneous workloads than GPUs. From what I can see, they have a chance at obsoleting the whole idea of a CPU, as long as we can program them. There is insane amounts of money pouring into these companies (for their applications to AI), and some of these chips are going to become widely-deployed in data centers and (eventually) consumer devices.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-24T23:16:58.168Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-06-24T23:16:58.168Z" class="date">2021-06-24 23:16:58</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> I'll look them up, thank you üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-26T22:33:44.171Z" class="reply"><span class="user">Andrew Martin</span> <a href="#2021-06-26T22:33:44.171Z" class="date">2021-06-26 22:33:44</a> <div class="message"><p><a href="https://twitter.com/NickSmit_">Nick Smith</a> fyi the successor to Pony is a microsoft research project called "Project Verona". I think it's one of the most interesting research projects in the more traditional PL world right now. It might not be what you're looking for but I think the heap model it uses is a lot more generalised and flexible than the actor model.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-26T22:38:37.171Z" class="reply"><span class="user">Andrew Martin</span> <a href="#2021-06-26T22:38:37.171Z" class="date">2021-06-26 22:38:37</a> <div class="message"><p><a href="https://www.microsoft.com/en-us/research/project/project-verona/"></a><a href="https://www.microsoft.com/en-us/research/project/project-verona/">https://www.microsoft.com/en-us/research/project/project-verona/</a></p>
<p>there's not much information up yet, but i think there are some talks explaining the memory model a bit, if you're interested.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.microsoft.com/en-us/research/project/project-verona/">Project Verona - Microsoft Research</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-26T22:50:24.171Z" class="reply"><span class="user">Andrew Martin</span> <a href="#2021-06-26T22:50:24.171Z" class="date">2021-06-26 22:50:24</a> <div class="message"><p>in reference to your original question, I would say that both Pony and Verona have type systems that are comparable to Rust's in fanciness (they also rely on concepts like linearity), but they aim to find a sweet spot in usability by permitting a more free-form programming style within regions.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-06-24T13:31:07.166Z" class="post"><span class="user">Rob Haisfield</span> <a href="#2021-06-24T13:31:07.166Z" class="date">2021-06-24 13:31:07</a> <div class="message"><p>I keep hearing about how Common Lisp has insanely cool tooling but struggling to find examples. Anyone have any links?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-06-24T14:02:12.167Z" class="reply"><span class="user">Haakon HR</span> <a href="#2021-06-24T14:02:12.167Z" class="date">2021-06-24 14:02:12</a> <div class="message"><p>SLY (<a href="https://github.com/joaotavora/sly"></a><a href="https://github.com/joaotavora/sly">https://github.com/joaotavora/sly</a>) and SLIME is a good place to start. I played around a bit with SLY last year and it has some pretty cool features such as stickers</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/joaotavora/sly">joaotavora/sly</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-25T03:12:30.168Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="#2021-06-25T03:12:30.168Z" class="date">2021-06-25 03:12:30</a> <div class="message"><p>I would suggest looking at 3 lisp IDEs:</p>
<p>a) Lispworks (very well integrated set of tools)</p>
<p>b) emacs + slime (contains <em>everything</em>, see, esp. org-mode)</p>
<p>c) Racket</p>
<p>Then, you need to know what it is that you want to accomplish: [+]</p>
<p>1) rapid prototyping, or,</p>
<p>2) compilation.</p>
<p>Early lisps emphasized 1, CL emphasizes 2 but has more 1 than most languages (see, for example, restarts).</p>
<p>[Asides: Debugging is easier when the debugger language is the same as the language being debugged.  Debugging is facilitated when a language has no syntax and is expression-based. Debugging is facilitated when the debugger and the language being debugged are the same thing.]</p>
<p><a href="http://www.lispworks.com/products/index.html"></a><a href="http://www.lispworks.com/products/index.html">http://www.lispworks.com/products/index.html</a></p>
<p><a href="https://orgmode.org/"></a><a href="https://orgmode.org/">https://orgmode.org/</a></p>
<p><a href="https://racket-lang.org/"></a><a href="https://racket-lang.org/">https://racket-lang.org/</a></p>
<p>[+] I contend that you don‚Äôt want both at once.  [IMO, 1 and 2 are different views on 0 (The Solution/Design)].</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://orgmode.org/">Org Mode</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-25T14:53:24.169Z" class="reply"><span class="user">Chris Maughan</span> <a href="#2021-06-25T14:53:24.169Z" class="date">2021-06-25 14:53:24</a> <div class="message"><p><a href="https://github.com/vlime/vlime"></a><a href="https://github.com/vlime/vlime">https://github.com/vlime/vlime</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/vlime/vlime">vlime/vlime</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-06-25T14:53:37.169Z" class="reply"><span class="user">Chris Maughan</span> <a href="#2021-06-25T14:53:37.169Z" class="date">2021-06-25 14:53:37</a> <div class="message"><p>I haven't tried this one yet; but I've been meaning to....</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-06-26T14:20:27.170Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2021-06-26T14:20:27.170Z" class="date">2021-06-26 14:20:27</a> <div class="message"><p>Seconding SLY, I use it every day. It is great. Another interesting piece of software is clouseau: <a href="https://www.youtube.com/watch?v=-1LzFxTbU9E"></a><a href="https://www.youtube.com/watch?v=-1LzFxTbU9E">https://www.youtube.com/watch?v=-1LzFxTbU9E</a></p>
<p>I actually don't think the tooling for CL is all that great, as a user of the language. Most of the interesting workflows, etc that you can do aren't so much provided by tooling as augmented by tooling. More or less all the functionality exposed by stuff like SLY (including the debugger) is part of the base language standard. And I think that's the really interesting part about CL if you're trying to learn from it.</p>
<p>In particular, CL is designed as a whole to support interactive workflows, there's no one design decision you can point to here, but the combination of how it is image-based, the package system, use of late-binding, the ability to have dynamic binding, all work together to make it possible. It would be quite difficult to replicate what CL does without any one of those things. (Though it seems like clojure has managed to to some extent? I haven't used it so I don't know)</p>
<p>Take the example of editing your code while it's running: a common workflow when working with event driven code (a webserver, game, etc) is to have the event loop running, and then recompile event handlers as you change them so that you can mould the program on the fly. For that to be possible you need to be able to patch out the function calls in the old code to point to new code, and the CL runtime supports this, since it's runtime is image-based‚Äîall functions work this way, any file related metadata is incidental.</p>
<p>Another example is post-mortem debugging. I actually learnt this term from a C programmer, and it's considered a pretty esoteric technique. Debugging coredumps after your program crashes. In CL, this workflow doesn't warrant a term because that is just how everyone writes code‚Äîyou let your program fail, it drops into the debugger, and then you fix the issue and move on. In particular the conditions and restarts system In addition to the ability to recompile stuff on the fly is necessary here, and the former is implemented with dynamically bound (so-called "special") variables.</p>
<p>As a final note, while I said the tooling in CL isn't all that amazing, I meant that in absolute terms. I would say it's about par with other ecosystems that have put work into tooling. The interesting thing is that CL tooling is mostly (entirely?) hobby projects, whereas for example, stuff like asan, dtrace, or rr that let you replicate these workflows in other languages are multimillion dollar projects. So CL lets people be very productive when building tooling around the language, because it provides the tools to build tooling.</p>
<p>If you're interested in what the debugger workflow looks like, this is a good series walking through it: <a href="https://malisper.me/debugging-lisp-part-1-recompilation/"></a><a href="https://malisper.me/debugging-lisp-part-1-recompilation/">https://malisper.me/debugging-lisp-part-1-recompilation/</a></p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=-1LzFxTbU9E">Clouseau - The McCLIM inspector - Online Lisp Meeting #6, 05.08.2020</a></p>
<p>üîó <a href="https://malisper.me/debugging-lisp-part-1-recompilation/">Debugging Lisp Part 1: Recompilation - malisper.me</a></p>
</blockquote>
</div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
