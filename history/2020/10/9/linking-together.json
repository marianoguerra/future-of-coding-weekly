[
    {
        "client_msg_id": "C0101179-89A0-41C4-9358-E8DB400E768B",
        "type": "message",
        "text": "I don’t have the background to know if this is well done (or even a good idea), but I simply love the intent behind this a “monospaced font for scientific and technical computing”.\n<https:\/\/juliamono.netlify.app\/|https:\/\/juliamono.netlify.app\/>",
        "user": "UE0ETTCG7",
        "ts": "1602279660.070200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8d5fa305f272",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-24\/1392332871012_8d5fa305f272f9d0c9e3_72.jpg",
            "first_name": "Roben",
            "real_name": "Roben Kleene",
            "display_name": "robenkleene",
            "team": "T5TCAFTA9",
            "name": "services",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0GY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don’t have the background to know if this is well done (or even a good idea), but I simply love the intent behind this a “monospaced font for scientific and technical computing”.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/juliamono.netlify.app\/",
                                "text": "https:\/\/juliamono.netlify.app\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602279660.070200",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1602324572.070900",
        "reply_users": [
            "UG0EL18H3",
            "UJBAJNFLK"
        ],
        "replies": [
            {
                "user": "UG0EL18H3",
                "ts": "1602281819.070300"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1602324572.070900"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "sunglasses",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UML4ZEKDK",
                    "UD6EXQVM0"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "73831c45-dea6-419f-81b0-68fee6924dd1",
        "type": "message",
        "text": "This seems interesting! As someone who has always had trouble “lining up” equations from books and papers with software implementations, having symbols like this would make it slightly less painful to verify the correctness of an implementation (assuming you understand what a particular symbol means in the context of your domain model). However, this might also be useful for folks who have to read code from domains with which they are unfamiliar. In that context, an interesting language feature might be to allow the use of stylized single-character names, with the caveat that you can only use them as “aliases” for existing names (I’m imagining <https:\/\/github.com\/JuliaArrays\/StaticArrays.jl\/issues\/537#issuecomment-439863841|this code snippet> but with the ability to hover over all the identifiers and see their definition: what does ℳʹ _mean_, for example, or Λ₂?). Perhaps you could also import “commonly-used” symbol definitions from a particular field: for instance `import quantum-mechanics` might include _h_ (Planck’s constant), and _Ψ_ (representing a wave function), and so on...",
        "user": "UG0EL18H3",
        "ts": "1602281819.070300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "25cc47143833",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-08-01\/702360681283_25cc471438337c72e600_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Rabl",
            "display_name": "crabl",
            "team": "T5TCAFTA9",
            "name": "chris.rabl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "Certain `SArray` * `Adjoint(SArray)` produces `Array{Float64,2}` instead of `SArray` · Issue #537 · JuliaArrays\/StaticArrays.jl",
                "title_link": "https:\/\/github.com\/JuliaArrays\/StaticArrays.jl\/issues\/537#issuecomment-439863841",
                "text": "A product of two StaticArrays results in an allocated array. Here is a minimal working example: A = @SMatrix rand(9,1) B = SArray{Tuple{9},Float64,1,9}(1,2,3,4,5,6,7,8,9) C = adjoint(B) D = A*C typ...",
                "fallback": "GitHub: Certain `SArray` * `Adjoint(SArray)` produces `Array{Float64,2}` instead of `SArray` · Issue #537 · JuliaArrays\/StaticArrays.jl",
                "thumb_url": "https:\/\/avatars2.githubusercontent.com\/u\/21312771?s=400&v=4",
                "from_url": "https:\/\/github.com\/JuliaArrays\/StaticArrays.jl\/issues\/537#issuecomment-439863841",
                "thumb_width": 300,
                "thumb_height": 300,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/JuliaArrays\/StaticArrays.jl\/issues\/537#issuecomment-439863841"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ohn1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This seems interesting! As someone who has always had trouble “lining up” equations from books and papers with software implementations, having symbols like this would make it slightly less painful to verify the correctness of an implementation (assuming you understand what a particular symbol means in the context of your domain model). However, this might also be useful for folks who have to read code from domains with which they are unfamiliar. In that context, an interesting language feature might be to allow the use of stylized single-character names, with the caveat that you can only use them as “aliases” for existing names (I’m imagining "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/JuliaArrays\/StaticArrays.jl\/issues\/537#issuecomment-439863841",
                                "text": "this code snippet"
                            },
                            {
                                "type": "text",
                                "text": " but with the ability to hover over all the identifiers and see their definition: what does ℳʹ "
                            },
                            {
                                "type": "text",
                                "text": "mean",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", for example, or Λ₂?). Perhaps you could also import “commonly-used” symbol definitions from a particular field: for instance "
                            },
                            {
                                "type": "text",
                                "text": "import quantum-mechanics",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " might include "
                            },
                            {
                                "type": "text",
                                "text": "h",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (Planck’s constant), and "
                            },
                            {
                                "type": "text",
                                "text": "Ψ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (representing a wave function), and so on..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602279660.070200",
        "parent_user_id": "UE0ETTCG7"
    }
]