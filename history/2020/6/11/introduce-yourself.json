[
    {
        "client_msg_id": "1e64a174-0c6e-4c3f-8ebb-753cde6905b5",
        "type": "message",
        "text": "Not exactly paper, but I've enjoyed watching recently  a lecture by Gregor Kiczales on \"<https:\/\/www.youtube.com\/watch?v=5l2wMgm7ZOk|Why Black Boxes are so Hard to Reuse>\". Totally different experience compared to modern tech talks.\nThe idea of having mapping dilemmas and doing base\/meta separation are good ones.",
        "user": "U012XRK1371",
        "ts": "1591874167.285400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b41664c53742",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-11\/1191441878993_b41664c53742c6ce01ab_72.jpg",
            "first_name": "",
            "real_name": "Andrew Sernyak",
            "display_name": "Andrew Sernyak",
            "team": "T5TCAFTA9",
            "name": "ndrew.sernyak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "Why Black Boxes are so Hard to Reuse, lecture by Gregor Kiczales",
                "title_link": "https:\/\/www.youtube.com\/watch?v=5l2wMgm7ZOk",
                "author_name": "Computer History Museum",
                "author_link": "https:\/\/www.youtube.com\/user\/ComputerHistory",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/5l2wMgm7ZOk\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Why Black Boxes are so Hard to Reuse, lecture by Gregor Kiczales",
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https:\/\/www.youtube.com\/embed\/5l2wMgm7ZOk?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "from_url": "https:\/\/www.youtube.com\/watch?v=5l2wMgm7ZOk",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=5l2wMgm7ZOk"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3b5qD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not exactly paper, but I've enjoyed watching recently  a lecture by Gregor Kiczales on \""
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=5l2wMgm7ZOk",
                                "text": "Why Black Boxes are so Hard to Reuse"
                            },
                            {
                                "type": "text",
                                "text": "\". Totally different experience compared to modern tech talks.\nThe idea of having mapping dilemmas and doing base\/meta separation are good ones."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591724889.278500",
        "parent_user_id": "U012XRK1371"
    },
    {
        "client_msg_id": "194d2352-ef55-476d-9b1b-dec954b6ed5b",
        "type": "message",
        "text": "Cool video, I really liked it! thanks for sharing it",
        "user": "U85HCL7JP",
        "ts": "1591914936.285900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SX0u5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Cool video, I really liked it! thanks for sharing it"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591724889.278500",
        "parent_user_id": "U012XRK1371"
    },
    {
        "client_msg_id": "815c680e-b90a-416a-a6d2-8d0fe503c72e",
        "type": "message",
        "text": "Just to circle back here, <@U015902ESJC>: even though I suggested the name uCISC, I would recommend not identifying with one side of the CISC vs RISC debate. So take out the defense of CISC in places like <https:\/\/github.com\/grokthis\/ucisc\/blob\/master\/docs\/02_Design_Goals.md>. In the end the goal is a good design, not being ideologically consistent. These ideological categories are part of the map, not the territory. They're mostly in our heads and can keep us from seeing reality clearly.",
        "user": "UCUSW7WVD",
        "ts": "1591945185.286100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "fallback": "[grokthis\/ucisc] docs\/02_Design_Goals.md",
                "text": "```\n## Design Goals\n\nWith a few exceptions, these design goals have mostly been around since the\nbeginning of my hobby to build a processor from scratch. However, as the endeavor\nbecame more serious and I learned more about retro computing, computer\narchitectures and the current state of hobby electronics, I have refined them a\ngreat deal.\n\nThe examples below are given in uCISC syntax since it is more readable than\nthe binary instruction format. See the [syntax chapter](\/03_Syntax.md) for more\ndetails. If you want to read through here first, just not that the examples\nmake verbose use of inline comments which are between slashes:\n\n```\n# This is a line comment\n... \/this is an inline comment\/ ...\n# Comments are removed before compliation and have no bearing on the result\n```\n\n#### Maximum Micro\n\nThe instruction set should be as small as possible. Initially, the aim was\nan 8-bit architecture, but in the end, that was too limiting. I tried really\nhard for a long time to stay at 8-bits, but a number of issues cropped up.\n\n* The space for immediate values was too small, 16-bit uCISC only has space\n  for 6 signed bits as it is, so you can imagine trying to fit it in 8-bits.\n* I didn't want to compromise on constant space and time (see below) and allow\n  variable byte width instructions.\n* The 16-bit address space is the minimum I could imagine to be useful for even\n  a hobby computer (256 addresses in an 8-bit space seemed small to me). In the\n  end 16-bit address space and 16-bit instructions has huge hardware benefits\n  since addresses and instructions can fit in the same registers, bus width, etc.\n\nAll instructions, therefore, should be 16-bits wide including the immediate\nvalue. Variable instruction widths are not allowed.\n\n#### Memory Based System\n\nuCISC comes firmly down on the side of CISC and is opinionated that memory is\nthe primary thing being manipulated. Registers are used only because it makes\nthe instructions easier to implement in hardware in many respects. RISC\narchitectures aim to \"reduce\" the amount of work a processor does on each\ninstructions. The\n[Wikipedia article on RISC](<https:\/\/en.wikipedia.org\/wiki\/Reduced_instruction_set_computer>)\nputs it like this:\n\n&gt; A common misunderstanding of the phrase \"reduced instruction set computer\" is\n&gt; the mistaken idea that instructions are simply eliminated, resulting in a smaller\n&gt; set of instructions. In fact, over the years, RISC instruction sets have grown in\n&gt; size, and today many of them have a larger set of instructions than many CISC CPUs.\n&gt; Some RISC processors such as the PowerPC have instruction sets as large as the CISC\n&gt; IBM System\/370, for example; conversely, the DEC PDP-8—clearly a CISC CPU because\n&gt; many of its instructions involve multiple memory accesses—has only 8 basic\n&gt; instructions and a few extended instructions.\n&gt;\n&gt; The term \"reduced\" in that phrase was intended to describe the fact that the amount\n&gt; of work any single instruction accomplishes is reduced—at most a single data memory\n&gt; cycle—compared to the \"complex instructions\" of CISC CPUs that may require dozens of\n&gt; data memory cycles in order to execute a single instruction. In particular, RISC\n&gt; processors typically have separate instructions for I\/O and data processing.\n&gt;\n&gt; The term load\/store architecture is sometimes preferred.\n\nIn other words, RISC based systems copy values to registers and manipulate them there,\nwhereas CISC usually more directly manipulates memory instead. uCISC typically does\nup to four memory accesses per instruction:\n\n* Read the instruction from the PC\n* Read the value at the source memory location\n* Read the value at the target memory location\n* Write the result value to the target memory location\n\nProcessors that implement the uCISC instruction set are required to do all of these in\nconstant time execution (see below) with only a few exceptions. The example\nimplementations do all of this in a single clock cycle. For details on how this works\nread the memory design documentation (coming soon).\n\n#### Maximum Value\n\nThe instruction set should pack as much value as possible in the limited space.\nThis means that clever tricks are used to get double use of instructions. Humans\nare clever beings that can wield powerful tools in creative ways. It makes the\nlearning curve a bit higher, but the payoff is big.\n\nFor example, uCISC doesn't have jump instructions. A copy or ALU instruction will\ndo just fine if the resulting value is stored in the program counter. You can do\nquite a lot by just varying the arguments.\n\n```\n# Do a relative jump by adding a displacement value to the program counter\n0\/copy\/ 0.reg\/from pc\/ Entry.disp\/displacement to Entry label\/ 0.reg\/into pc\/\n\n# Absolute jumps are also possible\n0\/copy\/ 4.imm\/from immediate\/ Entry.imm\/absolute offset to Entry\/ 0.reg\/into pc\/\n```\n\nAnother example of packing more value into less space is the \"halt\" instruction.\nSince copying the value to the PC to itself with no offset will result in an\ninfinite loop, this particular combindation is treated as the \"halt\" instruction.\nAs an added benifit of the instruction set setup, you actually get conditional\nhalts by manipulating the effect argument.\n\n```\n# All of these instructions look at the flags set by the last ALU operation.\n# So you do some math, comparisons, etc. and check the result.\n\n# halt instruction (3.eff\/always store\/ is inferred here)\n0\/copy\/ 0.reg\/from pc\/ 0.imm\/zero offset\/ 0.reg\/into pc\/\n\n# halt if zero\n0\/copy\/ 0.reg\/from pc\/ 0.imm\/zero offset\/ 0.reg\/into pc\/ 0.eff\/if zero\/\n\n# halt if NOT zero\n0\/copy\/ 0.reg\/from pc\/ 0.imm\/zero offset\/ 0.reg\/into pc\/ 1.eff\/if not zero\/\n\n# halt if positive\n0\/copy\/ 0.reg\/from pc\/ 0.imm\/zero offset\/ 0.reg\/into pc\/ 2.eff\/if positive\/\n```\n\n#### Constant Time Peformance\n\nAll instructions should execute in a consistent time on a processor. There are\na few cases where this is not possible (e.g. page to\/from main memory), but\nthese should be rare. This implies consistent instruction size, roughly equivalent\ninstruction computation time, etc. A lot of effort has been made to make the\ninstructions have roughly the same flavor even across different types.\n\nFor example, ALU and Copy instructions feel roughly the same, even if there is\nsome variance in bit widths or semantics on a few arguments based on the context\nof a copy verses an ALU operion. Notably, ALU operations have no immediate value\ndue to space constraints.\n\n```\n# Jump relative instruction\n0\/copy\/ 0.reg\/from pc\/ 6.imm 0.reg\/into pc\/\n\n# Jump relative with ALU instead\n# First, store 6 into a register (r3 in this cas)\n0\/copy\/ 4.imm 6.imm\/immediate value 6\/ 7.reg\/into r3\/\n# Then, add r3 to PC\n20A\/add\/ 7.reg\/r3\/ 0.reg\/to pc and store in pc\/\n\n# Jump relative with ALU, this time with value off the stack\n# May be useful for longer jumps that won't fit in an immediate\n20A\/add\/ 1.mem\/value on stack\/ 0.reg\/to pc and store in pc\/\n```\n\nAchieving constant time performance also typically means there are very few forms\nof caching allowed since cache misses necessarily produce longer execution times.\n\nSome exceptions being considered:\n - Memory paging. Steps should be taken to ensure minimal variability in access,\n   but accessing any shared resource will involve contention.\n - Device access, which is implemented through memory paging mechanics.\n - Page locks. Locking\/unlocking pages involves accessing a shared resource.\n\nNote: It is possible for a system to have page addresses that are any multiple of\n16-bits. In this case, software will have to be recompiled as stack and memory\noffsets will be different, but it doesn't fundamentally change the instruction set.\nRegardless, the hardware must still conform to the constant time execution, which\nimplies a wider memory lookahead in the processor internals.\n\n#### Easy to Implement in Hardware\n\nEasy to implement is such a vague measure. More or less this means it should be\nimplementable on an FPGA by a hobbyist. Since I am a electro…",
                "title": "docs\/02_Design_Goals.md",
                "footer": "<https:\/\/github.com\/grokthis\/ucisc|grokthis\/ucisc>",
                "id": 1,
                "title_link": "https:\/\/github.com\/grokthis\/ucisc\/blob\/master\/docs\/02_Design_Goals.md",
                "footer_icon": "https:\/\/github.githubassets.com\/favicon.ico",
                "color": "24292f",
                "mrkdwn_in": [
                    "text"
                ],
                "bot_id": "B011KHY4N3Y",
                "app_unfurl_url": "https:\/\/github.com\/grokthis\/ucisc\/blob\/master\/docs\/02_Design_Goals.md",
                "is_app_unfurl": true
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XhY7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Just to circle back here, "
                            },
                            {
                                "type": "user",
                                "user_id": "U015902ESJC"
                            },
                            {
                                "type": "text",
                                "text": ": even though I suggested the name uCISC, I would recommend not identifying with one side of the CISC vs RISC debate. So take out the defense of CISC in places like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/grokthis\/ucisc\/blob\/master\/docs\/02_Design_Goals.md"
                            },
                            {
                                "type": "text",
                                "text": ". In the end the goal is a good design, not being ideologically consistent. These ideological categories are part of the map, not the territory. They're mostly in our heads and can keep us from seeing reality clearly."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590881147.261300",
        "parent_user_id": "U015902ESJC",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJN1TAYEQ"
                ],
                "count": 1
            }
        ]
    }
]