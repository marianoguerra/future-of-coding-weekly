[
    {
        "client_msg_id": "ff450c6f-fe49-4f31-ab42-11baa2f1f56d",
        "type": "message",
        "text": "<@UC2A2ARPT> can you elaborate on what you mean by \"stroked straight line\"?",
        "user": "UCUSW7WVD",
        "ts": "1586245567.004200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FYsTQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " can you elaborate on what you mean by \"stroked straight line\"?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "0f410737-dceb-4504-a1a5-bf7f1b0bdfa6",
        "type": "message",
        "text": "<@UCUSW7WVD> See here <https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/SVG\/Tutorial\/Fills_and_Strokes>",
        "user": "UUQ2EQW21",
        "ts": "1586247058.004400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1586247062.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oB1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " See here "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/SVG\/Tutorial\/Fills_and_Strokes"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "02360dda-ef30-4b1c-acee-9c247f9866fc",
        "type": "message",
        "text": "At least, I assume that's what he means - the library I referenced draws SVG primitives like this.",
        "user": "UUQ2EQW21",
        "ts": "1586247082.004800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1586247092.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ggFYH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At least, I assume that's what he means - the library I referenced draws SVG primitives like this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6A604763-DC8E-4289-A33B-473152493FB5",
        "type": "message",
        "text": "Yeah, the \"line\" or \"path\" refers to the geometry, and the \"stroke\" is how it is rendered. When stroking a line, you generally want control over the stroke thickness and color at a minimum. Lots of features beyond that, but that's the basics.",
        "user": "UC2A2ARPT",
        "ts": "1586266807.009900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1586267804.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lda",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, the \"line\" or \"path\" refers to the geometry, and the \"stroke\" is how it is rendered. When stroking a line, you generally want control over the stroke thickness and color at a minimum. Lots of features beyond that, but that's the basics."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "17f97b49-08b6-4d6b-8681-c58d470e42b2",
        "type": "message",
        "text": "Nanovg requires OpenGL. Doesn't that conflict with the \"no dependencies\" requirement of the Mu project? If the goal is to be able to program all the way down to the bare metal, then I think you would want to standardize on a single GPU architecture, and program it directly. Just as you have standardized on x86. Or don't support a GPU, and instead interface directly to a frame buffer.",
        "user": "UJN1TAYEQ",
        "ts": "1586279479.010400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ih7w4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nanovg requires OpenGL. Doesn't that conflict with the \"no dependencies\" requirement of the Mu project? If the goal is to be able to program all the way down to the bare metal, then I think you would want to standardize on a single GPU architecture, and program it directly. Just as you have standardized on x86. Or don't support a GPU, and instead interface directly to a frame buffer."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UNCP67JSK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "7944b2d5-56fd-40d1-b867-4656399e0611",
        "type": "message",
        "text": "Yeah, my current plan is to focus on just a frame buffer. Mu currently can boot up a disk image with the hobbyist OS Soso (<https:\/\/github.com\/ozkl\/soso>) in addition to Linux. Soso is much tinier so reduces my dependency on C. It's also graphical from the ground up, where I haven't really managed to compile a Linux kernel with graphics yet. On the other hand it doesn't have a network stack...\n\nI interpreted the nanovg suggestion as something to crib from, and it's extremely useful in that respect. Even though I minimize dependencies I don't want to rethink everything from scratch. (For example, Mu's support for bootable disk images comes from digging into and cribbing from the Minimal Linux project at <http:\/\/minimal.linux-bg.org>.) Regardless of dependencies, tiny projects that can teach how something works are _gold_.",
        "user": "UCUSW7WVD",
        "ts": "1586279868.010600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "ozkl\/soso",
                "title_link": "https:\/\/github.com\/ozkl\/soso",
                "text": "A Simple Unix-like operating system. Contribute to ozkl\/soso development by creating an account on GitHub.",
                "fallback": "GitHub: ozkl\/soso",
                "thumb_url": "https:\/\/avatars2.githubusercontent.com\/u\/27739662?s=400&v=4",
                "from_url": "https:\/\/github.com\/ozkl\/soso",
                "thumb_width": 256,
                "thumb_height": 256,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/ozkl\/soso"
            },
            {
                "title": "Minimal Linux Live",
                "title_link": "http:\/\/minimal.linux-bg.org\/",
                "text": "Minimal Linux Live",
                "fallback": "Minimal Linux Live",
                "from_url": "http:\/\/minimal.linux-bg.org\/",
                "service_icon": "http:\/\/minimal.linux-bg.org\/assets\/img\/favicon.ico",
                "service_name": "minimal.linux-bg.org",
                "id": 2,
                "original_url": "http:\/\/minimal.linux-bg.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IoDT3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, my current plan is to focus on just a frame buffer. Mu currently can boot up a disk image with the hobbyist OS Soso ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/ozkl\/soso"
                            },
                            {
                                "type": "text",
                                "text": ") in addition to Linux. Soso is much tinier so reduces my dependency on C. It's also graphical from the ground up, where I haven't really managed to compile a Linux kernel with graphics yet. On the other hand it doesn't have a network stack...\n\nI interpreted the nanovg suggestion as something to crib from, and it's extremely useful in that respect. Even though I minimize dependencies I don't want to rethink everything from scratch. (For example, Mu's support for bootable disk images comes from digging into and cribbing from the Minimal Linux project at "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/minimal.linux-bg.org"
                            },
                            {
                                "type": "text",
                                "text": ".) Regardless of dependencies, tiny projects that can teach how something works are "
                            },
                            {
                                "type": "text",
                                "text": "gold",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "32165dfa-7518-4537-83bb-e4291f2ef2d3",
        "type": "message",
        "text": "Another way to put it: Mu burns everything to the ground _in production_. Mainstream software is good for prototypes (<https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1586116575146400?thread_ts=1586108832.143700&amp;cid=C5T9GPWFL>) and prototypes are very useful in staging environments.",
        "user": "UCUSW7WVD",
        "ts": "1586280000.010900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1586280029.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "b3v1\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another way to put it: Mu burns everything to the ground "
                            },
                            {
                                "type": "text",
                                "text": "in production",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Mainstream software is good for prototypes ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1586116575146400?thread_ts=1586108832.143700&cid=C5T9GPWFL"
                            },
                            {
                                "type": "text",
                                "text": ") and prototypes are very useful in staging environments."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bf2087ca-37a8-4733-8821-0f139b85baea",
        "type": "message",
        "text": "I actually like a lot of the OpenGL interface, from what I've seen of it. I'd be happy to implement some subset of it. Unless someone convinces me it sucks..",
        "user": "UCUSW7WVD",
        "ts": "1586280316.011300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Ety=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I actually like a lot of the OpenGL interface, from what I've seen of it. I'd be happy to implement some subset of it. Unless someone convinces me it sucks.."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "d1e1543f-0960-4c76-8be3-2271c52950e6",
        "type": "message",
        "text": "The <https:\/\/libre-soc.org\/> project aims to produce an open source CPU + GPU. The GPU is integrated with the CPU: it's just an extension to the instruction set architecture, rather than being a coprocessor. This means that programming this GPU on the bare metal will be orders of magnitude simpler than a typical GPU. Hypothetically, when the project is finally finished and the hardware is available, it would be a good platform for a program-on-the-bare-metal type of software project.",
        "user": "UJN1TAYEQ",
        "ts": "1586280654.011500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hZB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/libre-soc.org\/"
                            },
                            {
                                "type": "text",
                                "text": " project aims to produce an open source CPU + GPU. The GPU is integrated with the CPU: it's just an extension to the instruction set architecture, rather than being a coprocessor. This means that programming this GPU on the bare metal will be orders of magnitude simpler than a typical GPU. Hypothetically, when the project is finally finished and the hardware is available, it would be a good platform for a program-on-the-bare-metal type of software project."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UNCP67JSK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "8aa61e1b-dce2-4aec-ad58-aaafbfd4b7e0",
        "type": "message",
        "text": "The reason to implement OpenGL is for porting legacy software. I am not a fan: I think the API is overly complex and clumsy.\n\nOpenGL is stuck forever at version 4.6 and everybody has moved on. The new cross-platform GPU API is WebGPU (which is still under development, although working prototypes exist). Vulkan also purports to be cross-platform, but Vulkan will never be available in a web browser. Vulkan is not nice to use (1000 lines of code to draw a triangle) while WebGPU has a pleasant to use and modern C, Rust and Javascript interface. WebGPU will be a native API on all desktop and mobile platforms, it will be available in web browsers via Javascript, and it will be the native GPU API for Web Assembly.\n\nSo WebGPU is the future and OpenGL is the past.",
        "user": "UJN1TAYEQ",
        "ts": "1586282702.011900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hJb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason to implement OpenGL is for porting legacy software. I am not a fan: I think the API is overly complex and clumsy.\n\nOpenGL is stuck forever at version 4.6 and everybody has moved on. The new cross-platform GPU API is WebGPU (which is still under development, although working prototypes exist). Vulkan also purports to be cross-platform, but Vulkan will never be available in a web browser. Vulkan is not nice to use (1000 lines of code to draw a triangle) while WebGPU has a pleasant to use and modern C, Rust and Javascript interface. WebGPU will be a native API on all desktop and mobile platforms, it will be available in web browsers via Javascript, and it will be the native GPU API for Web Assembly.\n\nSo WebGPU is the future and OpenGL is the past."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UDQBTJ211"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a8839aa4-8913-432e-b81a-98dec6500727",
        "type": "message",
        "text": "The advantage of GL is that it is pretty much available everywhere.  As you say, Vulkan is difficult for beginners (and advanced users :slightly_smiling_face: ).",
        "user": "UUQ2EQW21",
        "ts": "1586282890.012100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3V4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The advantage of GL is that it is pretty much available everywhere.  As you say, Vulkan is difficult for beginners (and advanced users "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " )."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UBSMEUXAA"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0e0aeb64-b151-49bf-a472-9a1c554ad120",
        "type": "message",
        "text": "If you just have a framebuffer, you could think of something like this; a software-based renderer: <https:\/\/github.com\/zauonlok\/renderer>",
        "user": "UUQ2EQW21",
        "ts": "1586282914.012300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1586282920.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bX9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you just have a framebuffer, you could think of something like this; a software-based renderer: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/zauonlok\/renderer"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "9c74e645-b57a-46cc-ad96-6ad275f2dd20",
        "type": "message",
        "text": "<https:\/\/github.com\/ssloy\/tinyrenderer> - or this simpler one.  It even has an 'our_gl.h' header file....",
        "user": "UUQ2EQW21",
        "ts": "1586283190.012700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1586283197.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KFnkV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/ssloy\/tinyrenderer"
                            },
                            {
                                "type": "text",
                                "text": " - or this simpler one.  It even has an 'our_gl.h' header file...."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "d9b54397-acb0-47ed-83f5-771b4d1ec063",
        "type": "message",
        "text": "I am using OpenGL right now for my project. My problem is that I want to be cross-platform, and Apple has officially deprecated OpenGL, and they also do not support OpenGL 4.3, which has features I need. The MacOS and WebAssembly platforms are the reasons why I will migrate to WebGPU.\n\nOpenGL is still a great cross-platform solution if you don't need access to features introduced in the last 10 years, like compute shaders.",
        "user": "UJN1TAYEQ",
        "ts": "1586283722.013100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9qQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am using OpenGL right now for my project. My problem is that I want to be cross-platform, and Apple has officially deprecated OpenGL, and they also do not support OpenGL 4.3, which has features I need. The MacOS and WebAssembly platforms are the reasons why I will migrate to WebGPU.\n\nOpenGL is still a great cross-platform solution if you don't need access to features introduced in the last 10 years, like compute shaders."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "7264D04C-E316-4DBD-9551-10BFD8E3F866",
        "type": "message",
        "text": "Yeah, for original poster’s question, he just needs basic GL.  I didn’t realise WebGPU would work native on desktop - if there’s a C API it’s more interesting... my live coding tool has GL\/DX 12 and Vulkan backends in various levels of completion! ",
        "user": "UUQ2EQW21",
        "ts": "1586299184.016900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L0Vx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, for original poster’s question, he just needs basic GL.  I didn’t realise WebGPU would work native on desktop - if there’s a C API it’s more interesting... my live coding tool has GL\/DX 12 and Vulkan backends in various levels of completion! "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "2b6c5c18-1fbe-4df4-9aec-43e6104c897c",
        "type": "message",
        "text": "<@UUQ2EQW21> both those repos are excellent, thank you. However they're not actually writing to the framebuffer, are they? Maybe I'm missing something.\n\nJust to give some context, the problem I wrestle with for graphics is how to make something that:\na) can display on a real machine with minimal dependencies, and\nb) can also display on a stock *nix or Mac machine without needing root permissions and so on.\n\nTo help you triangulate, my non-graphics programs in Mu can currently run on Linux and also on a much simpler OS using either Qemu or native hardware. This is easy because we don't typically need root to access stdin\/stdout\/tty the way we need it for framebuffer access.\n\nOnce I can display a single pixel within these criteria, your repos become very relevant.",
        "user": "UCUSW7WVD",
        "ts": "1586299400.017100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O59Vv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UUQ2EQW21"
                            },
                            {
                                "type": "text",
                                "text": " both those repos are excellent, thank you. However they're not actually writing to the framebuffer, are they? Maybe I'm missing something.\n\nJust to give some context, the problem I wrestle with for graphics is how to make something that:\na) can display on a real machine with minimal dependencies, and\nb) can also display on a stock *nix or Mac machine without needing root permissions and so on.\n\nTo help you triangulate, my non-graphics programs in Mu can currently run on Linux and also on a much simpler OS using either Qemu or native hardware. This is easy because we don't typically need root to access stdin\/stdout\/tty the way we need it for framebuffer access.\n\nOnce I can display a single pixel within these criteria, your repos become very relevant."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "5f803aca-0bf5-4ee4-857f-c6ec86f8d034",
        "type": "message",
        "text": "<@UUQ2EQW21> The WebGPU C implementations are wgpu (<https:\/\/github.com\/gfx-rs\/wgpu>) and dawn (<https:\/\/dawn.googlesource.com\/dawn\/>). Both implementations use the same C header file (<https:\/\/github.com\/webgpu-native\/webgpu-headers\/blob\/master\/webgpu.h>). For now, these prototype implementations ingest SPIR-V as the shader language. Later they will change to ingest WebGPU Shader Language (WGSL), which is text based and isomorphic to SPIR-V, but that is still in an early stage of design.",
        "user": "UJN1TAYEQ",
        "ts": "1586300888.017300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "gfx-rs\/wgpu",
                "title_link": "https:\/\/github.com\/gfx-rs\/wgpu",
                "text": "Native WebGPU implementation based on gfx-hal. Contribute to gfx-rs\/wgpu development by creating an account on GitHub.",
                "fallback": "GitHub: gfx-rs\/wgpu",
                "from_url": "https:\/\/github.com\/gfx-rs\/wgpu",
                "thumb_url": "https:\/\/repository-images.githubusercontent.com\/148686316\/fc1c7f00-3ae1-11ea-884a-b4d1a7840650",
                "thumb_width": 250,
                "thumb_height": 250,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/gfx-rs\/wgpu"
            },
            {
                "service_name": "GitHub",
                "title": "webgpu-native\/webgpu-headers",
                "title_link": "https:\/\/github.com\/webgpu-native\/webgpu-headers\/blob\/master\/webgpu.h",
                "text": "Contribute to webgpu-native\/webgpu-headers development by creating an account on GitHub.",
                "fallback": "GitHub: webgpu-native\/webgpu-headers",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/52747906?s=400&v=4",
                "from_url": "https:\/\/github.com\/webgpu-native\/webgpu-headers\/blob\/master\/webgpu.h",
                "thumb_width": 420,
                "thumb_height": 420,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 2,
                "original_url": "https:\/\/github.com\/webgpu-native\/webgpu-headers\/blob\/master\/webgpu.h"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4wvj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UUQ2EQW21"
                            },
                            {
                                "type": "text",
                                "text": " The WebGPU C implementations are wgpu ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/gfx-rs\/wgpu"
                            },
                            {
                                "type": "text",
                                "text": ") and dawn ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dawn.googlesource.com\/dawn\/"
                            },
                            {
                                "type": "text",
                                "text": "). Both implementations use the same C header file ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/webgpu-native\/webgpu-headers\/blob\/master\/webgpu.h"
                            },
                            {
                                "type": "text",
                                "text": "). For now, these prototype implementations ingest SPIR-V as the shader language. Later they will change to ingest WebGPU Shader Language (WGSL), which is text based and isomorphic to SPIR-V, but that is still in an early stage of design."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "42424e83-ed7d-4bd7-a3bf-062d984c7b48",
        "type": "message",
        "text": "<@UCUSW7WVD> AFAIK you can't write directly to framebuffer hardware if you want to run under a modern OS. Under Linux, Windows or MacOS, Mu is effectively running in a virtual machine and is using OS APIs to do all of its input and output, including graphics. Probably Mu is running under a window manager, so that is another layer of abstraction between Mu and the hardware. Maybe you want to create a pixel array in Mu's address space, pretend that this pixel array is the frame buffer, and write OS-specific code to copy the frame buffer to the window once per frame. It's not difficult to code this using OpenGL. It will not be energy efficient on a laptop though, since the frame buffer copy happens 60 times per second even if the framebuffer hasn't changed.",
        "user": "UJN1TAYEQ",
        "ts": "1586302035.017600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wJMH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " AFAIK you can't write directly to framebuffer hardware if you want to run under a modern OS. Under Linux, Windows or MacOS, Mu is effectively running in a virtual machine and is using OS APIs to do all of its input and output, including graphics. Probably Mu is running under a window manager, so that is another layer of abstraction between Mu and the hardware. Maybe you want to create a pixel array in Mu's address space, pretend that this pixel array is the frame buffer, and write OS-specific code to copy the frame buffer to the window once per frame. It's not difficult to code this using OpenGL. It will not be energy efficient on a laptop though, since the frame buffer copy happens 60 times per second even if the framebuffer hasn't changed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "8b375c60-6a77-421e-b129-ccc5830a5b93",
        "type": "message",
        "text": "It occurs to me that I just need a framebuffer emulator analogous to text-mode terminal emulators. And look, someone else had the same idea:\n\n<https:\/\/sixpak.org\/fbe>\n\n<@UJN1TAYEQ> it's totally an option to have different code paths for running on native hardware vs a host OS. For example, here are the syscalls I use for two different OSs: <https:\/\/github.com\/akkartik\/mu\/blob\/master\/init.linux> and <https:\/\/github.com\/akkartik\/mu\/blob\/master\/init.soso>. In combination with fbe, I could maybe have separate init.linux and init.qemu or something like that, where the ioctls expand to nothing and the address of `mmap`d memory changes.",
        "user": "UCUSW7WVD",
        "ts": "1586302471.017800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1586302503.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+aT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It occurs to me that I just need a framebuffer emulator analogous to text-mode terminal emulators. And look, someone else had the same idea:\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/sixpak.org\/fbe"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " it's totally an option to have different code paths for running on native hardware vs a host OS. For example, here are the syscalls I use for two different OSs: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/akkartik\/mu\/blob\/master\/init.linux"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/akkartik\/mu\/blob\/master\/init.soso"
                            },
                            {
                                "type": "text",
                                "text": ". In combination with fbe, I could maybe have separate init.linux and init.qemu or something like that, where the ioctls expand to nothing and the address of `mmap`d memory changes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "776fca93-14ff-485c-a828-22ace1e921c2",
        "type": "message",
        "text": "Yes, I was describing my implementation of a framebuffer emulator.",
        "user": "UJN1TAYEQ",
        "ts": "1586304245.018300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1ha",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I was describing my implementation of a framebuffer emulator."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585682016.001200",
        "parent_user_id": "UC2A2ARPT"
    }
]