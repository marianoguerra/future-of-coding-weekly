[
    {
        "client_msg_id": "59a549d8-6b0a-437b-8575-bad6e06c506d",
        "type": "message",
        "text": "&gt; Also I'll just point out that I'm getting a vibe from a lot of people that their \"future of coding\" involves C-like performance. Most applications aren't limited by operations per second... so I'm puzzled by why people are limiting their visions to ones with a clear mapping to C-like constructs. Only asymptotic complexity matters broadly, since that is what separates the possible from the impossible.\nI didn't mean to suggest that C like performance is necessary. In fact I think optimising compilers are very bad for understanding. The examples I gave were cases of asymptotic complexity being different, and in high level languages. Shalabh's async track trace example is one that has nothing to do with performance.\n\nFor me it's not about the performance so much as the tension of presenting a model of computation that is fundamentally at odds with reality. The disagreement is whether or not this matters. The answer to this question basically comes down to how airtight your abstractions are. My main point is these issues can be avoided if you just make it possible to draw back the curtain.\n\nIf your abstraction is blocking my understanding, let me easily remove it. If your abstraction is *not* blocking my understanding, whether or not I can remove it is moot because I won't want to.",
        "user": "UDQBTJ211",
        "ts": "1585727606.062000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NiTg",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also I'll just point out that I'm getting a vibe from a lot of people that their \"future of coding\" involves C-like performance. Most applications aren't limited by operations per second... so I'm puzzled by why people are limiting their visions to ones with a clear mapping to C-like constructs. Only asymptotic complexity matters broadly, since that is what separates the possible from the impossible."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI didn't mean to suggest that C like performance is necessary. In fact I think optimising compilers are very bad for understanding. The examples I gave were cases of asymptotic complexity being different, and in high level languages. Shalabh's async track trace example is one that has nothing to do with performance.\n\nFor me it's not about the performance so much as the tension of presenting a model of computation that is fundamentally at odds with reality. The disagreement is whether or not this matters. The answer to this question basically comes down to how airtight your abstractions are. My main point is these issues can be avoided if you just make it possible to draw back the curtain.\n\nIf your abstraction is blocking my understanding, let me easily remove it. If your abstraction is "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " blocking my understanding, whether or not I can remove it is moot because I won't want to."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "4c0a4b00-c2a0-4e33-a693-38048325f584",
        "type": "message",
        "text": "If a language has a bad abstraction, then the solution is to replace it with a better abstraction, not expose the machine code (the \"reality\") that the bad abstraction compiles to. I can't think of any situation in which exposing the machine code is a good idea, because if the user has to think about machine code, then my language has failed to achieve its purpose, which is to be a new foundation for specifying &amp; reasoning about computation. What I *do* want to expose via my programming environment is the time &amp; space complexity of programs, so the user can reason about what is possible and impossible. If the language is designed well, then the environment can provide an intuitive explanation for why a program has a particular complexity.",
        "user": "UCGAK10LS",
        "ts": "1585729956.062200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fget",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If a language has a bad abstraction, then the solution is to replace it with a better abstraction, not expose the machine code (the \"reality\") that the bad abstraction compiles to. I can't think of any situation in which exposing the machine code is a good idea, because if the user has to think about machine code, then my language has failed to achieve its purpose, which is to be a new foundation for specifying & reasoning about computation. What I "
                            },
                            {
                                "type": "text",
                                "text": "do",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " want to expose via my programming environment is the time & space complexity of programs, so the user can reason about what is possible and impossible. If the language is designed well, then the environment can provide an intuitive explanation for why a program has a particular complexity."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "7f913944-ba8a-435a-aecb-03679fda8ea3",
        "type": "message",
        "text": "Possibly a failure of imagination on my part, but I guess I'm struggling to understand what you mean by \"time\", if not number of CPU instructions, and \"space\" if not number of memory bits. If you do mean these, then isn't your abstraction tied tightly to \"C concepts\" as well...?",
        "user": "UDQBTJ211",
        "ts": "1585730448.062400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tCN\/y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Possibly a failure of imagination on my part, but I guess I'm struggling to understand what you mean by \"time\", if not number of CPU instructions, and \"space\" if not number of memory bits. If you do mean these, then isn't your abstraction tied tightly to \"C concepts\" as well...?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "b6df756a-ad71-47b6-a0f6-f86468869042",
        "type": "message",
        "text": "The CS notions of time and space complexity have never been based on CPU instructions or memory bits. They talk about the rate of growth of time and space measured in abstract \"operations\" and \"stored data\" relative to the \"input size\" of your program, the concrete units being irrelevant (since we're interested in the slope).",
        "user": "UCGAK10LS",
        "ts": "1585731763.062600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kkm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The CS notions of time and space complexity have never been based on CPU instructions or memory bits. They talk about the rate of growth of time and space measured in abstract \"operations\" and \"stored data\" relative to the \"input size\" of your program, the concrete units being irrelevant (since we're interested in the slope)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "939dc2b2-d96c-473f-9ce1-a0e9957dda09",
        "type": "message",
        "text": "You can't provide an exact number for operations or data storage regardless of what units you use, until code actually runs. The number of concrete operations in any program with a branch instruction varies with the input, but its (worst case) time complexity will be fixed, across all inputs.",
        "user": "UCGAK10LS",
        "ts": "1585731970.062800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h1f1l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can't provide an exact number for operations or data storage regardless of what units you use, until code actually runs. The number of concrete operations in any program with a branch instruction varies with the input, but its (worst case) time complexity will be fixed, across all inputs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "5fa828ed-092e-4401-81cd-d1fe6528b463",
        "type": "message",
        "text": "Yes, but specifically in your language, how are you measuring \"operations\"? Surely in a way that maps very closely to x86 instructions? Otherwise, what's the value of this information?\n\nObviously it's possible to define some notion of \"operation\" that treats add(a, b), sqrt(n) and factorize(n) all as \"one operation\", and then discuss time complexity in terms of these - but this is not an analysis that is particularly useful.\n\nWe have actually built machines that map \"memory space\" to metres (RAM), and \"instruction count\" to seconds (CPUs), which is why time and space complexity analysis (in these terms) is useful to humans.",
        "user": "UDQBTJ211",
        "ts": "1585732829.063000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pc2E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, but specifically in your language, how are you measuring \"operations\"? Surely in a way that maps very closely to x86 instructions? Otherwise, what's the value of this information?\n\nObviously it's possible to define some notion of \"operation\" that treats add(a, b), sqrt(n) and factorize(n) all as \"one operation\", and then discuss time complexity in terms of these - but this is not an analysis that is particularly useful.\n\nWe have actually built machines that map \"memory space\" to metres (RAM), and \"instruction count\" to seconds (CPUs), which is why time and space complexity analysis (in these terms) is useful to humans."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "DAF37581-6A6D-491B-86F5-AC65420F4C6F",
        "type": "message",
        "text": "I’ll ask you the same question: how do you measure operations in a C program? An x86 program? How useful is that measure? Whatever measure I choose would be no worse.",
        "user": "UCGAK10LS",
        "ts": "1585733107.064700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vh8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’ll ask you the same question: how do you measure operations in a C program? An x86 program? How useful is that measure? Whatever measure I choose would be no worse."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "17631561-F917-46BE-B77C-CB7BF4E46042",
        "type": "message",
        "text": "For that reason, I’m not going to tell users how long a program did\/might run by operation count, like “173”. It’s not useful. I could tell them the runtime in seconds, if they need to benchmark.",
        "user": "UCGAK10LS",
        "ts": "1585733238.066800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585733967.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dg+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For that reason, I’m not going to tell users how long a program did\/might run by operation count, like “173”. It’s not useful. I could tell them the runtime in seconds, if they need to benchmark."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "3FCB6B91-237C-4A60-BE7C-3622B3B2F212",
        "type": "message",
        "text": "(Spoiler: you can’t specify how long an instruction is going to take across all CPUs, not even all x86 CPUs, nor all Intel x86 CPUs. It varies by model. You also can’t predict how long any memory access is going to take in any multi-threaded or multi-process system, which is all consumer systems). ",
        "user": "UCGAK10LS",
        "ts": "1585733499.071200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o22k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Spoiler: you can’t specify how long an instruction is going to take across all CPUs, not even all x86 CPUs, nor all Intel x86 CPUs. It varies by model. You also can’t predict how long any memory access is going to take in any multi-threaded or multi-process system, which is all consumer systems). "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "685a99c7-c55c-4917-91f2-11eca336cb11",
        "type": "message",
        "text": "The sentence I was struggling with was;\n&gt; What I *do* want to expose via my programming environment is the time &amp; space complexity of programs, so the user can reason about what is possible and impossible",
        "user": "UDQBTJ211",
        "ts": "1585733838.071400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sFl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The sentence I was struggling with was;\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I "
                            },
                            {
                                "type": "text",
                                "text": "do",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " want to expose via my programming environment is the time & space complexity of programs, so the user can reason about what is possible and impossible"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "dc7556b8-fc97-4461-aad1-d162804963ed",
        "type": "message",
        "text": "Perhaps I will have to wait to see a concrete example of the kind of environment that you mean",
        "user": "UDQBTJ211",
        "ts": "1585733870.071600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "i9ba",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps I will have to wait to see a concrete example of the kind of environment that you mean"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "A71F41D3-92B4-4A48-A625-55D010015991",
        "type": "message",
        "text": "You could, but I’m talking distant future. Designing a programming language by oneself is a Herculean effort. By that sentence, I mean literally O(n), O(nlogn) etc, but with a better syntax, not math notation.",
        "user": "UCGAK10LS",
        "ts": "1585734121.074900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZJVhQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You could, but I’m talking distant future. Designing a programming language by oneself is a Herculean effort. By that sentence, I mean literally O(n), O(nlogn) etc, but with a better syntax, not math notation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "3ed0a2eb-b42d-42f6-8d2a-d5e15b1d3805",
        "type": "message",
        "text": "<@UFB8STN7K> re: #4 - he does make an argument - if you look around in the tech\/dev community, you will see a lot of focus has shifted from “hey I had an idea so i hacked it up and i think this might be a good product” to “hey lets make a todo list app and ship it and call ourselves entrepeneur makers and focus on pumping out same old just to ship stuff”",
        "user": "UNBPP291C",
        "ts": "1585738174.075200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gcf29e340a09",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Ian Rumac",
            "display_name": "Ian Rumac",
            "team": "T5TCAFTA9",
            "name": "ian.rumac",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W\/BwN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " re: #4 - he does make an argument - if you look around in the tech\/dev community, you will see a lot of focus has shifted from “hey I had an idea so i hacked it up and i think this might be a good product” to “hey lets make a todo list app and ship it and call ourselves entrepeneur makers and focus on pumping out same old just to ship stuff”"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585616341.042100",
        "parent_user_id": "UBSMEUXAA"
    },
    {
        "client_msg_id": "ac71f922-127d-44a1-83f0-bda5b7df5563",
        "type": "message",
        "text": "the hacker spirit has been replaced by “entrepeneur” spirit. even tho I wouldnt say replaced, Id just say the scene has scaled quite a lot and that kind stuff is the stuff that people promote externally while hacker communities promote things internally so it has less visibility",
        "user": "UNBPP291C",
        "ts": "1585738261.075400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gcf29e340a09",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Ian Rumac",
            "display_name": "Ian Rumac",
            "team": "T5TCAFTA9",
            "name": "ian.rumac",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TSh08",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the hacker spirit has been replaced by “entrepeneur” spirit. even tho I wouldnt say replaced, Id just say the scene has scaled quite a lot and that kind stuff is the stuff that people promote externally while hacker communities promote things internally so it has less visibility"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585616341.042100",
        "parent_user_id": "UBSMEUXAA"
    },
    {
        "client_msg_id": "23401de5-9182-4c73-b0b1-ad3ce1f00fde",
        "type": "message",
        "text": "You made a nice start on your editor. However, you haven't considered one of the crucial problems that will come up, which is what happens when the width of your display is wider than the screen, and the content is taller. At that point you are now looking through a porthole into misc. data, and the user will be completely lost. Spreadsheets alleviate this through a split screen approach, and supporting fixing in place header rows so context isn't lost. There is a lot of ergonomics in doing this kind of graphical approach properly, and if you haven't addressed the core problems, your prototype is like putting frosting without the cake. So my suggestion is to take a much larger example and see how you would edit that. This loss of context problem is what is killing the node-and-wire projects like Luna. It immediately turns into pure wires once you hit a complex enough problem. I'm not saying it isn't solvable, but that the reason so many people fail is they pick their own examples to build around. Take my chess program; that will not fit under any circumstances on a single screen, and one will have to navigate around.\n\nIf you are interested in the theory behind this, i can recommend \"Platform for change\" by Stafford Beer, who was invited by Salvador Allende to automate chile, and is one of the pioneers of systems theory. Really brilliant man, and in that book he talks about Ashby's law of requisite variety. If more people were familiar with that law they wouldn't be so gung ho on no code approaches which usually try to break this law of information theory.",
        "user": "UEQ6M68H0",
        "ts": "1585808824.076200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I2zJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You made a nice start on your editor. However, you haven't considered one of the crucial problems that will come up, which is what happens when the width of your display is wider than the screen, and the content is taller. At that point you are now looking through a porthole into misc. data, and the user will be completely lost. Spreadsheets alleviate this through a split screen approach, and supporting fixing in place header rows so context isn't lost. There is a lot of ergonomics in doing this kind of graphical approach properly, and if you haven't addressed the core problems, your prototype is like putting frosting without the cake. So my suggestion is to take a much larger example and see how you would edit that. This loss of context problem is what is killing the node-and-wire projects like Luna. It immediately turns into pure wires once you hit a complex enough problem. I'm not saying it isn't solvable, but that the reason so many people fail is they pick their own examples to build around. Take my chess program; that will not fit under any circumstances on a single screen, and one will have to navigate around.\n\nIf you are interested in the theory behind this, i can recommend \"Platform for change\" by Stafford Beer, who was invited by Salvador Allende to automate chile, and is one of the pioneers of systems theory. Really brilliant man, and in that book he talks about Ashby's law of requisite variety. If more people were familiar with that law they wouldn't be so gung ho on no code approaches which usually try to break this law of information theory."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585588913.032700",
        "parent_user_id": "UCKRZS3DZ"
    }
]