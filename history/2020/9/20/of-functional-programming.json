[
    {
        "client_msg_id": "629efd8f-31b1-4cd5-93e0-d4fb64037104",
        "type": "message",
        "text": "The author of the CT\/math book I'm reading (Paolo Aluffi) suggested that if functions defs put output first ( `f : B &lt;- A` instead of `f : A -&gt; B`) then function composition like `f . g` would make more sense.\nThen a couple chapters later he goes on to say that writing `(x)f` instead of `f(x)` would make  `(f.g)(x)`  be `((x)g)f` (or even maybe `xgf`)\nBoth are nice suggestions, but the mix really does hurt my head",
        "user": "UN57U8V53",
        "ts": "1600616899.006300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3447742b735b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-09\/753296041488_3447742b735b104a7ff2_72.png",
            "first_name": "",
            "real_name": "Don Abrams",
            "display_name": "Don Abrams",
            "team": "T5TCAFTA9",
            "name": "donabrams",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WFHO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The author of the CT\/math book I'm reading (Paolo Aluffi) suggested that if functions defs put output first ( "
                            },
                            {
                                "type": "text",
                                "text": "f : B <- A",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead of "
                            },
                            {
                                "type": "text",
                                "text": "f : A -> B",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ") then function composition like "
                            },
                            {
                                "type": "text",
                                "text": "f . g",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would make more sense.\nThen a couple chapters later he goes on to say that writing "
                            },
                            {
                                "type": "text",
                                "text": "(x)f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead of "
                            },
                            {
                                "type": "text",
                                "text": "f(x)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would make  "
                            },
                            {
                                "type": "text",
                                "text": "(f.g)(x)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  be "
                            },
                            {
                                "type": "text",
                                "text": "((x)g)f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (or even maybe "
                            },
                            {
                                "type": "text",
                                "text": "xgf",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ")\nBoth are nice suggestions, but the mix really does hurt my head"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "reply_count": 6,
        "reply_users_count": 4,
        "latest_reply": "1600831119.002200",
        "reply_users": [
            "UT60XSVCN",
            "UJN1TAYEQ",
            "U78TZ437S",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UT60XSVCN",
                "ts": "1600618350.006700"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1600648832.007100"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1600649688.007400"
            },
            {
                "user": "U78TZ437S",
                "ts": "1600668924.007600"
            },
            {
                "user": "U78TZ437S",
                "ts": "1600669008.007800"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1600831119.002200"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "70c55627-a42f-42e5-a2d7-992aaae97839",
        "type": "message",
        "text": "If you read older algebra books, people actually do this. I think herstein's book does it.\nThe context switching I think is why people have mostly settled on one notation",
        "user": "UT60XSVCN",
        "ts": "1600618350.006700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gbc3e6041047",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "S.M Mukarram Nainar",
            "display_name": "S.M Mukarram Nainar",
            "team": "T5TCAFTA9",
            "name": "nainars",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sq1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you read older algebra books, people actually do this. I think herstein's book does it.\nThe context switching I think is why people have mostly settled on one notation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "parent_user_id": "UN57U8V53"
    },
    {
        "client_msg_id": "a3d0d9a3-1aa5-42df-a009-5e24e1fa9dd5",
        "type": "message",
        "text": "De Bruijn Notation is a variant notation for lambda calculus where you write `(x)f` to call a function. The wikipedia page describes how this simplifies the algebraic manipulation of lambda terms, and makes certain proofs easier.\n<https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_notation>",
        "user": "UJN1TAYEQ",
        "ts": "1600648832.007100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1600648857.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wD1B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "De Bruijn Notation is a variant notation for lambda calculus where you write "
                            },
                            {
                                "type": "text",
                                "text": "(x)f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to call a function. The wikipedia page describes how this simplifies the algebraic manipulation of lambda terms, and makes certain proofs easier.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_notation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "parent_user_id": "UN57U8V53"
    },
    {
        "client_msg_id": "85c30ce2-2c39-4a70-83d2-daa5b473559a",
        "type": "message",
        "text": "F# has an infix function call operator where `x |&gt; f` means `f x`, and an infix function composition operator where `f &gt;&gt; g` is the same as `g . f` in Haskell. This design has become popular, and has been widely copied by newer functional languages.",
        "user": "UJN1TAYEQ",
        "ts": "1600649688.007400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D\/mK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "F# has an infix function call operator where "
                            },
                            {
                                "type": "text",
                                "text": "x |> f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " means "
                            },
                            {
                                "type": "text",
                                "text": "f x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and an infix function composition operator where "
                            },
                            {
                                "type": "text",
                                "text": "f >> g",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is the same as "
                            },
                            {
                                "type": "text",
                                "text": "g . f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in Haskell. This design has become popular, and has been widely copied by newer functional languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "parent_user_id": "UN57U8V53",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC",
                    "UKP3B2J5D"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a5c478bf-6326-46c7-a658-e0d4339e09bf",
        "type": "message",
        "text": "I think another perspective is evaluation order \/ dominance of expressions. For example, in a lazy language like Haskell, an expression like `f x`  - is \"dominated\" by `f` which may choose to evaluate or not evaluate `x` at all, and in any case `f` and its application are evaluated first. So it makes sense to see things ordered by their importance: `f (g (h x)).`\nIn an eager language, it's nicer to see things read by their evaluation order: `x |&gt; g |&gt; f` (though `f` or `g` as function yielding expressions are actually be evaluated first, their application is evaluated later).",
        "user": "U78TZ437S",
        "ts": "1600668924.007600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ga3a20a76a69",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/da3a20a76a69532fa83e790e89cb4c6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "Eyal",
            "real_name": "Eyal Lotem",
            "display_name": "eyal",
            "team": "T5TCAFTA9",
            "name": "eyal.lotem",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BK+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think another perspective is evaluation order \/ dominance of expressions. For example, in a lazy language like Haskell, an expression like "
                            },
                            {
                                "type": "text",
                                "text": "f x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  - is \"dominated\" by "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " which may choose to evaluate or not evaluate "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " at all, and in any case "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and its application are evaluated first. So it makes sense to see things ordered by their importance: "
                            },
                            {
                                "type": "text",
                                "text": "f (g (h x)).",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nIn an eager language, it's nicer to see things read by their evaluation order: "
                            },
                            {
                                "type": "text",
                                "text": "x |> g |> f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (though "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "g",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as function yielding expressions are actually be evaluated first, their application is evaluated later)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "parent_user_id": "UN57U8V53",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UN57U8V53",
                    "UKP3B2J5D"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d20790b0-58c2-49f4-90bf-8e757048b6a6",
        "type": "message",
        "text": "Another perspective on whether we should write: `f : B &lt;- A` or `f : A -&gt; B` is analogy to arithmetic.  `A -&gt; B` is `B ^ A` (B raised to the power of A).  So making the notations align up could be nice",
        "user": "U78TZ437S",
        "ts": "1600669008.007800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ga3a20a76a69",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/da3a20a76a69532fa83e790e89cb4c6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "Eyal",
            "real_name": "Eyal Lotem",
            "display_name": "eyal",
            "team": "T5TCAFTA9",
            "name": "eyal.lotem",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RMRns",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another perspective on whether we should write: "
                            },
                            {
                                "type": "text",
                                "text": "f : B <- A",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "f : A -> B",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is analogy to arithmetic.  "
                            },
                            {
                                "type": "text",
                                "text": "A -> B",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is "
                            },
                            {
                                "type": "text",
                                "text": "B ^ A",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (B raised to the power of A).  So making the notations align up could be nice"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600616899.006300",
        "parent_user_id": "UN57U8V53",
        "reactions": [
            {
                "name": "smile",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    }
]