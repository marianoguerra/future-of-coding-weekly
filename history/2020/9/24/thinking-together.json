[
    {
        "client_msg_id": "f901a49e-7fcd-46a7-b5f0-c726597757b1",
        "type": "message",
        "text": "Maybe one way to address some of your points is to store all the code editing history. One missing point will the tracking of the resources and the alternatives that have been considered but not tried.\n\nI guess using environments that use CRDT can have this for free. CRDT used as editing actions log can be used to show what happen at what \"time\".\n\nAnd adding other not-code artifacts (resources and record of not-tried alternatives) in the environnement might also help covering all your points.",
        "user": "UJ6LDMMN0",
        "ts": "1600937449.000900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Aha0S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe one way to address some of your points is to store all the code editing history. One missing point will the tracking of the resources and the alternatives that have been considered but not tried.\n\nI guess using environments that use CRDT can have this for free. CRDT used as editing actions log can be used to show what happen at what \"time\".\n\nAnd adding other not-code artifacts (resources and record of not-tried alternatives) in the environnement might also help covering all your points."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "a23e7fea-18be-4e29-ae72-2a65ebd7cc34",
        "type": "message",
        "text": "I end up using git annotate as a proxy for some of this. It’s limitations are being line-based and being just the most recent thing to have happened to each line. I’m picturing something that turns the section of code I’m looking at into a series of slices that let me step through commits while seeing what has been stable and what has been turbulent.",
        "user": "UKDM3GLAJ",
        "ts": "1600955918.001200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "34e7a55348e8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-04\/893378739792_34e7a55348e8c86c1901_72.jpg",
            "first_name": "",
            "real_name": "Jared Windover",
            "display_name": "Jared Windover",
            "team": "T5TCAFTA9",
            "name": "jaredwindover",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H8x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I end up using git annotate as a proxy for some of this. It’s limitations are being line-based and being just the most recent thing to have happened to each line. I’m picturing something that turns the section of code I’m looking at into a series of slices that let me step through commits while seeing what has been stable and what has been turbulent."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "385217d4-f419-4376-ab90-66296fe5aa43",
        "type": "message",
        "text": "i think one big area that's possible right now without crazy advances in PL design is revealing production behaviour in the editor during development. it doesn't help that much with designing business logic and answering the questions you asked, but for managing all the accidental complexity of actually running code in production, there's a lot of data generated by logs, tracing systems, etc these days that i wish editors revealed much easier",
        "user": "U016LEA3J1H",
        "ts": "1600964214.001600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7082261f477c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-06\/1225163496802_7082261f477cd8a85548_72.jpg",
            "first_name": "Harry",
            "real_name": "Harry Brundage",
            "display_name": "Harry Brundage",
            "team": "T5TCAFTA9",
            "name": "harry",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U016LEA3J1H",
            "ts": "1600964271.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h11p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i think one big area that's possible right now without crazy advances in PL design is revealing production behaviour in the editor during development. it doesn't help that much with designing business logic and answering the questions you asked, but for managing all the accidental complexity of actually running code in production, there's a lot of data generated by logs, tracing systems, etc these days that i wish editors revealed much easier"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "UKP3B2J5D",
                    "UJNJQD2AC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "1f7ca2ed-41fa-461c-8e73-a250c7ff8184",
        "type": "message",
        "text": "think hovering a name in your editor and getting a popover that shows values that name held for various traces in production, or the values it tends to hold for successful requests vs failed requests, etc",
        "user": "U016LEA3J1H",
        "ts": "1600964262.001800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7082261f477c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-06\/1225163496802_7082261f477cd8a85548_72.jpg",
            "first_name": "Harry",
            "real_name": "Harry Brundage",
            "display_name": "Harry Brundage",
            "team": "T5TCAFTA9",
            "name": "harry",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pIX70",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "think hovering a name in your editor and getting a popover that shows values that name held for various traces in production, or the values it tends to hold for successful requests vs failed requests, etc"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UPVBV34EL",
                    "U013ZLJARC7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "9d7acd36-b92f-459c-b38c-4d6f1dd543a2",
        "type": "message",
        "text": "pretty sure some advanced Java development setups allow for this kind of thing with remote debuggers running in prod, but it doesn't seem to have taken off",
        "user": "U016LEA3J1H",
        "ts": "1600964301.002100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7082261f477c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-06\/1225163496802_7082261f477cd8a85548_72.jpg",
            "first_name": "Harry",
            "real_name": "Harry Brundage",
            "display_name": "Harry Brundage",
            "team": "T5TCAFTA9",
            "name": "harry",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FU1E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "pretty sure some advanced Java development setups allow for this kind of thing with remote debuggers running in prod, but it doesn't seem to have taken off"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "d691fb9c-0dd6-400b-90cd-5cd84e7d10b6",
        "type": "message",
        "text": "it really does sound nice to work with a medium that reveals all the variations it could be shaped into next or all the variations it used to be in the shape of, instead of just the current shape, but i also think maybe our feeble brains can't deal with yet another dimension of abstraction when working with code. the concreteness of the code in front of you, the lossiness might actually be valuable in service of making programming possible in the first place",
        "user": "U016LEA3J1H",
        "ts": "1600964486.002300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7082261f477c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-06\/1225163496802_7082261f477cd8a85548_72.jpg",
            "first_name": "Harry",
            "real_name": "Harry Brundage",
            "display_name": "Harry Brundage",
            "team": "T5TCAFTA9",
            "name": "harry",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ec8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "it really does sound nice to work with a medium that reveals all the variations it could be shaped into next or all the variations it used to be in the shape of, instead of just the current shape, but i also think maybe our feeble brains can't deal with yet another dimension of abstraction when working with code. the concreteness of the code in front of you, the lossiness might actually be valuable in service of making programming possible in the first place"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "6370c258-e56a-45eb-bfed-01f128468339",
        "type": "message",
        "text": "One thing I've wished for is the ability to ask, \"do we have any tests where this variable has value ___?\" Often when I have a bugfix to add I'll first comment out existing business logic, just to figure out the best place to put the new test.",
        "user": "UCUSW7WVD",
        "ts": "1600965625.002600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7PJPn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing I've wished for is the ability to ask, \"do we have any tests where this variable has value ___?\" Often when I have a bugfix to add I'll first comment out existing business logic, just to figure out the best place to put the new test."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "980fbe4e-97a9-4305-89d2-55d6ebbff377",
        "type": "message",
        "text": "This is an area of I have thought a lot about. My own personal programming project is aimed to help with this. But I've also been white boarding through ideas on how to help with this in the current world. Not sure I could summarize well the ways I want to actually help this problem here, but I do want to at least contribute a few meta thoughts.\n\nFirst I think one really important thing to consider is if we can in fact recover the important parts of a programs history at all. Peter Naur in his paper \"Programming as Theory Building\" claims that re-establishing the theory of a dead program is strictly impossible. I'm sure so people might question this, but I think this is actually very important to consider. If we aim at trying to save a history, we have to consider our aims. If our goal is to recover the theory behind the program that could be a fools errand. Instead maybe we should be thinking about what parts of a programs history are important for helping us establish a new theory? Does that history have to be an actual history or could it be something like what is proposed in the talk \"Idealized Commit Logs\" (<https:\/\/www.youtube.com\/watch?v=dSqLt8BgbRQ>)?\n\nSecond I think we actually should really consider learning more from historians, particular historians of artifacts (like art history). There is a great book on art history methodology called Patterns of Intention by Michael Baxandall. One of the points he makes is that when we are describing art, we are converting something visual to something linguistic. This is a lossy and biased format, one easy example he gives us that paintings don't actually a beginning and end point. We have to choose how to describe it and where to start. When we are studying art works, we are really studying them under some description of them. (He makes this much clearer for of us who are not artistically inclined by starting with a history of the forth bridge. His history of this artifacts asks as a really interesting example into what goes into an historical explanation.)\n\nI think these same things hold true for programs. In capturing a history, we can't just be recording facts in a database, we are interpreting those facts, selecting the relevant ones and determining an order. What sorts of facts, in what sorts of orders can help people gain a new theory? Will different interpretations click better with different people? What things do we exclude by selecting that facts in this way? Is the loss worth the pay off?\n\n&gt; What are some ways in which programming environments could help us record this info \/ answer these questions without requiring additional effort from the author?\nI think this is particularly interesting. We all know that getting people to provide documentation is hard. It is even harder to make that documentation good. Short of completely automatic though, what if we could make this easier? What if we could make it more part of your current flow? What if you didn't have to leave your editor, but you also didn't have to mess up the code by leaving some big huge long comment in the middle of things?\n\nWhat if you could decide that something was a good example for later and save it off with a single button press? What if you could make tours through your code bases, or document in those code bases various ways the data flows? What if you could make an interactive introduction to codebase.\n\nI think these are the sorts of starting points we should consider. Once we can make these things work and work well manually, then we can start plugging in automations, start making automatic curation.",
        "user": "UK3LH8CF5",
        "ts": "1600982822.003100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "\"Idealized Commit Logs: Code Simplification via Program Slicing\" by Alan Shreve",
                "title_link": "https:\/\/www.youtube.com\/watch?v=dSqLt8BgbRQ",
                "author_name": "Strange Loop",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/dSqLt8BgbRQ\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Idealized Commit Logs: Code Simplification via Program Slicing\" by Alan Shreve",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/dSqLt8BgbRQ?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=dSqLt8BgbRQ",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=dSqLt8BgbRQ"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v1Wu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is an area of I have thought a lot about. My own personal programming project is aimed to help with this. But I've also been white boarding through ideas on how to help with this in the current world. Not sure I could summarize well the ways I want to actually help this problem here, but I do want to at least contribute a few meta thoughts.\n\nFirst I think one really important thing to consider is if we can in fact recover the important parts of a programs history at all. Peter Naur in his paper \"Programming as Theory Building\" claims that re-establishing the theory of a dead program is strictly impossible. I'm sure so people might question this, but I think this is actually very important to consider. If we aim at trying to save a history, we have to consider our aims. If our goal is to recover the theory behind the program that could be a fools errand. Instead maybe we should be thinking about what parts of a programs history are important for helping us establish a new theory? Does that history have to be an actual history or could it be something like what is proposed in the talk \"Idealized Commit Logs\" ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=dSqLt8BgbRQ"
                            },
                            {
                                "type": "text",
                                "text": ")?\n\nSecond I think we actually should really consider learning more from historians, particular historians of artifacts (like art history). There is a great book on art history methodology called Patterns of Intention by Michael Baxandall. One of the points he makes is that when we are describing art, we are converting something visual to something linguistic. This is a lossy and biased format, one easy example he gives us that paintings don't actually a beginning and end point. We have to choose how to describe it and where to start. When we are studying art works, we are really studying them under some description of them. (He makes this much clearer for of us who are not artistically inclined by starting with a history of the forth bridge. His history of this artifacts asks as a really interesting example into what goes into an historical explanation.)\n\nI think these same things hold true for programs. In capturing a history, we can't just be recording facts in a database, we are interpreting those facts, selecting the relevant ones and determining an order. What sorts of facts, in what sorts of orders can help people gain a new theory? Will different interpretations click better with different people? What things do we exclude by selecting that facts in this way? Is the loss worth the pay off?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are some ways in which programming environments could help us record this info \/ answer these questions without requiring additional effort from the author?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think this is particularly interesting. We all know that getting people to provide documentation is hard. It is even harder to make that documentation good. Short of completely automatic though, what if we could make this easier? What if we could make it more part of your current flow? What if you didn't have to leave your editor, but you also didn't have to mess up the code by leaving some big huge long comment in the middle of things?\n\nWhat if you could decide that something was a good example for later and save it off with a single button press? What if you could make tours through your code bases, or document in those code bases various ways the data flows? What if you could make an interactive introduction to codebase.\n\nI think these are the sorts of starting points we should consider. Once we can make these things work and work well manually, then we can start plugging in automations, start making automatic curation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UFB8STN7K",
                    "U013ZLJARC7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "d7a9ae43-c1f2-476b-8095-af404a46a365",
        "type": "message",
        "text": "in a big codebase there might be some utility in using ML. For example, applying frequent itemsets to change sets could identify chunks of code that are changed together more frequently than expected. This might be suggestive of risk, or of refactoring opportunities.",
        "user": "U01A1C2K8MP",
        "ts": "1600984191.007000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gd4b24603815",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/d4b246038154d7cc2363256bd25a4fe0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0014-72.png",
            "first_name": "",
            "real_name": "larry",
            "display_name": "larry",
            "team": "T5TCAFTA9",
            "name": "ljw1001",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z0V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "in a big codebase there might be some utility in using ML. For example, applying frequent itemsets to change sets could identify chunks of code that are changed together more frequently than expected. This might be suggestive of risk, or of refactoring opportunities."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UPVBV34EL",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "52e26948-e1ce-4e16-87da-e7dc50d5e84b",
        "type": "message",
        "text": "<@UK3LH8CF5> the reference to idealized commit logs is really interesting. I’ve also been exploring a tool that uses dynamic program slicing for program comprehension (<https:\/\/github.com\/willcrichton\/inliner>), although it’s a little more general in that it uses several source-to-source compiler techniques for simplifying programs, not just dead code elimination. The idea of using cumulative tests to construct diffs between slices is pretty cool, haven’t thought of that before.",
        "user": "UFB8STN7K",
        "ts": "1600990223.007500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "willcrichton\/inliner",
                "title_link": "https:\/\/github.com\/willcrichton\/inliner",
                "text": "Programmable, human-readable inlining of Python code - willcrichton\/inliner",
                "fallback": "GitHub: willcrichton\/inliner",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/663326?s=400&v=4",
                "from_url": "https:\/\/github.com\/willcrichton\/inliner",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/willcrichton\/inliner"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Akn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": " the reference to idealized commit logs is really interesting. I’ve also been exploring a tool that uses dynamic program slicing for program comprehension ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/willcrichton\/inliner"
                            },
                            {
                                "type": "text",
                                "text": "), although it’s a little more general in that it uses several source-to-source compiler techniques for simplifying programs, not just dead code elimination. The idea of using cumulative tests to construct diffs between slices is pretty cool, haven’t thought of that before."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "cd775dfe-61d1-4223-9191-4babd33b6539",
        "type": "message",
        "text": "Looks awesome <@UFB8STN7K> ! That is the kind of thing I'm aiming to support in my language. But ideally it should take like 10 lines of code and be something you can just write on the fly. :)",
        "user": "UK3LH8CF5",
        "ts": "1600990758.007800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UK3LH8CF5",
            "ts": "1600990996.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nKu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Looks awesome "
                            },
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " ! That is the kind of thing I'm aiming to support in my language. But ideally it should take like 10 lines of code and be something you can just write on the fly. :)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "4d8ff529-f840-4983-9a57-2b0086e4df21",
        "type": "message",
        "text": "<@UK3LH8CF5> as in a goal of your language is to support high-level program transformations? Do you have an example?",
        "user": "UFB8STN7K",
        "ts": "1600992863.008100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LslW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": " as in a goal of your language is to support high-level program transformations? Do you have an example?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "532fea6d-a2bb-4b85-93bf-96bd280bcf1d",
        "type": "message",
        "text": "I've been thinking lately about how our minds have infinite levels of conceptual hierarchy, but our tools are inevitably limited to some finite number. That discrepancy inevitably leads to loss of information and entropy.",
        "user": "UCUSW7WVD",
        "ts": "1600994019.008400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qLywF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been thinking lately about how our minds have infinite levels of conceptual hierarchy, but our tools are inevitably limited to some finite number. That discrepancy inevitably leads to loss of information and entropy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UK3LH8CF5"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e018b066-e980-44c7-8bbe-772f64226547",
        "type": "message",
        "text": "I talk a bit about the idea at the end of my talk here. <https:\/\/youtu.be\/9fhnJpCgtUw|https:\/\/youtu.be\/9fhnJpCgtUw> I've got a prototype I'm working on. But only so much free time to do it. \n\nBasically the idea is to base the semantics on term rewriting. So the whole language is just data transformation. Then you can have a notion of meta-execution which is rules that match on the execution data. So you can write a rule that just says, tell me the current expression, what it transforms into, and which rule and clause matched that caused that transformation. \n\nIn my prototypes that means I can make a stepping debugger in 3-5 lines of code. And then a time travel debugger in only a few more. Should soon be able to do what we are talking about above as well. \n\nBasically in order to program without a blindfold we need access to the unfolding of the execution of our programs, so why not let it be data that we can match on, query on, etc?",
        "user": "UK3LH8CF5",
        "ts": "1600997792.008700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "\"Meander: Declarative Explorations at the Limits of FP\" by Jimmy Miller",
                "title_link": "https:\/\/youtu.be\/9fhnJpCgtUw",
                "author_name": "Strange Loop",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/9fhnJpCgtUw\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Meander: Declarative Explorations at the Limits of FP\" by Jimmy Miller",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/9fhnJpCgtUw?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/youtu.be\/9fhnJpCgtUw",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/youtu.be\/9fhnJpCgtUw"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "apW2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I talk a bit about the idea at the end of my talk here. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/9fhnJpCgtUw",
                                "text": "https:\/\/youtu.be\/9fhnJpCgtUw"
                            },
                            {
                                "type": "text",
                                "text": " I've got a prototype I'm working on. But only so much free time to do it. \n\nBasically the idea is to base the semantics on term rewriting. So the whole language is just data transformation. Then you can have a notion of meta-execution which is rules that match on the execution data. So you can write a rule that just says, tell me the current expression, what it transforms into, and which rule and clause matched that caused that transformation. \n\nIn my prototypes that means I can make a stepping debugger in 3-5 lines of code. And then a time travel debugger in only a few more. Should soon be able to do what we are talking about above as well. \n\nBasically in order to program without a blindfold we need access to the unfolding of the execution of our programs, so why not let it be data that we can match on, query on, etc?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "+1::skin-tone-3",
                "users": [
                    "U85HCL7JP"
                ],
                "count": 1
            }
        ]
    }
]