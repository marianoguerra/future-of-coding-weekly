[
    {
        "client_msg_id": "56832ec8-2ac7-4321-822d-7fdde819f044",
        "type": "message",
        "text": "Yes I have noticed the unique id and I also really like the idea because this property makes your way of representing things a natural fit for CRDT like systems. I would like to use CRDT for offline first collaborative editing environments and I guess your approach will be perfect as a representation for editable artifacts that are managed by the environment, be it data or logic.",
        "user": "UJ6LDMMN0",
        "ts": "1605966254.258700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/dL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes I have noticed the unique id and I also really like the idea because this property makes your way of representing things a natural fit for CRDT like systems. I would like to use CRDT for offline first collaborative editing environments and I guess your approach will be perfect as a representation for editable artifacts that are managed by the environment, be it data or logic."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605731807.247500",
        "parent_user_id": "UPX3PH28N",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UPX3PH28N"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6bc3fd86-7735-4c54-bc06-254a7ffd90f4",
        "type": "message",
        "text": "Oh yes, <@UPX3PH28N> lazy evaluation introduces \"when\" ambiguity.  The _promise_ of \"later\" makes lazy reasoning too tricky for me.  I dread lazy evaluation — strongly touting non-strict purity.  Instead of \"later,\" commit to \"it shouldn't matter\" — with divergence\/termination\/performance being the subtle difference.  So then the only thing that makes sense to me is for mutable and dynamic variables to resolve to the values they have at the time the non-strict value is defined.",
        "user": "UA14TGLTC",
        "ts": "1606014102.259000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Vgb2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh yes, "
                            },
                            {
                                "type": "user",
                                "user_id": "UPX3PH28N"
                            },
                            {
                                "type": "text",
                                "text": " lazy evaluation introduces \"when\" ambiguity.  The "
                            },
                            {
                                "type": "text",
                                "text": "promise",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of \"later\" makes lazy reasoning too tricky for me.  I dread lazy evaluation — strongly touting non-strict purity.  Instead of \"later,\" commit to \"it shouldn't matter\" — with divergence\/termination\/performance being the subtle difference.  So then the only thing that makes sense to me is for mutable and dynamic variables to resolve to the values they have at the time the non-strict value is defined."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK"
    }
]