[
    {
        "client_msg_id": "781ba3d1-b251-47c1-bf3d-5b84160dc4a8",
        "type": "message",
        "text": "Are there languages where files are functions and imports are parameters?\n\nI am annoyed with file path issues when building typescript. When I try to build the same exact files with tsc, webpack, jest, or yarn, I get 4 different results.\n\nAre there any languages out there where a file is a function that takes parameters which are the paths to its imports? Where you don't include a file, but call it? Built-in dependency injection at the build level?\n\nie:\n\n\n`\/\/ main.foo`\n`printLib = printLib ?? \"a_default_value_for_print.foo_import\"`\n\n`printLib.print \"hello world\"`\n\n`\/\/ project.build`\n`main.foo(printLib = \"print.foo\")`",
        "user": "UMVFWPZ36",
        "ts": "1606580326.162400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UMVFWPZ36",
            "ts": "1606580985.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CPsx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there languages where files are functions and imports are parameters?\n\nI am annoyed with file path issues when building typescript. When I try to build the same exact files with tsc, webpack, jest, or yarn, I get 4 different results.\n\nAre there any languages out there where a file is a function that takes parameters which are the paths to its imports? Where you don't include a file, but call it? Built-in dependency injection at the build level?\n\nie:\n\n\n"
                            },
                            {
                                "type": "text",
                                "text": "\/\/ main.foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "printLib = printLib ?? \"a_default_value_for_print.foo_import\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "printLib.print \"hello world\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "\/\/ project.build",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "main.foo(printLib = \"print.foo\")",
                                "style": {
                                    "code": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "reply_count": 4,
        "reply_users_count": 3,
        "latest_reply": "1606745437.172700",
        "reply_users": [
            "U8A5MS6R1",
            "UMVFWPZ36",
            "UJBAJNFLK"
        ],
        "replies": [
            {
                "user": "U8A5MS6R1",
                "ts": "1606582534.162700"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1606591555.165800"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1606591586.166000"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1606745437.172700"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "6e6de199-5575-47a9-b512-a5dc9cb4af0a",
        "type": "message",
        "text": "Newspeak\n\nThere is no import statement or hard linked external dependencies. Modules are just top level classes you instantiate and pass in the deps. See <https:\/\/bracha.org\/newspeak-modules.pdf|https:\/\/bracha.org\/newspeak-modules.pdf>\nand <https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html|https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html>",
        "user": "U8A5MS6R1",
        "ts": "1606582534.162700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Serialization Killer",
                "title_link": "https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html",
                "text": "Way back in October 2009 , I threatened to write a post about how serialization can serve as a binary format. The moment of reckoning has ar...",
                "fallback": "Serialization Killer",
                "from_url": "https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html",
                "service_icon": "https:\/\/gbracha.blogspot.com\/favicon.ico",
                "service_name": "gbracha.blogspot.com",
                "id": 1,
                "original_url": "https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/W9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Newspeak\n\nThere is no import statement or hard linked external dependencies. Modules are just top level classes you instantiate and pass in the deps. See "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bracha.org\/newspeak-modules.pdf",
                                "text": "https:\/\/bracha.org\/newspeak-modules.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\nand "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html",
                                "text": "https:\/\/gbracha.blogspot.com\/2010\/02\/serialization-killer.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "U019CPED6T1",
                    "UD31LGQKB"
                ],
                "count": 3
            },
            {
                "name": "clap",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "E6546697-C262-42BF-80E5-D5C55CA5D10C",
        "type": "message",
        "text": "infra includes a few interesting properties: a “patch” datatype, which represents references to other infra data as well as immutable changes, using the same format as the rest of the data, and an editor that lets you make changes to data with mouse and keyboard and then outputs the changed data with a record in the form of patches",
        "user": "UHWC9PXBL",
        "ts": "1606586289.165500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Ofx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "infra includes a few interesting properties: a “patch” datatype, which represents references to other infra data as well as immutable changes, using the same format as the rest of the data, and an editor that lets you make changes to data with mouse and keyboard and then outputs the changed data with a record in the form of patches"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3ab6b13c-f2e6-4127-a2be-2a86c1c6a09a",
        "type": "message",
        "text": "The relevant bits: \"Imports Code within a module must often make use of code defined by other modules. For example, ShapeLibrary requires utility classes such as List, defined by the standard collections library. In the absence of a global namespace, there is no way to refer to a class such as List directly. Instead, we have defined a slot named List inside ShapeLibrary. The slot declarations used in figure 2 differ slightly from our earlier examples. Here, slot initialization uses = rather than ::=. The use of = signifies that these are immutable slots, that will not be changed after they are initialized. No setter methods are generated for immutable slots, thus enforcing immutability. When ShapeLibrary is instantiated, it expects an object representing the underlying platform as an argument to its factory method usingPlatform:. This object will be the value of the factory method’s formal parameter platform. During the initialization of the module, the slot List will be initialized via the expression platform collections List. This sends the message collections to platform, presumably returning an object representing an instance of the platform’s collection library. This object then responds to the message List, returning the desired class. The class is stored in the slot, and is available to code within the module definition via the slot’s getter method. The slot definition of List fills the role of an import statement, as do those of Error and Point. Note that the parameters to the factory method are only in scope within the instance initializer. The programmer must take explicit action to make (parts of) them available to the rest of the module. The preferred idiom is to extract individual classes and store them in slots, as shown here. It is then possible to determine the module’s external dependencies at a glance, by looking at the instance initializer. Encouraging this idiom is the prime motivation for restricting the scope of the factory arguments to the initializer\"",
        "user": "UMVFWPZ36",
        "ts": "1606591555.165800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bpn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The relevant bits: \"Imports Code within a module must often make use of code defined by other modules. For example, ShapeLibrary requires utility classes such as List, defined by the standard collections library. In the absence of a global namespace, there is no way to refer to a class such as List directly. Instead, we have defined a slot named List inside ShapeLibrary. The slot declarations used in figure 2 differ slightly from our earlier examples. Here, slot initialization uses = rather than ::=. The use of = signifies that these are immutable slots, that will not be changed after they are initialized. No setter methods are generated for immutable slots, thus enforcing immutability. When ShapeLibrary is instantiated, it expects an object representing the underlying platform as an argument to its factory method usingPlatform:. This object will be the value of the factory method’s formal parameter platform. During the initialization of the module, the slot List will be initialized via the expression platform collections List. This sends the message collections to platform, presumably returning an object representing an instance of the platform’s collection library. This object then responds to the message List, returning the desired class. The class is stored in the slot, and is available to code within the module definition via the slot’s getter method. The slot definition of List fills the role of an import statement, as do those of Error and Point. Note that the parameters to the factory method are only in scope within the instance initializer. The programmer must take explicit action to make (parts of) them available to the rest of the module. The preferred idiom is to extract individual classes and store them in slots, as shown here. It is then possible to determine the module’s external dependencies at a glance, by looking at the instance initializer. Encouraging this idiom is the prime motivation for restricting the scope of the factory arguments to the initializer\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "687f04c6-63de-4383-af91-4472ad6a0959",
        "type": "message",
        "text": "(better of course to look at the PDF to see the source example, but just wanted to paste that for easier ctrl+f)",
        "user": "UMVFWPZ36",
        "ts": "1606591586.166000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I5u62",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(better of course to look at the PDF to see the source example, but just wanted to paste that for easier ctrl+f)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "c09fbad6-8319-428f-827d-b7a02415daf6",
        "type": "message",
        "text": "In this comment I present a counterpoint to what I think <@UCUSW7WVD> is saying here:\n&gt;  Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n&gt; _&lt;snipped a long list of mechanism details pertaining to function invocation&gt;_\nhere:\n&gt;  Shannon's law of entropy you have to trade off flexibility for concision\nand here:\n&gt; _\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"_\nFunnily I kind of agree with Kartik but only while we stick to the current models of abstraction.\n\nI'm going to use the following analogy to describe how I think about this. Imagine we are all \"electronics people\" making circuit boards with LEDs, batteries, wires, switches etc. We send signals around encoded as voltage-on-wire or even FM. Note that voltage-on-wire serves a higher purpose (e.g. a specific voltage on a line may represent the \"turn this light on\" signal). We create  wired-ports\/FM transmitters\/recievers to hook up multiple such gizmos together. Unfortunately we all use different conventions for _how_ the voltage levels or FM bands correspond to the the signals we share. So most of our integration work is spent building adapters - the simple ones might just step up\/down the voltage. The complex ones may receive a signal encoded as FM and re-encode the same signal as voltage-on-wire, or even re-transmit it on another FM band. There's nothing wrong with this because _this is reality_.\n\nOTOH, we can also think of making things better, or even doing something  _different_. Here, and this is key, I think there are two broad paths:\n\n1. Standardize. If everyone uses 5V and the same FM band and the same \"encoding\" of the shared signals, we can more easily plug things with each other. _We're still electronics people, doing mostly the same thing,_ but better and easier.\n2. A new level of abstraction. Say we completely stop thinking about voltages and think in a new level of abstraction called \"bytes\". This is the idea of software. I'd say we're now doing a fundamentally different thing - _we now are \"software people\" and no longer electronics people_ - because we are absolved of concerns about voltages and such things. The voltage didn't disappear, but don't matter directly to us. In fact many different physical contraptions may use very different physical mechanisms to represent the same bytes, but from our abstraction level, we still think of those disparate systems through a unified model of \"bytes\".\nNow the next chapter.. bytes are themselves problematic in ways that resemble voltage and FM band mismatches. The thing is bytes are used to represent \"higher purpose\" signals and messages that we send around - so encoding matters, again. The first approach is \"standardize the encodings\". This is very popular (cue this history of byte formats). But is there a second approach which would _make bytes irrelevant_ _to us_? What are the new concepts we would think and design in? We may end up with many different byte level encodings for the same messages we send around but we will have a new unified model of design across all of them. We will no longer be \"bytes people\", so what will we be? (BTW, eventually we could forego bytes completely in some cases and map directly to voltage or other physical representations.)",
        "user": "U8A5MS6R1",
        "ts": "1606594264.166300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606594412.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SBKR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In this comment I present a counterpoint to what I think "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " is saying here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n"
                            },
                            {
                                "type": "text",
                                "text": "<snipped a long list of mechanism details pertaining to function invocation>",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Shannon's law of entropy you have to trade off flexibility for concision"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFunnily I kind of agree with Kartik but only while we stick to the current models of abstraction.\n\nI'm going to use the following analogy to describe how I think about this. Imagine we are all \"electronics people\" making circuit boards with LEDs, batteries, wires, switches etc. We send signals around encoded as voltage-on-wire or even FM. Note that voltage-on-wire serves a higher purpose (e.g. a specific voltage on a line may represent the \"turn this light on\" signal). We create  wired-ports\/FM transmitters\/recievers to hook up multiple such gizmos together. Unfortunately we all use different conventions for "
                            },
                            {
                                "type": "text",
                                "text": "how",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the voltage levels or FM bands correspond to the the signals we share. So most of our integration work is spent building adapters - the simple ones might just step up\/down the voltage. The complex ones may receive a signal encoded as FM and re-encode the same signal as voltage-on-wire, or even re-transmit it on another FM band. There's nothing wrong with this because "
                            },
                            {
                                "type": "text",
                                "text": "this is reality",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nOTOH, we can also think of making things better, or even doing something  "
                            },
                            {
                                "type": "text",
                                "text": "different",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Here, and this is key, I think there are two broad paths:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Standardize. If everyone uses 5V and the same FM band and the same \"encoding\" of the shared signals, we can more easily plug things with each other. "
                                    },
                                    {
                                        "type": "text",
                                        "text": "We're still electronics people, doing mostly the same thing, ",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "but better and easier."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A new level of abstraction. Say we completely stop thinking about voltages and think in a new level of abstraction called \"bytes\". This is the idea of software. I'd say we're now doing a fundamentally different thing - "
                                    },
                                    {
                                        "type": "text",
                                        "text": "we now are \"software people\" and no longer electronics people",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " - because we are absolved of concerns about voltages and such things. The voltage didn't disappear, but don't matter directly to us. In fact many different physical contraptions may use very different physical mechanisms to represent the same bytes, but from our abstraction level, we still think of those disparate systems through a unified model of \"bytes\"."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNow the next chapter.. bytes are themselves problematic in ways that resemble voltage and FM band mismatches. The thing is bytes are used to represent \"higher purpose\" signals and messages that we send around - so encoding matters, again. The first approach is \"standardize the encodings\". This is very popular (cue this history of byte formats). But is there a second approach which would "
                            },
                            {
                                "type": "text",
                                "text": "make bytes irrelevant",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "to us",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? What are the new concepts we would think and design in? We may end up with many different byte level encodings for the same messages we send around but we will have a new unified model of design across all of them. We will no longer be \"bytes people\", so what will we be? (BTW, eventually we could forego bytes completely in some cases and map directly to voltage or other physical representations.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "873dab04-3373-4e47-8c65-f50e09c747cf",
        "type": "message",
        "text": "what you are describing sounds  an awful lot like networking. In networking you go from radio, copper. fiber optic mediums to ... bytes, and then more layers of bytes by packing in \"layers\". The way systems like TCP\/IP has been successful is .. by standardizing. I may be wrong but it sounds like you are thinking there may be something undiscovered that is superior to \"arranging bits\", but encoding and decoding data just seems like the nature of the problem.",
        "user": "UN9SCH5RD",
        "ts": "1606607135.166800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaa31b79aded",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Emmanuel Oga",
            "display_name": "Emmanuel Oga",
            "team": "T5TCAFTA9",
            "name": "emmanueloga",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bi\/WR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "what you are describing sounds  an awful lot like networking. In networking you go from radio, copper. fiber optic mediums to ... bytes, and then more layers of bytes by packing in \"layers\". The way systems like TCP\/IP has been successful is .. by standardizing. I may be wrong but it sounds like you are thinking there may be something undiscovered that is superior to \"arranging bits\", but encoding and decoding data just seems like the nature of the problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "bb475ffc-279a-4c91-bd80-ff0b63e834e8",
        "type": "message",
        "text": "I'm not proposing a solution but rather suggesting a perspective on the problem. It's not about superior, but the about virtual concepts we work with. Yes it is about what concepts have been standardized. E.g. TCP\/IP will work across copper wire, _or_ radio frequency _or_ microwave frequency _or_ any other medium the someone cares to map it to.\n\nI could just as correctly say \"designing circuits or radio frequencies is just the nature of the problem\". Yet in decades of building systems that _transmit information_ I have never once had to design the mapping of information to radio frequencies. Yet I have often designed (or reckoned with) the mapping of information to _bits._ You could standardize on a concept higher level than bits of course, (one example is something based on \"symbols\"). In fact we always work with higher levels within PLs or frameworks. Yet the OS and networks stop at giving us support for bits.",
        "user": "U8A5MS6R1",
        "ts": "1606611089.167000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lVA8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not proposing a solution but rather suggesting a perspective on the problem. It's not about superior, but the about virtual concepts we work with. Yes it is about what concepts have been standardized. E.g. TCP\/IP will work across copper wire, "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " radio frequency "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " microwave frequency "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " any other medium the someone cares to map it to.\n\nI could just as correctly say \"designing circuits or radio frequencies is just the nature of the problem\". Yet in decades of building systems that "
                            },
                            {
                                "type": "text",
                                "text": "transmit information",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " I have never once had to design the mapping of information to radio frequencies. Yet I have often designed (or reckoned with) the mapping of information to "
                            },
                            {
                                "type": "text",
                                "text": "bits. ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "You could standardize on a concept higher level than bits of course, (one example is something based on \"symbols\"). In fact we always work with higher levels within PLs or frameworks. Yet the OS and networks stop at giving us support for bits."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "69e0c189-f475-47b3-aedd-b42b0811bfc2",
        "type": "message",
        "text": "Since software is executable, it gives us much more powerful ways of re-configuring than we can have with hardware. With hardware the encodings tend to be fixed. With software we can look at standardizing the bare minimum and leveraging its reconfigurability. For instance instead of standardizing \"encodings\" we could standardize \"encoding grammar\" which are pre-shared, but any real encodings can just be defined using this grammar and sent on the wire. Any receiver can then generate encoder\/decoder on the fly. This doesn't do away with bits but encapsulates them in a way.",
        "user": "U8A5MS6R1",
        "ts": "1606612182.167300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606612219.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o0mrS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Since software is executable, it gives us much more powerful ways of re-configuring than we can have with hardware. With hardware the encodings tend to be fixed. With software we can look at standardizing the bare minimum and leveraging its reconfigurability. For instance instead of standardizing \"encodings\" we could standardize \"encoding grammar\" which are pre-shared, but any real encodings can just be defined using this grammar and sent on the wire. Any receiver can then generate encoder\/decoder on the fly. This doesn't do away with bits but encapsulates them in a way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3875c2d5-5a0a-46fa-991a-d9d4be19bd7a",
        "type": "message",
        "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language. Maybe a total language depending on your definition. I mean, the idea is pretty close to what I want to do\/see, but even these \"grammars\" have to be encoded to be shared, and standardizing that encoding won't be any easier than the others.\n\nI think of this as \"encoding\" vs \"intent\". Intent is the human purpose for whatever the system is supposed to do. We would really like to specify everything in terms of intent, both messages and programs, but intent is inherently non-physical (unless you want to talk about neurology). You can't standardize intent, or transmit it. I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\n\nMy design goals, as far as I've nailed them down, revolve in large part around precisely capturing intent, in particular, _avoiding_ encoding things that are not intended but merely side effects of the encoding a user is using to convey their intent to a computer. One of my catchphrases is \"as specific as desired\", something I've thought about since I first felt straitjacketed by a mind-mapping app. Implicit ordering and implicit dependencies are quite pernicious, e.g. a supposedly unordered map that is nevertheless processed in order and allows\/requires you to make assumptions based on that order. (Notably, bit strings are always ordered, which in a way is the fundamental obstacle.)\n\nI've gotten as far as \"make all dependencies explicit and optional (including ordering)\" and \"define things by the effects (in the sense of I\/O!) they produce\". What form of communication your intent produces, or whether it results in native code, is a matter of encoding, to be specified independently; as I (and Emmanuel I guess) said, the OS's job. Details are WIP. :-\/",
        "user": "U016VUZGUUQ",
        "ts": "1606620852.167600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UMZn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language. Maybe a total language depending on your definition. I mean, the idea is pretty close to what I want to do\/see, but even these \"grammars\" have to be encoded to be shared, and standardizing that encoding won't be any easier than the others.\n\nI think of this as \"encoding\" vs \"intent\". Intent is the human purpose for whatever the system is supposed to do. We would really like to specify everything in terms of intent, both messages and programs, but intent is inherently non-physical (unless you want to talk about neurology). You can't standardize intent, or transmit it. I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\n\nMy design goals, as far as I've nailed them down, revolve in large part around precisely capturing intent, in particular, "
                            },
                            {
                                "type": "text",
                                "text": "avoiding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " encoding things that are not intended but merely side effects of the encoding a user is using to convey their intent to a computer. One of my catchphrases is \"as specific as desired\", something I've thought about since I first felt straitjacketed by a mind-mapping app. Implicit ordering and implicit dependencies are quite pernicious, e.g. a supposedly unordered map that is nevertheless processed in order and allows\/requires you to make assumptions based on that order. (Notably, bit strings are always ordered, which in a way is the fundamental obstacle.)\n\nI've gotten as far as \"make all dependencies explicit and optional (including ordering)\" and \"define things by the effects (in the sense of I\/O!) they produce\". What form of communication your intent produces, or whether it results in native code, is a matter of encoding, to be specified independently; as I (and Emmanuel I guess) said, the OS's job. Details are WIP. :-\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "b45f2140-396a-4bbe-b143-1b52eb0ac0f4",
        "type": "message",
        "text": "<@U016VUZGUUQ> wrote\n&gt; In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language.\nI agree.\n&gt; I think of this as \"encoding\" vs \"intent\".\nYou've put this really well. I think of this as \"meaning\", which only exists in our minds, and \"representations\" and \"mechanisms\" which exist outside the mind.\n&gt; I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\nIf you're saying that irrespective of the encoding, the machines can only hold _signifiers_ and all mechanisms in the end amount to just transmitting arbitrary symbols (bits are just a sequence of symbols \"1\", \"0\") I must agree. But consider that we spend a lot of effort designing and manually implementing the mapping between _multiple_ vocabularies of such symbols - all of which are entirely in the machine. So there is the possibility of removing this extra work. (BTW, <@UJBAJNFLK> and I have a <https:\/\/shalabh.com\/programmable-systems\/files-and-file-formats.html#comment-7|discussion> on this topic on my blog post).\n\n&gt; _avoiding_ encoding things that are \n&gt; not intended but merely side effects of the encoding a user is using to \n&gt; convey their intent to a computer\nNicely put. In some sense these are _encoding artifacts_. Looking forward to see where you take these ideas.",
        "user": "U8A5MS6R1",
        "ts": "1606631008.167900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606631112.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kTYU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " wrote\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think of this as \"encoding\" vs \"intent\"."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You've put this really well. I think of this as \"meaning\", which only exists in our minds, and \"representations\" and \"mechanisms\" which exist outside the mind.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you're saying that irrespective of the encoding, the machines can only hold "
                            },
                            {
                                "type": "text",
                                "text": "signifiers",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and all mechanisms in the end amount to just transmitting arbitrary symbols (bits are just a sequence of symbols \"1\", \"0\") I must agree. But consider that we spend a lot of effort designing and manually implementing the mapping between "
                            },
                            {
                                "type": "text",
                                "text": "multiple",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " vocabularies of such symbols - all of which are entirely in the machine. So there is the possibility of removing this extra work. (BTW, "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " and I have a "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/shalabh.com\/programmable-systems\/files-and-file-formats.html#comment-7",
                                "text": "discussion"
                            },
                            {
                                "type": "text",
                                "text": " on this topic on my blog post).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "avoiding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " encoding things that are \nnot intended but merely side effects of the encoding a user is using to \nconvey their intent to a computer"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nicely put. In some sense these are "
                            },
                            {
                                "type": "text",
                                "text": "encoding artifacts",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Looking forward to see where you take these ideas."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    }
]