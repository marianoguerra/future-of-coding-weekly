[
    {
        "client_msg_id": "db32d11c-fbea-4423-b610-196e1b619701",
        "type": "message",
        "text": "Have you read the python zen?\n\n```&gt;&gt;&gt; import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!```\n",
        "user": "UBN9AFS0N",
        "ts": "1582620288.027300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wdce",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Have you read the python zen?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": ">>> import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ],
        "thread_ts": "1582620288.027300",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1582870431.044500",
        "reply_users": [
            "UPVBV34EL",
            "UKDM3GLAJ",
            "UC6997THT"
        ],
        "replies": [
            {
                "user": "UPVBV34EL",
                "ts": "1582624294.030800"
            },
            {
                "user": "UKDM3GLAJ",
                "ts": "1582644280.031800"
            },
            {
                "user": "UC6997THT",
                "ts": "1582870431.044500"
            }
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "59ac5b60-a2ab-456d-8685-5c5de8785c13",
        "type": "message",
        "text": "what's your language\/tool zen?",
        "user": "UBN9AFS0N",
        "ts": "1582620294.027500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NJvqM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "what's your language\/tool zen?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "client_msg_id": "07b581b1-469c-4d67-92dc-6c2e4ba8d482",
        "type": "message",
        "text": "Ruby quote time...\n\nRuby is designed to be human-oriented. It reduces the burden of programming. It tries to push jobs back to machines. You can accomplish more tasks with less work, in smaller yet readable code. (Matz)\n\nRuby is a very free-form community.  Matz is the most benevolent dictator I've had the pleasure to work with, and most of the community are true free-thinking artists.  It's like the hippie commune of the language world.  (Charles Nutter)\n\nRuby seems so self-explanatory to me. It makes it almost boring; you try to focus on Ruby and you wind up talking about some problem domain instead of the language.  (Steve Yegge)",
        "user": "UA14TGLTC",
        "ts": "1582621803.028000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dmEQ0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ruby quote time...\n\nRuby is designed to be human-oriented. It reduces the burden of programming. It tries to push jobs back to machines. You can accomplish more tasks with less work, in smaller yet readable code. (Matz)\n\nRuby is a very free-form community.  Matz is the most benevolent dictator I've had the pleasure to work with, and most of the community are true free-thinking artists.  It's like the hippie commune of the language world.  (Charles Nutter)\n\nRuby seems so self-explanatory to me. It makes it almost boring; you try to focus on Ruby and you wind up talking about some problem domain instead of the language.  (Steve Yegge)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582621803.028000",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1582637876.031400",
        "reply_users": [
            "U5STGTB3J",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "U5STGTB3J",
                "ts": "1582624095.030600"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1582635748.031000"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1582637460.031200"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1582637876.031400"
            }
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "USH01JEDQ",
                    "UUH505U23",
                    "UMWF81HTP",
                    "UCXR52MU2"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "9e156c1e-81a2-4db8-bb00-4c9577303617",
        "type": "message",
        "text": "For Haskell, I like <https:\/\/www.willamette.edu\/~fruehr\/haskell\/evolution.html> and <https:\/\/www.willamette.edu\/~fruehr\/haskell\/seuss.html>.",
        "user": "UA14TGLTC",
        "ts": "1582621858.028400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mc0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For Haskell, I like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.willamette.edu\/~fruehr\/haskell\/evolution.html"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.willamette.edu\/~fruehr\/haskell\/seuss.html"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UUH505U23"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "07EABD1C-FCB3-4865-94FA-AD5E7B802692",
        "type": "message",
        "text": "I have to admit that in my Ruby days, this was the only language where it happened to me surprisingly often that I would just write a piece of code without looking at the documentation thinking “I have no idea but I feel like this is how that should work” — and it did.",
        "user": "U5STGTB3J",
        "ts": "1582624095.030600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Y+=\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have to admit that in my Ruby days, this was the only language where it happened to me surprisingly often that I would just write a piece of code without looking at the documentation thinking “I have no idea but I feel like this is how that should work” — and it did."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582621803.028000",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "d0279644-688b-496f-bbde-bc986746077c",
        "type": "message",
        "text": "Yes, and love it :heart:",
        "user": "UPVBV34EL",
        "ts": "1582624294.030800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "259a1e56ad2e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-28\/811814014976_259a1e56ad2e11fe3d56_72.jpg",
            "first_name": "",
            "real_name": "Shubhadeep Roychowdhury",
            "display_name": "Shubhadeep Roychowdhury",
            "team": "T5TCAFTA9",
            "name": "shubhadeeproychowdhur",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "leI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, and love it "
                            },
                            {
                                "type": "emoji",
                                "name": "heart"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582620288.027300",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "d9c7f12c-a6d1-4157-aebe-c40c93c2fbb6",
        "type": "message",
        "text": "Ruby is so delightfully unsound: perpetually punting on precision and completeness, favoring a sort of joy and ease.",
        "user": "UA14TGLTC",
        "ts": "1582635748.031000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/4u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ruby is so delightfully unsound: perpetually punting on precision and completeness, favoring a sort of joy and ease."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582621803.028000",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "d1579326-0500-4c1e-8745-f822aef461e1",
        "type": "message",
        "text": "For example, here's one that broke me — just now.  After writing it thousands of times, I cannot type this idiom anymore:\n```hash_mapping_x_to_fx = Hash[xs.map{|x| [x, f(x)]] ```\nFrom now on, I'm going with:\n```hash_mapping_x_to_fx = xs.hap{|x| f(x)}```\nRemember \"Ruby was a Lisp originally, in theory.\"  So the definition, for those unfamiliar, can be simple as:\n```module Enumerable\n  def hap\n    Hash[map{|x| [x, yield(x)]}]\n  end\nend```",
        "user": "UA14TGLTC",
        "ts": "1582637460.031200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZrI7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example, here's one that broke me — just now.  After writing it thousands of times, I cannot type this idiom anymore:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "hash_mapping_x_to_fx = Hash[xs.map{|x| [x, f(x)]] "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From now on, I'm going with:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "hash_mapping_x_to_fx = xs.hap{|x| f(x)}"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Remember \"Ruby was a Lisp originally, in theory.\"  So the definition, for those unfamiliar, can be simple as:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "module Enumerable\n  def hap\n    Hash[map{|x| [x, yield(x)]}]\n  end\nend"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582621803.028000",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "80e7325e-0c19-4722-9047-75281a277788",
        "type": "message",
        "text": "Certainly other languages have similar capabilities especially now that Ruby is getting to be about thirty.",
        "user": "UA14TGLTC",
        "ts": "1582637876.031400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UA14TGLTC",
            "ts": "1582637886.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rQv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Certainly other languages have similar capabilities especially now that Ruby is getting to be about thirty."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582621803.028000",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "692efdfc-c60f-42b8-875c-7dc0c5c80413",
        "type": "message",
        "text": "&gt; Simple is better than complex.\n&gt; Complex is better than complicated.\nHas had more influence on the way I write code than any other ten words.",
        "user": "UKDM3GLAJ",
        "ts": "1582644280.031800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "34e7a55348e8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-04\/893378739792_34e7a55348e8c86c1901_72.jpg",
            "first_name": "",
            "real_name": "Jared Windover",
            "display_name": "Jared Windover",
            "team": "T5TCAFTA9",
            "name": "jaredwindover",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V1e",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Simple is better than complex.\nComplex is better than complicated."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Has had more influence on the way I write code than any other ten words."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582620288.027300",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6a436863-72d1-437e-b134-8b0fc57f9640",
        "type": "message",
        "text": "Interesting, thanks for sharing! I used to use Leo ages ago, but gave up on it at some point because OrgMode in Emacs was more convenient (mainly because I needed Emacs anyway). I was surprised to see that Leo is still alive (it was and still is an essentially one-person project), and even more to see that it is developing a tool ecosystem around it!",
        "user": "UJBAJNFLK",
        "ts": "1582663176.032300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g05e4cf66ef1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/305e4cf66ef1179f7e95981b1520ba1a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2yRZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting, thanks for sharing! I used to use Leo ages ago, but gave up on it at some point because OrgMode in Emacs was more convenient (mainly because I needed Emacs anyway). I was surprised to see that Leo is still alive (it was and still is an essentially one-person project), and even more to see that it is developing a tool ecosystem around it!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582604635.026600",
        "parent_user_id": "UF1ATC4RF"
    },
    {
        "client_msg_id": "A3843500-59F9-42B2-A2CE-526A2ACD2E2B",
        "type": "message",
        "text": "Are there any languages that make fluid use of linguistic context, as in overloading variables\/symbols, type-specific sub-languages\/operations\/functions? I brainstorm here just because variable names tend to get long and complicated in any language, making thought too verbose. For instance, ‘Maybe Int = Just Int | Nothing’ seems incredibly verbose for something that gets passed around a lot in Haskell.\n\nSo if there is anything that makes variables\/function names\/types easier within specific contexts —at the cost of readability but making experimentation easy — that would be greatly appreciated",
        "user": "USUMN6XLH",
        "ts": "1582695411.037800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8a3bc278696f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-26\/922460775044_8a3bc278696f955af590_72.jpg",
            "first_name": "Josh",
            "real_name": "Josh Cho",
            "display_name": "Josh Cho",
            "team": "T5TCAFTA9",
            "name": "joshchonpc",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dbo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there any languages that make fluid use of linguistic context, as in overloading variables\/symbols, type-specific sub-languages\/operations\/functions? I brainstorm here just because variable names tend to get long and complicated in any language, making thought too verbose. For instance, ‘Maybe Int = Just Int | Nothing’ seems incredibly verbose for something that gets passed around a lot in Haskell.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "So if there is anything that makes variables\/function names\/types easier within specific contexts —at the cost of readability but making experimentation easy — that would be greatly appreciated"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1582757598.042400",
        "reply_users": [
            "UFB8STN7K",
            "UJBAJNFLK",
            "UEQ6M68H0"
        ],
        "replies": [
            {
                "user": "UFB8STN7K",
                "ts": "1582697396.038000"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1582710751.041600"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1582757598.042400"
            }
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "b33c702a-2fc6-4dbb-83c2-4e8e642e34f2",
        "type": "message",
        "text": "most theorem provers I think fall into this category, e.g.  lean <https:\/\/leanprover.github.io\/theorem_proving_in_lean\/interacting_with_lean.html#notation>",
        "user": "UFB8STN7K",
        "ts": "1582697396.038000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NZ8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "most theorem provers I think fall into this category, e.g.  lean "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/leanprover.github.io\/theorem_proving_in_lean\/interacting_with_lean.html#notation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "parent_user_id": "USUMN6XLH",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "USUMN6XLH"
                ],
                "count": 1
            }
        ]
    }
]