[
    {
        "client_msg_id": "ed0fcb47-960e-4882-8be2-e5299eefd6ae",
        "type": "message",
        "text": "Hi Eddy, I think the idea of working backwards from the desired result is an awesome idea! Much of the problems that the software industry has are do to working with some complex mechanism (language, tool, pattern, etc.) and then trying to \"emerge\" the human model out of it -- which is completely backwards to what makes sense! That's why the human model becomes an afterthought, and software does things people don't expect, and nobody knows what to even look for to fix the situation: they're working from the wrong end!\n\nAnyway, I talked at length in another thread about my thoughts on this, and how I'm approaching the problem of getting rigid mechanism or of the way by making it possible to freely scult whatever it means to design \/ code \/ model whatever it is that one is trying to do, rather than starting with a broken model and going the other way.\n\nIt's a lot to reformulate on this context, so here's a link to that post \/ thread: <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&amp;cid=C5T9GPWFL|https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&amp;cid=C5T9GPWFL>",
        "user": "UAVCC2X70",
        "ts": "1585004552.083800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&amp;cid=C5T9GPWFL",
                "fallback": "[March 20th, 2020 9:24 PM] dcook0819: I'll explain what I'm building in phases, because it's not about the specific tool, but the process that it enables:\n\nI'm building a tool in which code and data can be edited and interacted with as live objects on a canvas. Code and data are made of the same \"building blocks\" (structural representation) that can be inspected, edited, and executed (interpreted) directly from the live structure.\n\nAll the LIVE code for the tool itself -- including the user interface and the interpreter -- is also exposed for live editing through the same interface. You can use the tool, to completely change itself (down to the metal if you like) to work completely differently. This entire transformation can happen at runtime, without the tool ever \"stopping\".\n\nWhat I'm making is much more about this self-bootstrapping ability\/ process, than it is about a specific tool that works a specific way. Building a specific tool is only necessary in the first place, just to bootstrap this ability into existence. So the initial \"tool\" just has to be minimally capable, even if it sucks -- and from there, I'll evolve it into something better through direct manipulation.\n\nImagine a robot capable of physically modifying itself, and programmed to improve itself. Even if it's not great at that, it could improve it's ability to improve itself, or even it's criteria for reasoning about what that means. If you can somehow make that initial robot _at all_, no matter how crappy, then you've succeeded in bootstrapping arbitrarily better robots. That's what I'm trying to do, but with software &amp; programming.\n\nThere's more to it than that, which is my philosophy on \"programming language\" not needing to be a solidly defined thing, or perhaps not even a thing at all! What is a compiler or interpreter, other than just code that operates on code? Why not put THAT code and YOUR code all in the same bucket? Instead of code + compiler, you have code (in whatever form makes sense for the context) + other code that executes or translates that code?\n\nHere is where the line blurs between programming language, and having code that iterates over a hardcoded list to avoid having to repeat a bunch of code that differs only by specific values. That's as much of a \"language\" as the one your code is written in!\n\nNow take that to the extreme, but think of being able to customize your own visual representation and \/ or editor for whatever makes sense for a given context. Imagine if \"code\" could contain instructions that told your IDE how to behave? That's the same as putting your code and the code OF the IDE in the same codebase. Just like I described for removing the separation between compiler + code.\n\nOne (example) vision I have is that \"code\" for something is not a text file that you open in another tool, but a self-contained executable program that, when you run it, presents you with a custom interface \/ model for \"the code\", including the code of the whole running program &amp; interface that it presents. No more dependency on some other interface! It's the same idea (in a sense) as infrastructure as code, or HATEOS\n\nBut what's that? you need a Java program? Fine, click a button, and it spits out a compiled-to-Java equivalent of \"just the product code\". Any code in any language or for any system, has a structure, and there's no reason that cannot be stored and executed as a _live_ structural representation, prior to generating the actual \"compiled\" built product from it.\n\nWhat's that? Execution in the tool is not the same as execution in the JVM (or whatever other target)? Well, the tool is written \"in itself\", and you already made a generate-the-equivalent-Java-code functionality; use that on the tool itself, and bootstrap the tool right into the JVM (or what have you). That's one perk of having just some generic code model with self contained rules for execution or translation.\n\nThere are so so many things and approaches and models for what \"code\" could be and how to model or visualize it, how it can be edited or projected, and what to even DO with the code (e.g. translate it) ... a tool like this would make it very easy to explore that space.\n\nWhat if the representation I choose is not great? What if the tools and process I provide for molding better tools and processes, really sucks? Well, then I mold better things for molding better things.\n\nSoftware is not just made of levers; it's made of levers for making levers. And I want to put that power in everyone's hands. This makes sense not just for programmers, but also for everyone else: What the heck does it even mean to have the power of a computer in your hand, without actually having any power of a computer in your hand? What a joke!\n\nBut what if people suck at computer stuff, though? Well gosh, if only they had the power of a computer to assist with using the power of a computer...",
                "ts": "1584764693.467400",
                "author_id": "UAVCC2X70",
                "author_subname": "Dan Cook",
                "channel_id": "C5T9GPWFL",
                "channel_name": "general",
                "is_msg_unfurl": true,
                "is_reply_unfurl": true,
                "text": "I'll explain what I'm building in phases, because it's not about the specific tool, but the process that it enables:\n\nI'm building a tool in which code and data can be edited and interacted with as live objects on a canvas. Code and data are made of the same \"building blocks\" (structural representation) that can be inspected, edited, and executed (interpreted) directly from the live structure.\n\nAll the LIVE code for the tool itself -- including the user interface and the interpreter -- is also exposed for live editing through the same interface. You can use the tool, to completely change itself (down to the metal if you like) to work completely differently. This entire transformation can happen at runtime, without the tool ever \"stopping\".\n\nWhat I'm making is much more about this self-bootstrapping ability\/ process, than it is about a specific tool that works a specific way. Building a specific tool is only necessary in the first place, just to bootstrap this ability into existence. So the initial \"tool\" just has to be minimally capable, even if it sucks -- and from there, I'll evolve it into something better through direct manipulation.\n\nImagine a robot capable of physically modifying itself, and programmed to improve itself. Even if it's not great at that, it could improve it's ability to improve itself, or even it's criteria for reasoning about what that means. If you can somehow make that initial robot _at all_, no matter how crappy, then you've succeeded in bootstrapping arbitrarily better robots. That's what I'm trying to do, but with software &amp; programming.\n\nThere's more to it than that, which is my philosophy on \"programming language\" not needing to be a solidly defined thing, or perhaps not even a thing at all! What is a compiler or interpreter, other than just code that operates on code? Why not put THAT code and YOUR code all in the same bucket? Instead of code + compiler, you have code (in whatever form makes sense for the context) + other code that executes or translates that code?\n\nHere is where the line blurs between programming language, and having code that iterates over a hardcoded list to avoid having to repeat a bunch of code that differs only by specific values. That's as much of a \"language\" as the one your code is written in!\n\nNow take that to the extreme, but think of being able to customize your own visual representation and \/ or editor for whatever makes sense for a given context. Imagine if \"code\" could contain instructions that told your IDE how to behave? That's the same as putting your code and the code OF the IDE in the same codebase. Just like I described for removing the separation between compiler + code.\n\nOne (example) vision I have is that \"code\" for something is not a text file that you open in another tool, but a self-contained executable program that, when you run it, presents you with a custom interface \/ model for \"the code\", including the code of the whole running program &amp; interface that it presents. No more dependency on some other interface! It's the same idea (in a sense) as infrastructure as code, or HATEOS\n\nBut what's that? you need a Java program? Fine, click a button, and it spits out a compiled-to-Java equivalent of \"just the product code\". Any code in any language or for any system, has a structure, and there's no reason that cannot be stored and executed as a _live_ structural representation, prior to generating the actual \"compiled\" built product from it.\n\nWhat's that? Execution in the tool is not the same as execution in the JVM (or whatever other target)? Well, the tool is written \"in itself\", and you already made a generate-the-equivalent-Java-code functionality; use that on the tool itself, and bootstrap the tool right into the JVM (or what have you). That's one perk of having just some generic code model with self contained rules for execution or translation.\n\nThere are so so many things and approaches and models for what \"code\" could be and how to model or visualize it, how it can be edited or projected, and what to even DO with the code (e.g. translate it) ... a tool like this would make it very easy to explore that space.\n\nWhat if the representation I choose is not great? What if the tools and process I provide for molding better tools and processes, really sucks? Well, then I mold better things for molding better things.\n\nSoftware is not just made of levers; it's made of levers for making levers. And I want to put that power in everyone's hands. This makes sense not just for programmers, but also for everyone else: What the heck does it even mean to have the power of a computer in your hand, without actually having any power of a computer in your hand? What a joke!\n\nBut what if people suck at computer stuff, though? Well gosh, if only they had the power of a computer to assist with using the power of a computer...",
                "author_name": "Dan Cook",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UAVCC2X70",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_48.jpg",
                "mrkdwn_in": [
                    "text"
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&amp;cid=C5T9GPWFL",
                "footer": "From a thread in #general"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "saWJ0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Eddy, I think the idea of working backwards from the desired result is an awesome idea! Much of the problems that the software industry has are do to working with some complex mechanism (language, tool, pattern, etc.) and then trying to \"emerge\" the human model out of it -- which is completely backwards to what makes sense! That's why the human model becomes an afterthought, and software does things people don't expect, and nobody knows what to even look for to fix the situation: they're working from the wrong end!\n\nAnyway, I talked at length in another thread about my thoughts on this, and how I'm approaching the problem of getting rigid mechanism or of the way by making it possible to freely scult whatever it means to design \/ code \/ model whatever it is that one is trying to do, rather than starting with a broken model and going the other way.\n\nIt's a lot to reformulate on this context, so here's a link to that post \/ thread: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&cid=C5T9GPWFL",
                                "text": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1584764693467400?thread_ts=1584235196.324400&cid=C5T9GPWFL"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35"
    }
]