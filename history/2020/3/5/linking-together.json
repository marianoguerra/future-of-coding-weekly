[
    {
        "client_msg_id": "1c8c1793-ae8e-412f-8942-f30a7b28af60",
        "type": "message",
        "text": "I noticed that when refactoring you start building a stack of tasks that appear as you go along, sometimes you follow each task as it comes (breadth first) and some times you take notes or try to remember the next tasks to tackle later (depth first), is this specific to the way we code or general to coding (and maybe general to other activities), if so, what kind of tools would help keeping track of those task stacks (say it 10 times fast :P), or being a little bit more ambitious, what would those tools look like if they were builtin into our programming environments.\n\nAnother interesting facts is that the activity as a whole is not reflected in my commits, I could create a branch and merge it to signal a complete activity, but each commit and their relations do not reflect the reason of the changes.",
        "user": "UBN9AFS0N",
        "ts": "1583399645.033200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vgh62",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I noticed that when refactoring you start building a stack of tasks that appear as you go along, sometimes you follow each task as it comes (breadth first) and some times you take notes or try to remember the next tasks to tackle later (depth first), is this specific to the way we code or general to coding (and maybe general to other activities), if so, what kind of tools would help keeping track of those task stacks (say it 10 times fast :P), or being a little bit more ambitious, what would those tools look like if they were builtin into our programming environments.\n\nAnother interesting facts is that the activity as a whole is not reflected in my commits, I could create a branch and merge it to signal a complete activity, but each commit and their relations do not reflect the reason of the changes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "reply_count": 12,
        "reply_users_count": 8,
        "latest_reply": "1583918719.069900",
        "reply_users": [
            "UBN9AFS0N",
            "UA14TGLTC",
            "UNBPP291C",
            "U5STGTB3J",
            "UUB7RA7PF",
            "UFEQUBNNT",
            "UHWC9PXBL",
            "U8A5MS6R1"
        ],
        "replies": [
            {
                "user": "UBN9AFS0N",
                "ts": "1583400113.033400"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1583400345.033600"
            },
            {
                "user": "UNBPP291C",
                "ts": "1583405794.038800"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1583408632.062800"
            },
            {
                "user": "UUB7RA7PF",
                "ts": "1583420864.063200"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1583455364.064700"
            },
            {
                "user": "UFEQUBNNT",
                "ts": "1583463670.064900"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1583483353.065400"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1583535351.066200"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1583535356.066400"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1583905587.069300"
            },
            {
                "user": "UBN9AFS0N",
                "ts": "1583918719.069900"
            }
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1583918719.069900"
    },
    {
        "client_msg_id": "418eb938-d6ad-46b2-bc38-3903e3a7cb9f",
        "type": "message",
        "text": "I just lost track of where my return address was and I forgot why I was doing what I was doing and where should I continue :smile:",
        "user": "UBN9AFS0N",
        "ts": "1583400113.033400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Gyt8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just lost track of where my return address was and I forgot why I was doing what I was doing and where should I continue "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "374cf878-a880-4802-88f3-e2aa4537c94e",
        "type": "message",
        "text": "I use comments starting with `#!!`.  For bigger refactors, I do end up with a bunch of commits that I merge into the main branch at the end.  (I'm into true history rather than the rewriting that git allows.)",
        "user": "UA14TGLTC",
        "ts": "1583400345.033600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qPSr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I use comments starting with "
                            },
                            {
                                "type": "text",
                                "text": "#!!",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  For bigger refactors, I do end up with a bunch of commits that I merge into the main branch at the end.  (I'm into true history rather than the rewriting that git allows.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "ad542693-d78c-456a-93b4-b8b02e1fb6cd",
        "type": "message",
        "text": "I like some parts that intellij has - like back navigation that really goes to the previous line, auto refactor which shows you where stuff is getting refactored too and similar.\nI’d love to have a dependency graph - I click show usage graph and it shows a graph of classes using it.",
        "user": "UNBPP291C",
        "ts": "1583405794.038800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gcf29e340a09",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Ian Rumac",
            "display_name": "Ian Rumac",
            "team": "T5TCAFTA9",
            "name": "ian.rumac",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2YPLO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like some parts that intellij has - like back navigation that really goes to the previous line, auto refactor which shows you where stuff is getting refactored too and similar.\nI’d love to have a dependency graph - I click show usage graph and it shows a graph of classes using it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "8E1D71AF-747A-42B8-99E5-748E0AD8C901",
        "type": "message",
        "text": "Is “three states for Boolean” about modeling what many languages do with exceptions? That's the only interpretation I can think of to make sense of this. And then aren’t you really debating if a language should use a pure functional approach (where all possible states are explicitly modeled in a data structure eg. with Maybe\/Optional or Result types) or an exception based approach (which seems to be argued against here?).\n\nTaking the pure functional approach leads to the discovery that this model isn’t perfect either — which I believe is what Haskell's mentioned “unsoundness” is about? Seems like a rather theoretical concern. There's this “hack” to talk about the category Hask, which sneakily adds the value Bottom to all type classes, which is probably equivalent to that mysterious third Boolean state discussed above…? \n\nIf I’m not mistaken there is also a compiler switch in Haskell to enforce exhaustive pattern matching, as well as best practices to avoid partial functions, which means in essence Bottom becomes Haskell's way of saying “This function could never halt, take too long for you to wait on, or run out of computing resources (stack overflow etc.)”. It's there, but in a way that you don’t have to be concerned about it all the time, which is what it sounds like you’re doing when you talk about “Booleans really have three states”.",
        "user": "U5STGTB3J",
        "ts": "1583408236.059900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I9SH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is “three states for Boolean” about modeling what many languages do with exceptions? That's the only interpretation I can think of to make sense of this. And then aren’t you really debating if a language should use a pure functional approach (where all possible states are explicitly modeled in a data structure eg. with Maybe\/Optional or Result types) or an exception based approach (which seems to be argued against here?).\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Taking the pure functional approach leads to the discovery that this model isn’t perfect either — which I believe is what Haskell's mentioned “unsoundness” is about? Seems like a rather theoretical concern. There's this “hack” to talk about the category Hask, which sneakily adds the value Bottom to all type classes, which is probably equivalent to that mysterious third Boolean state discussed above…? \n\nIf I’m not mistaken there is also a compiler switch in Haskell to enforce exhaustive pattern matching, as well as best practices to avoid partial functions, which means in essence Bottom becomes Haskell's way of saying “This function could never halt, take too long for you to wait on, or run out of computing resources (stack overflow etc.)”. It's there, but in a way that you don’t have to be concerned about it all the time, which is what it sounds like you’re doing when you talk about “Booleans really have three states”."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "34D46AF6-8BBB-47D2-9025-12F5A9F4AFED",
        "type": "message",
        "text": "This somehow sounds to me like if you solve this problem, you’ll have solved structured editing along the way too. They seem related in a way, and I would consider structured editing the easier one of the two.",
        "user": "U5STGTB3J",
        "ts": "1583408632.062800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WHa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This somehow sounds to me like if you solve this problem, you’ll have solved structured editing along the way too. They seem related in a way, and I would consider structured editing the easier one of the two."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "56b2668f-f260-42f8-b204-df8dc11411be",
        "type": "message",
        "text": "When doing bigger refactoring in dynamic language (Javascript), I normally end up doing a lot of searching around to find all the affected parts, and I write them down in a checklist to be able to track them. I do this in mostly BFS manner. Then, refactoring itself I do in more of a DFS manner, meaning I follow the checklist but I also dig deeper when I realize for certain item that there is more work to get done.\nFinally, if code is well tested, I expect broken tests to further guide me and warn me about all the places that I missed. If it is not well tested, well then it comes to manual testing of course, and hopefully I add some missing tests on the way.\n\nThat said, I just recently switched from JS project to Haskell project, and experience is very much different. I don't have to do so much of investigating and thinking, I just start with one change and let the compiler guide me -&gt; when I am done with fixing all compiler errors, I am mostly done all together + I have a good idea of all the affected parts (I don't need to search through the codebase that much). Then there are tests again to check the logic is functioning ok (not covered by type system), and that is mostly it.\n\nWhat do you mean by activity as a whole reflecting in commits: is that in case where you did the change through multiple commits and want it to be obvious they are all part of that change?\nPersonally, I always create new branch for new \"feature\/activity\", and when I am done, I squash all commits into one commit and rebase that onto master, often with github issues number included in the commit message.\nIf feature\/activity is bigger and it makes sense to keep it split into multiple commits (does not happen often to me), I still just rebase it into master - usually commit messages are descpritive enough to make it obvious what is the relationship between these commits. I guess you could prefix all of the commit (their messages) with same prefix, smth like issue number of feature name, to make that more obvious if really needed?",
        "user": "UUB7RA7PF",
        "ts": "1583420864.063200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2fdcf29b225b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-02-26\/971836171367_2fdcf29b225b02e66825_72.png",
            "first_name": "Martin",
            "real_name": "Martin Sosic",
            "display_name": "Martin",
            "team": "T5TCAFTA9",
            "name": "sosic.martin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UUB7RA7PF",
            "ts": "1583420997.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ueX7c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When doing bigger refactoring in dynamic language (Javascript), I normally end up doing a lot of searching around to find all the affected parts, and I write them down in a checklist to be able to track them. I do this in mostly BFS manner. Then, refactoring itself I do in more of a DFS manner, meaning I follow the checklist but I also dig deeper when I realize for certain item that there is more work to get done.\nFinally, if code is well tested, I expect broken tests to further guide me and warn me about all the places that I missed. If it is not well tested, well then it comes to manual testing of course, and hopefully I add some missing tests on the way.\n\nThat said, I just recently switched from JS project to Haskell project, and experience is very much different. I don't have to do so much of investigating and thinking, I just start with one change and let the compiler guide me -> when I am done with fixing all compiler errors, I am mostly done all together + I have a good idea of all the affected parts (I don't need to search through the codebase that much). Then there are tests again to check the logic is functioning ok (not covered by type system), and that is mostly it.\n\nWhat do you mean by activity as a whole reflecting in commits: is that in case where you did the change through multiple commits and want it to be obvious they are all part of that change?\nPersonally, I always create new branch for new \"feature\/activity\", and when I am done, I squash all commits into one commit and rebase that onto master, often with github issues number included in the commit message.\nIf feature\/activity is bigger and it makes sense to keep it split into multiple commits (does not happen often to me), I still just rebase it into master - usually commit messages are descpritive enough to make it obvious what is the relationship between these commits. I guess you could prefix all of the commit (their messages) with same prefix, smth like issue number of feature name, to make that more obvious if really needed?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "c44d5f82-0860-4c9c-bc4f-25e3aba54773",
        "type": "message",
        "text": "<@U5STGTB3J> yes refactoring is a good perspective on structured editing since the goal is to leave one thing (the behavior) the same while changing another (the representation).\n\nLeads to good questions, fundamental ones, \"if it's going to work the same, what difference does the factoring make?\"  Right now I'm in the middle of a big refactor where a bunch of long lived objects are used in a calculation requiring a lot of temporary data, which was attached to the long lived objects meaning that they end up containing both the long-lived data and the transients together with code to ensure that the transients are reset, remain consistent from one calculation to the next.\n\nSo in this case, the life-cycle of objects motivates the refactoring.  We end up with more classes and a bunch 1-1 relationships, but the important difference is that one of those 1s is short-lived.",
        "user": "UA14TGLTC",
        "ts": "1583455364.064700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZRmc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " yes refactoring is a good perspective on structured editing since the goal is to leave one thing (the behavior) the same while changing another (the representation).\n\nLeads to good questions, fundamental ones, \"if it's going to work the same, what difference does the factoring make?\"  Right now I'm in the middle of a big refactor where a bunch of long lived objects are used in a calculation requiring a lot of temporary data, which was attached to the long lived objects meaning that they end up containing both the long-lived data and the transients together with code to ensure that the transients are reset, remain consistent from one calculation to the next.\n\nSo in this case, the life-cycle of objects motivates the refactoring.  We end up with more classes and a bunch 1-1 relationships, but the important difference is that one of those 1s is short-lived."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "102a4714-2989-4c6e-aa90-9aa81a1458ee",
        "type": "message",
        "text": "<@U5TCAFTD3> talked on the podcast often about source control where you created branches for each of the changes you wanted to make and used the repo history as your task manager. <https:\/\/github.com\/stevekrouse\/futureofcoding.org\/files\/1248895\/Top-down.programming.assistant.pdf|This> is all I see in written form, so I guess most of his thoughts are in his status update episodes.",
        "user": "UFEQUBNNT",
        "ts": "1583463670.064900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "565c54a4fa91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2508698086192_565c54a4fa91a0c8c75a_72.png",
            "first_name": "Tom",
            "real_name": "Tom Lieber",
            "display_name": "alltom",
            "team": "T5TCAFTA9",
            "name": "tom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "puBg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5TCAFTD3"
                            },
                            {
                                "type": "text",
                                "text": " talked on the podcast often about source control where you created branches for each of the changes you wanted to make and used the repo history as your task manager. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/stevekrouse\/futureofcoding.org\/files\/1248895\/Top-down.programming.assistant.pdf",
                                "text": "This"
                            },
                            {
                                "type": "text",
                                "text": " is all I see in written form, so I guess most of his thoughts are in his status update episodes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1583399645.033200",
        "parent_user_id": "UBN9AFS0N"
    }
]