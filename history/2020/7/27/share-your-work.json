[
    {
        "client_msg_id": "ba23d221-a0ed-4dcb-b3f9-93cc0ef23941",
        "type": "message",
        "text": "Here is a bit of context. I have a very small Rust experience. As small as reading half of \"Programming Rust\" from O'Reilly, start coding in Rust, trying to replicate other languages habits, struggle with lot's of compiler error messages, finally actually understand the hard way that habits must change, unperfectly change them, implement some basic toy CRDT algorithm in Rust (which target WebAssembly for use in the browser), forget about all of this (it was one year ago and I didn't use Rust again since).\n\nFor your first question:\n&gt; Does the process of interpreting a type error make sense? Does it ring true to your own experience (in Rust or other languages?)\nYes, completely. And especially with Rust. Even if my memory of Rust is a bit... rusty (sorry for the bad pun...) and even if I didn't catch very well all your code examples (maybe I read it too fast too) reading the discussion totally makes sense and resonates with what I have experienced. To be precise on one point: I didn't write any unsafe code, even if there were several cases where it can be a solution. But as I was learning, and it strongly feels against the Rust idea, and that it seems complicated to write (and need to learn new things like you point in the article), I didn't do it.\n\nAnd for the other question:\n&gt; Did you learn something new? Does this paper help you understand\/frame the usability challenges about Rust specifically, or potentially a different language?\nTotally, it is a kind of global 'aha' moment too for me. All your points are like I felt them during my Rust experience but didn't really grasp or \"put a name\" on it. Especially, it wasn't clear to me that some compiler errors were due to incompletness, and I feel like knowing this would have been of great help in the way to manage the compiler and its messages, and knowing it now will definitely helps me in my future Rust experience (if any).",
        "user": "UJ6LDMMN0",
        "ts": "1595837470.424000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VzJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here is a bit of context. I have a very small Rust experience. As small as reading half of \"Programming Rust\" from O'Reilly, start coding in Rust, trying to replicate other languages habits, struggle with lot's of compiler error messages, finally actually understand the hard way that habits must change, unperfectly change them, implement some basic toy CRDT algorithm in Rust (which target WebAssembly for use in the browser), forget about all of this (it was one year ago and I didn't use Rust again since).\n\nFor your first question:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does the process of interpreting a type error make sense? Does it ring true to your own experience (in Rust or other languages?)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, completely. And especially with Rust. Even if my memory of Rust is a bit... rusty (sorry for the bad pun...) and even if I didn't catch very well all your code examples (maybe I read it too fast too) reading the discussion totally makes sense and resonates with what I have experienced. To be precise on one point: I didn't write any unsafe code, even if there were several cases where it can be a solution. But as I was learning, and it strongly feels against the Rust idea, and that it seems complicated to write (and need to learn new things like you point in the article), I didn't do it.\n\nAnd for the other question:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Did you learn something new? Does this paper help you understand\/frame the usability challenges about Rust specifically, or potentially a different language?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally, it is a kind of global 'aha' moment too for me. All your points are like I felt them during my Rust experience but didn't really grasp or \"put a name\" on it. Especially, it wasn't clear to me that some compiler errors were due to incompletness, and I feel like knowing this would have been of great help in the way to manage the compiler and its messages, and knowing it now will definitely helps me in my future Rust experience (if any)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595636687.411800",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "UFB8STN7K"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "36e7c4e2-49ee-4f29-833a-611e93bb050e",
        "type": "message",
        "text": "Currently, we work with OpenGL. Skia already supports Metal, but we just didn’t adopt it yet. We will in the near future.\n\nSo, currently, if you have OpenGL context, you can just draw to texture and we display it as is. For now, if you want to try Metal, it would require an extra step of going from a texture to a pixel buffer. But, when we will be on Metal, that extra step will not be needed anymore.",
        "user": "UE1JQM9HQ",
        "ts": "1595840892.424200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g48924f215ef",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "Tudor",
            "real_name": "Tudor Girba",
            "display_name": "Tudor Girba",
            "team": "T5TCAFTA9",
            "name": "tudor",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wYI3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Currently, we work with OpenGL. Skia already supports Metal, but we just didn’t adopt it yet. We will in the near future.\n\nSo, currently, if you have OpenGL context, you can just draw to texture and we display it as is. For now, if you want to try Metal, it would require an extra step of going from a texture to a pixel buffer. But, when we will be on Metal, that extra step will not be needed anymore."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595571873.400800",
        "parent_user_id": "UE1JQM9HQ"
    }
]