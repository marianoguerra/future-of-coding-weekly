[
    {
        "client_msg_id": "F2274C79-636D-4B1B-A583-3D6325BB73EF",
        "type": "message",
        "text": "&gt; The key to end-user happiness is to make tools that enable an equivalent level of affordance and flexibility compared to what the developer needed while developing it.\n&gt; \n&gt; Most of all, we need the ambition to build complete tools and the humility to grant our users access on an equal footing, instead of hoarding the goods.\n&gt; \nSo much good stuff in there.",
        "user": "U5STGTB3J",
        "ts": "1590918326.283900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1590918375.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uKWm",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The key to end-user happiness is to make tools that enable an equivalent level of affordance and flexibility compared to what the developer needed while developing it."
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most of all, we need the ambition to build complete tools and the humility to grant our users access on an equal footing, instead of hoarding the goods.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSo much good stuff in there."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590774956.270400",
        "parent_user_id": "U71PMQ1V0"
    },
    {
        "client_msg_id": "91E2AF4D-5101-4952-959F-BC139608BDAB",
        "type": "message",
        "text": "Indeed!",
        "user": "UJBAJNFLK",
        "ts": "1590947901.285100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g05e4cf66ef1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/305e4cf66ef1179f7e95981b1520ba1a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1qX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Indeed!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "ff9c3041-28cc-4beb-abe2-a1cad565a26b",
        "type": "message",
        "text": "thanks for all the pointers\nafter reading up some more, and trying out some of the proposals, I'm back to just regular S-expressions, though I must admit the infix rule <@UJBAJNFLK> mentioned is very elegant and is something I will remember. I suppose there's still always room for macros that change the syntax (I like LOOP, please no flames), and going even further, stuff like racket's #lang.\n\nMy main issue with syntactic extensions and changes, is that they usually break tooling support—usually macros don't provide too useful error messages, and static analysis tools don't work on the files anymore. Even basic stuff like syntax highlighting. Does anyone know of work in this area? I know of racket's syntax objects and still need to dive deeper into how they're used, but I'm not aware of much else.",
        "user": "UT60XSVCN",
        "ts": "1590968897.285700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gbc3e6041047",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "S.M Mukarram Nainar",
            "display_name": "S.M Mukarram Nainar",
            "team": "T5TCAFTA9",
            "name": "nainars",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UT60XSVCN",
            "ts": "1590968940.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WqjZm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "thanks for all the pointers\nafter reading up some more, and trying out some of the proposals, I'm back to just regular S-expressions, though I must admit the infix rule "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " mentioned is very elegant and is something I will remember. I suppose there's still always room for macros that change the syntax (I like LOOP, please no flames), and going even further, stuff like racket's #lang.\n\nMy main issue with syntactic extensions and changes, is that they usually break tooling support—usually macros don't provide too useful error messages, and static analysis tools don't work on the files anymore. Even basic stuff like syntax highlighting. Does anyone know of work in this area? I know of racket's syntax objects and still need to dive deeper into how they're used, but I'm not aware of much else."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "aa7387da-60d2-44c2-be78-325b792f81d2",
        "type": "message",
        "text": "Has anyone thought about, implemented, or encountered higher-level abstractions of *ALUs*? a.k.a. the part of hardware where actual computations are performed (as opposed to the miles of hardware dedicated to control flow management). Almost every programming language has an ALU abstraction based upon fixed-width chunks of binary digits (32 or 64-wide), arithmetic operations (interpreting the chunks as integers or IEEE floats), and bitwise and bitshift operations. Those fixed-width chunks are grouped into \"allocations\", which are either larger fixed-width containers (structs etc) or dynamically-sized arrays.\n\nRecently I've been thinking about a \"clean slate\" abstraction that still exposes the basic operations that ALUs are good at (integer arithmetic and bit manipulations) but without the fixed-width chunk limitations. Fixed-width chunks are purely a hardware design limitation and have no inherent value to a programmer's mental model; they just add complexity to data modelling. What DOES have value is the notion of a dynamically-sized bit sequence that can be manipulated via splicing operations (take, drop, insert, replace) that generalize bit shifts, bitwise operations (the same old &amp;,|,^ operations), and the familiar arithmetic operations (add, sub, mul, div...). This is a natural foundation for arbitrary-size integers and sequences, but also for general computations that want an efficient mapping to hardware capabilities. I want to take an ALU abstraction like this and build my way-out-there logic programming environment on top of it, so that you still have a conceptual bridge to hardware, and thus you can still reason about the efficiency of basic operations and use them to create efficient user-defined data types.",
        "user": "UCGAK10LS",
        "ts": "1590977348.305600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "laVrc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Has anyone thought about, implemented, or encountered higher-level abstractions of "
                            },
                            {
                                "type": "text",
                                "text": "ALUs",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? a.k.a. the part of hardware where actual computations are performed (as opposed to the miles of hardware dedicated to control flow management). Almost every programming language has an ALU abstraction based upon fixed-width chunks of binary digits (32 or 64-wide), arithmetic operations (interpreting the chunks as integers or IEEE floats), and bitwise and bitshift operations. Those fixed-width chunks are grouped into \"allocations\", which are either larger fixed-width containers (structs etc) or dynamically-sized arrays.\n\nRecently I've been thinking about a \"clean slate\" abstraction that still exposes the basic operations that ALUs are good at (integer arithmetic and bit manipulations) but without the fixed-width chunk limitations. Fixed-width chunks are purely a hardware design limitation and have no inherent value to a programmer's mental model; they just add complexity to data modelling. What DOES have value is the notion of a dynamically-sized bit sequence that can be manipulated via splicing operations (take, drop, insert, replace) that generalize bit shifts, bitwise operations (the same old &,|,^ operations), and the familiar arithmetic operations (add, sub, mul, div...). This is a natural foundation for arbitrary-size integers and sequences, but also for general computations that want an efficient mapping to hardware capabilities. I want to take an ALU abstraction like this and build my way-out-there logic programming environment on top of it, so that you still have a conceptual bridge to hardware, and thus you can still reason about the efficiency of basic operations and use them to create efficient user-defined data types."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590977348.305600",
        "reply_count": 31,
        "reply_users_count": 6,
        "latest_reply": "1593738544.222000",
        "reply_users": [
            "UCGAK10LS",
            "UEQ6M68H0",
            "U015902ESJC",
            "UJN1TAYEQ",
            "UD6EXQVM0",
            "UHDQ62M4P"
        ],
        "replies": [
            {
                "user": "UCGAK10LS",
                "ts": "1590977463.305700"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1590982910.306200"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1590996067.306900"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591031496.312300"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1591041211.313400"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1591041290.313700"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591081782.340500"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591081860.340900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591082055.341300"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591084605.354900"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591084750.355200"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591084959.355400"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591189348.390000"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591189417.391800"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1591200558.392500"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591233743.410800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591234787.414400"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591240308.420300"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1591821961.148100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591839632.150000"
            },
            {
                "user": "U015902ESJC",
                "ts": "1591894992.166000"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591934749.178900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591934830.179100"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1591940682.179400"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591940889.179600"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1591941261.180200"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591941429.180400"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591941507.180600"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1591941581.180800"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1591980421.203100"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1593738544.222000"
            }
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UMWF81HTP",
                    "UBSMEUXAA"
                ],
                "count": 3
            },
            {
                "name": "+1",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b82b7eed-151a-4eab-b39c-42e7109639e5",
        "type": "message",
        "text": "And yes, arbitrary-sized bit sequences have overhead, because you have to perform length checks before every operation. But I'm not too worried about this constant-factor overhead. I'm not competing with C. Also, many of those checks should be able to be removed with the help of some static analysis. I want to make this a language implementation problem, not a user's problem (and my users aren't compute-bound).",
        "user": "UCGAK10LS",
        "ts": "1590977463.305700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1590977634.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BCZV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And yes, arbitrary-sized bit sequences have overhead, because you have to perform length checks before every operation. But I'm not too worried about this constant-factor overhead. I'm not competing with C. Also, many of those checks should be able to be removed with the help of some static analysis. I want to make this a language implementation problem, not a user's problem (and my users aren't compute-bound)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590977348.305600",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "89e44578-6863-491d-a4dc-78526af5785a",
        "type": "message",
        "text": "In Beads i have a variable length bit string type (bits), and a variable length byte type (bytes), which are very useful for packing binary things, or for doing byte manipulation, both common low-level operations. Some CPU's such as the Motorola 68000 had variable length bit and byte strings. Intel has kinda sorta byte manipulation with the REP MOVSB instruction, but the Motorola had extremely handy arbitrary bit string stuff.\n\nAs for arithmetic, IEEE floating point is downright stupid, causes all sorts of problems. Some propose using DEC64 a superior methodology, but some languages support BCD with specified decimal digits which can be helpful in financial applications.\n\nNo question that thinking about 32 vs 64 is mostly a waste of time unless you have an ungodly amount of data to process, which is why AS3, JS, and many other languages have a single numeric type based on 64 bit floating point.",
        "user": "UEQ6M68H0",
        "ts": "1590982910.306200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kzLp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Beads i have a variable length bit string type (bits), and a variable length byte type (bytes), which are very useful for packing binary things, or for doing byte manipulation, both common low-level operations. Some CPU's such as the Motorola 68000 had variable length bit and byte strings. Intel has kinda sorta byte manipulation with the REP MOVSB instruction, but the Motorola had extremely handy arbitrary bit string stuff.\n\nAs for arithmetic, IEEE floating point is downright stupid, causes all sorts of problems. Some propose using DEC64 a superior methodology, but some languages support BCD with specified decimal digits which can be helpful in financial applications.\n\nNo question that thinking about 32 vs 64 is mostly a waste of time unless you have an ungodly amount of data to process, which is why AS3, JS, and many other languages have a single numeric type based on 64 bit floating point."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590977348.305600",
        "parent_user_id": "UCGAK10LS"
    }
]