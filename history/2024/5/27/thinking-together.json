[
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1716832997.950009",
        "client_msg_id": "95ad189f-9fda-460f-a3c5-265bc6fecb90",
        "text": "In something like prolog, terms can be nested. So I can express the idea \"Socrates believes that he is mortal\" with `bel ieves(socrates, mortal(socrates)).` Are there any popular database types that make it easy to have relations of arbitrary arity as parameters of other relations, without unduly adding to the complexity of the schema? Preferably with ungrounded statements and open-world negation? Is there some obvious reason why not? Is there a computational complexity problem that arises in the real world? RDF allows triples to be referenced, I believe, but you are limited to arity 2, which seems needlessly limiting. Labeled graphs have arbitrary arity for non-entities, but entities are limited to two, and you usually can't refer to an edge. It seems... weird to me. Is it just that we don't really have the efficient reasoners over those kinds of expressions, so it hasn't been useful?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "reply_count": 36,
        "reply_users_count": 6,
        "latest_reply": "1717182741.068059",
        "reply_users": [
            "U018S42NMMM",
            "U02U0AS3J49",
            "UDQBTJ211",
            "U01AD80KMLK",
            "U05PY5AQCA2",
            "UFEQUBNNT"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fxmMh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In something like prolog, terms can be nested. So I can express the idea \"Socrates believes that he is mortal\" with "
                            },
                            {
                                "type": "text",
                                "text": "bel ieves(socrates, mortal(socrates)).",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Are there any popular database types that make it easy to have relations of arbitrary arity as parameters of other relations, without unduly adding to the complexity of the schema? Preferably with ungrounded statements and open-world negation? Is there some obvious reason why not? Is there a computational complexity problem that arises in the real world? RDF allows triples to be referenced, I believe, but you are limited to arity 2, which seems needlessly limiting. Labeled graphs have arbitrary arity for non-entities, but entities are limited to two, and you usually can't refer to an edge. It seems... weird to me. Is it just that we don't really have the efficient reasoners over those kinds of expressions, so it hasn't been useful?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1716896943.450559",
        "client_msg_id": "87b383a1-1e40-44d0-b1a8-b0106104294d",
        "text": "Sounds like a \"nested hypergraph\" (which I have never used before): <https://arxiv.org/abs/2405.12235>",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "attachments": [
            {
                "from_url": "https://arxiv.org/abs/2405.12235",
                "service_icon": "https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png",
                "thumb_url": "https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png",
                "thumb_width": 1200,
                "thumb_height": 700,
                "id": 1,
                "original_url": "https://arxiv.org/abs/2405.12235",
                "fallback": "arXiv.org: Hypergraph: A Unified and Uniform Definition with Application to Chemical Hypergraph",
                "text": "The conventional definition of hypergraph has two major issues: (1) there is not a standard definition of directed hypergraph and (2) there is not a formal definition of nested hypergraph. To resolve these issues, we propose a new definition of hypergraph that unifies the concepts of undirected, directed and nested hypergraphs, and that is uniform in using hyperedge as a single construct for representing high-order correlations among things, i.e., nodes and hyperedges. Specifically, we define a hyperedge to be a simple hyperedge, a nesting hyperedge, or a directed hyperedge. With this new definition, a hypergraph is nested if it has nesting hyperedge(s), and is directed if it has directed hyperedge(s). Otherwise, a hypergraph is a simple hypergraph. The uniformity and power of this new definition, with visualization, should facilitate the use of hypergraph for representing (hierarchical) high-order correlations in general and chemical systems in particular. Graph has been widely used as a mathematical structure for machine learning on molecular structures and 3D molecular geometries. However, graph has a major limitation: it can represent only pairwise correlations between nodes. Hypergraph extends graph with high-order correlations among nodes. This extension is significant or essential for machine learning on chemical systems. For molecules, this is significant as it allows the direct, explicit representation of multicenter bonds and molecular substructures. For chemical reactions, this is essential since most chemical reactions involve multiple participants. We propose the use of chemical hypergraph, a multilevel hypergraph with simple, nesting and directed hyperedges, as a single mathematical structure for representing chemical systems. We apply the new definition of hypergraph to chemical hypergraph and, as simplified versions, molecular hypergraph and chemical reaction hypergraph.",
                "title": "Hypergraph: A Unified and Uniform Definition with Application to Chemical Hypergraph",
                "title_link": "https://arxiv.org/abs/2405.12235",
                "service_name": "arXiv.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6lHOv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds like a \"nested hypergraph\" (which I have never used before): "
                            },
                            {
                                "type": "link",
                                "url": "https://arxiv.org/abs/2405.12235"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "",
        "files": [
            {
                "id": "F075DJBUC7M",
                "created": 1716896967,
                "timestamp": 1716896967,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U018S42NMMM",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 217337,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F075DJBUC7M/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F075DJBUC7M/download/image.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 207,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 276,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 414,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 460,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 551,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F075DJBUC7M-2210788f9d/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 588,
                "original_w": 1828,
                "original_h": 1050,
                "thumb_tiny": "AwAbADDSJpN1BHNHfnNAC7qTd7Uceho496AF3UA80nHoaUYz0NACNjPakz9KfRQA0c9APyowfT9KdRQA3kdv0pRmlooA/9k=",
                "permalink": "https://futureofcoding.slack.com/files/U018S42NMMM/F075DJBUC7M/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F075DJBUC7M-4b9bdcc384",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "U018S42NMMM",
        "display_as_bot": false,
        "type": "message",
        "ts": "1716896972.954899",
        "client_msg_id": "cefd06d7-5d20-45b5-97c4-a8b7c0d9df40",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1716897087.228829",
        "edited": {
            "user": "U018S42NMMM",
            "ts": "1716897268.000000"
        },
        "client_msg_id": "7a5dc311-9fe9-4e1c-aac0-3a246220ebd3",
        "text": "Might want to check out <https://hypergraphdb.org/>\n\n>  The unit of storage is a tuple made up of 0 or more other tuples.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sRuYl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Might want to check out "
                            },
                            {
                                "type": "link",
                                "url": "https://hypergraphdb.org/"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " The unit of storage is a tuple made up of 0 or more other tuples."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1716897732.767749",
        "client_msg_id": "f06c9134-e366-404b-93dc-bb3f94ed7105",
        "text": "This too seems similar: <https://wiki.opencog.org/w/AtomSpace>\n\nIt hints at one of the complexities involved. Some atoms become executable. For example: Queries themselves are graphs. Atomese language is Turing-complete.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BBpJN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This too seems similar: "
                            },
                            {
                                "type": "link",
                                "url": "https://wiki.opencog.org/w/AtomSpace"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt hints at one of the complexities involved. Some atoms become executable. For example: Queries themselves are graphs. Atomese language is Turing-complete."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1716905209.016589",
        "client_msg_id": "b2375efb-5c05-4777-85ab-1c02d401631f",
        "text": "I've looked at nested hypergraphs before, but atomspace is interesting, thanks!",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Lf1/s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've looked at nested hypergraphs before, but atomspace is interesting, thanks!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1716930024.120729",
        "client_msg_id": "338c35c6-7568-456d-a0e9-16ea9ff4fd76",
        "text": "Can't you do this just with a unique ID/foreign key...? BELIEVES is a relation that takes a tuple as the 2nd parameter.\n\n(SOCRATES, IS, MORTAL), 123\n(SOCRATES, BELIEVES, 123), 124",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8p7sv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can't you do this just with a unique ID/foreign key...? BELIEVES is a relation that takes a tuple as the 2nd parameter.\n\n(SOCRATES, IS, MORTAL), 123\n(SOCRATES, BELIEVES, 123), 124"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717006192.015149",
        "client_msg_id": "49ecfff2-9749-4d2a-b1c1-08764822b70f",
        "text": "RDF* seems to do it that way, putting names on subgraphs and referencing those.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vUbVV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "RDF* seems to do it that way, putting names on subgraphs and referencing those."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717006338.559039",
        "client_msg_id": "137aca13-6fe0-4bc8-ba1c-728861ad0bce",
        "text": "<@U059ULNS2MQ>, I'm not sure how that representation would distinguish between asserting the fact itself, and merely asserting that the fact is believed. Statement 124 should be possible to express even if statement 124 is not known to be true.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VAH+r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U059ULNS2MQ"
                            },
                            {
                                "type": "text",
                                "text": ", I'm not sure how that representation would distinguish between asserting the fact itself, and merely asserting that the fact is believed. Statement 124 should be possible to express even if statement 124 is not known to be true."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1717006476.747499",
        "client_msg_id": "14d820eb-ef2c-4266-b84c-a6086761d8a9",
        "text": "Yeah you would have to separately distinguish which statements are TRUE. This would just be a particular relation though? It's no different from which statements are FUNNY or INTERESTING",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CMEKT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah you would have to separately distinguish which statements are TRUE. This would just be a particular relation though? It's no different from which statements are FUNNY or INTERESTING"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1717006594.100559",
        "client_msg_id": "548ce61f-a58d-4412-ad2b-202715d9dcf9",
        "text": "(124, HAS PROPERTY, TRUE/FUNNY etc), 461",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "b3BBf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(124, HAS PROPERTY, TRUE/FUNNY etc), 461"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717006921.494119",
        "client_msg_id": "b9003254-6394-49bf-8615-6568b00ab055",
        "text": "It is slightly different, because how do you know that 461 is true?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CS1TU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is slightly different, because how do you know that 461 is true?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1717007065.386399",
        "client_msg_id": "d6fcc870-cfaa-441c-a6cf-dd25de26fb63",
        "text": "Yeah you're right in that if you want to do some kind of meta level inference there's a special kind of \"true\" which is *USER* thinks X is true",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TUT5/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah you're right in that if you want to do some kind of meta level inference there's a special kind of \"true\" which is "
                            },
                            {
                                "type": "text",
                                "text": "USER",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " thinks X is true"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1717007092.670899",
        "client_msg_id": "07d78d2f-03ef-4d1c-9657-2b6eb6fbd419",
        "text": "The system/UI would special case this",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FZ8X5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The system/UI would special case this"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1717007154.877429",
        "client_msg_id": "cb5927ff-0158-4af6-8603-b32fa91316a7",
        "text": "But you presumably want to preserve the ability to say that Socrates believes 1 = 2 is true etc though",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+AKhQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But you presumably want to preserve the ability to say that Socrates believes 1 = 2 is true etc though"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717007365.700159",
        "client_msg_id": "da925624-891b-4af2-80fd-f5df970147d2",
        "text": "yes, but I am not sure it has to look the same as \"these are the things the system should believe to be true\"",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9lmE1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes, but I am not sure it has to look the same as \"these are the things the system should believe to be true\""
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717007376.687959",
        "client_msg_id": "2636a638-c218-40ea-a5d5-1e8b0c67ac81",
        "text": "special casing the latter is probably OK",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9xchO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "special casing the latter is probably OK"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717007595.628059",
        "client_msg_id": "e85af49d-9ff3-4a0d-b06d-b06adca0ebd2",
        "text": "If I have to look to see if the statement exists, and then also check if it is listed as true, that's a lot of needless cognitive overhead for the human user. And as the nesting gets deeper, reading statements is going to get harder and harder.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7TJJu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If I have to look to see if the statement exists, and then also check if it is listed as true, that's a lot of needless cognitive overhead for the human user. And as the nesting gets deeper, reading statements is going to get harder and harder."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717108290.114059",
        "client_msg_id": "f93e816c-fbea-4e5d-9529-be43cf3c58fb",
        "text": "The reason the relational model forbids this \u2014 the reason it is restricted to first order logic \u2014 is that this runs into the halting problem.\n\nRoughly, once relations can refer to other relations, they can form arbitrarily complex structures where queries never finish. The relational model is, almost mathematically so, the richest model you can have where queries always finish.\n\nNote that in the above suggestions where you refer to other relations by a code, you have to go into your external, Turing-complete language to use this.\n\nNot a reason a database should not have this feature, of course, but this might be a useful nuance to be aware of.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Cepu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason the relational model forbids this \u2014 the reason it is restricted to first order logic \u2014 is that this runs into the halting problem.\n\nRoughly, once relations can refer to other relations, they can form arbitrarily complex structures where queries never finish. The relational model is, almost mathematically so, the richest model you can have where queries always finish.\n\nNote that in the above suggestions where you refer to other relations by a code, you have to go into your external, Turing-complete language to use this.\n\nNot a reason a database should not have this feature, of course, but this might be a useful nuance to be aware of."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717111273.665189",
        "client_msg_id": "8be235dd-9872-4c08-af59-1acff9fc410f",
        "text": "That helps explain it, thanks.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "foO19",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That helps explain it, thanks."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717116852.043579",
        "client_msg_id": "1b0e057b-5a9f-4967-a84b-9785a9ab57fa",
        "text": "Every programming language runs into the halting problem, and yet, we don't care. Why do we care for a knowledge language?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LmMnC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Every programming language runs into the halting problem, and yet, we don't care. Why do we care for a knowledge language?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717117230.601369",
        "client_msg_id": "52068BF3-4651-4BD3-9AA5-CDA492836FBE",
        "text": "SQL has poisoned the entire industry. So you\u2019re used to thinking of a relational database as this heavyweight, fixed sort of thing with a terrible query language.\n\nThe correct way to understand the relational model is that it lets you separate your first order logic (FOL) computation from the stuff that should be (either logically or pragmatically) done in a Turing complete language.\n\nThe vast majority of the logic in just about any program can be written in FOL. Folks don\u2019t even think about doing that because SQL is terrible.\n\nOne of the great features of the relational model is that precisely because of its limits, optimisation is a relatively simple problem. We should be able to use relations freely across all of our programming tasks. The result would be that you can just declaratively specify what comes from what, and the query optimiser will make it work efficiently.\n\nThese considerations still apply to SQL databases. If you execute a query, it will eventually finish and when it does, you\u2019re guaranteed that if some data satisfies your query, it will be retrieved.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j0FMM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "SQL has poisoned the entire industry. So you\u2019re used to thinking of a relational database as this heavyweight, fixed sort of thing with a terrible query language.\n\nThe correct way to understand the relational model is that it lets you separate your first order logic (FOL) computation from the stuff that should be (either logically or pragmatically) done in a Turing complete language.\n\nThe vast majority of the logic in just about any program can be written in FOL. Folks don\u2019t even think about doing that because SQL is terrible.\n\nOne of the great features of the relational model is that precisely because of its limits, optimisation is a relatively simple problem. We should be able to use relations freely across all of our programming tasks. The result would be that you can just declaratively specify what comes from what, and the query optimiser will make it work efficiently.\n\nThese considerations still apply to SQL databases. If you execute a query, it will eventually finish and when it does, you\u2019re guaranteed that if some data satisfies your query, it will be retrieved."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717117346.144229",
        "client_msg_id": "757F84F6-DCAB-4ED4-A515-A6ACF1E9514D",
        "text": "If we use a database that is Turing complete, you can write something that is logically correct, but the query engine might not be able to determine that. It is a great virtue that if something is true of your data, if you can express it in FOL, your database can find it.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RrWPf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If we use a database that is Turing complete, you can write something that is logically correct, but the query engine might not be able to determine that. It is a great virtue that if something is true of your data, if you can express it in FOL, your database can find it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717124646.864589",
        "client_msg_id": "02e576a1-0169-4a2d-b189-cc4694c644f3",
        "text": "I have difficulty gauging how practical a virtue the guarantee of termination really is. I can end up with non-terminating code elsewhere, and I just fix it. Is the benefit perhaps that someone cannot add data that makes a query stop terminating that used to terminate? Because not a lot of people are letting users run arbitrary untested queries against their data. So it feels like you would know in advance it will terminate unless the data can stop that from happening, maybe?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0k73i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have difficulty gauging how practical a virtue the guarantee of termination really is. I can end up with non-terminating code elsewhere, and I just fix it. Is the benefit perhaps that someone cannot add data that makes a query stop terminating that used to terminate? Because not a lot of people are letting users run arbitrary untested queries against their data. So it feels like you would know in advance it will terminate unless the data can stop that from happening, maybe?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U01AD80KMLK",
                    "UFEQUBNNT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717125096.775079",
        "client_msg_id": "CE6701D9-1564-4E9B-99DD-28FE638C4270",
        "text": "The relational model is, basically, \u201cessence of declarative programming\u201d. 2nd order logic, subject to halting problems, currently mostly needs to be written by humans. But the rest of it can be declarative \u2014 most of most programs, in fact. The part you can express in FOL benefits from this essence of declarative stuff insofar as you can just declare the rules of what facts follow from what other facts, and then the computer writes an efficient algorithm to implement the logic for you.\n\nThe relational model provides a theory for generating code from declarations about what is true and what follows from what.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KHRb0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The relational model is, basically, \u201cessence of declarative programming\u201d. 2nd order logic, subject to halting problems, currently mostly needs to be written by humans. But the rest of it can be declarative \u2014 most of most programs, in fact. The part you can express in FOL benefits from this essence of declarative stuff insofar as you can just declare the rules of what facts follow from what other facts, and then the computer writes an efficient algorithm to implement the logic for you.\n\nThe relational model provides a theory for generating code from declarations about what is true and what follows from what."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717125948.693559",
        "client_msg_id": "911216cf-2058-4962-b424-3ea26d1f4167",
        "text": "Don't get me wrong. I'm sold on declarative  logic code. Love it, terminating issues and all. Big fan. I just am not sold on the FOL limitation, and I'm having difficulty believing that anyone without a comp sci degree really cares about guaranteed termination that much, unless it is guaranteed against changes in the data.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uAi3f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Don't get me wrong. I'm sold on declarative  logic code. Love it, terminating issues and all. Big fan. I just am not sold on the FOL limitation, and I'm having difficulty believing that anyone without a comp sci degree really cares about guaranteed termination that much, unless it is guaranteed against changes in the data."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717126060.338729",
        "client_msg_id": "EA67D097-C8F5-41BA-BE7E-1FB0659625AF",
        "text": "But that right there is one reason for the design. If you have a language in which someone *can\u2019t express* a non-terminating query, they don\u2019t have to understand any of that, but they know they have a completely reliable system that always answers their questions.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1PzCv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But that right there is one reason for the design. If you have a language in which someone "
                            },
                            {
                                "type": "text",
                                "text": "can\u2019t express",
                                "style": {
                                    "bold": true,
                                    "italic": false,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " a non-terminating query, they don\u2019t have to understand any of that, but they know they have a completely reliable system that always answers their questions."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717127206.613369",
        "client_msg_id": "e48a6607-4fc3-4637-bc8f-8cb81941e244",
        "text": "Regardless of the data, or just regardless of the query?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uUEW/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Regardless of the data, or just regardless of the query?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128658.159119",
        "client_msg_id": "39553A76-CEEC-4B19-A047-84DAE83D01A3",
        "text": "I\u2019m curious too. If every query has a 60-second deadline, valid FOL and SOL queries will both sometimes fail. How much does it matter why? Are the performance problems harder to diagnose and fix with the more complicated languages? Are they more common?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FdUcu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m curious too. If every query has a 60-second deadline, valid FOL and SOL queries will both sometimes fail. How much does it matter why? Are the performance problems harder to diagnose and fix with the more complicated languages? Are they more common?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128727.979669",
        "client_msg_id": "E3A7EBF8-8E1D-4AA0-8012-B53FE46DDA30",
        "text": "I was playing with the idea of a query language the other day and realized that I was limiting myself to FOL. So I questioned the choice.\n\nI came to realize that apps will need additional flexibility in how they process data before it can be presented, and limiting the query language wasn\u2019t going to make that requirement go away. All I was doing was forcing algorithms to be split across database and client, instead of allowing the entire algorithm to be done in one language. Worse, if the seam is in the middle of an algorithm, I might be forcing multiple network calls, with all the de/serialization that entails, to satisfy one semantic query. For what? So that I can say that every operation my database supports is fast? Wouldn\u2019t I rather say that my database is easy to use?",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wX+gG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was playing with the idea of a query language the other day and realized that I was limiting myself to FOL. "
                            },
                            {
                                "type": "text",
                                "text": "So "
                            },
                            {
                                "type": "text",
                                "text": "I questioned the choice."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "I came to realize that apps will need "
                            },
                            {
                                "type": "text",
                                "text": "additional"
                            },
                            {
                                "type": "text",
                                "text": " flexibility in how they process data before it can be presented, and limiting the query language wasn\u2019t going to make that requirement go away. All I was doing was forcing algorithms to be split across database and client, instead of allowing the entire algorithm to be done in one language. Worse, if the seam is in the middle of an algorithm, I might be forcing multiple network calls"
                            },
                            {
                                "type": "text",
                                "text": ", with all the de/serialization that entails,"
                            },
                            {
                                "type": "text",
                                "text": " to satisfy one semantic query. For what? So that I can say that every operation my database supports is fast? Wouldn\u2019t I rather say that my database is easy to use?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128855.513579",
        "client_msg_id": "4BFE35BA-15B8-42A1-A8FF-49250A62E1FF",
        "text": "I decided that I\u2019d rather bring relational operations to a more complex language, and just isolate them enough that they can be plucked out by an optimizer.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HBmAH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I decided that I\u2019d rather bring relational operations to a more complex language, and just isolate them enough that they can be plucked out by an optimizer."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129027.057379",
        "client_msg_id": "1E310FAD-B045-4581-B6E3-AA7425DEB6EC",
        "text": "Aha! You discovered the weakness in my cunning ruse!\n\nNot really. You can certainly write SQL queries that will time out. But in practice, those are rare, and if you had to solve the same problem in a Turing-complete language, there\u2019s a good chance you have no other way to fix it.\n\nComputation complexity is always with us, either way.\n\nAnd in practice, there might be some things that are easier to write in a TC language. But I\u2019d have to struggle with some quite unusual sort of data for a while to produce an example.\n\nSo: a relational database can represent most of most programs more cleanly and simply than any mainstream TC language can, and it does a lot of the programming for you, particularly in terms of working out what order it should process each part of your logic in. And, because it can do that dynamically and automatically, it can retain efficiencies even as you change the model, whereas the typical TC solution might need substantial re-engineering to retain efficiency.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xFOvz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Aha! You discovered the weakness in my cunning ruse!\n\nNot really. You can certainly write SQL queries that will time out. But in practice, those are rare, and if you had to solve the same problem in a Turing-complete language, there\u2019s a good chance you have no other way to fix it.\n\nComputation complexity is always with us, either way.\n\nAnd in practice, there might be some things that are easier to write in a TC language. But I\u2019d have to struggle with some quite unusual sort of data for a while to produce an example.\n\nSo: a relational database can represent most of most programs more cleanly and simply than any mainstream TC language can, and it does a lot of the programming for you, particularly in terms of working out what order it should process each part of your logic in. And, because it can do that dynamically and automatically, it can retain efficiencies even as you change the model, whereas the typical TC solution might need substantial re-engineering to retain efficiency."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129104.148369",
        "client_msg_id": "EA216CE1-EAB6-4B9B-85F5-A1600E664745",
        "text": "There is absolutely nothing wrong with a higher-order/TC query/logic language. Prolog is one such, is very useful for some types of problems, and is I believe easier for non-developers to learn than most TC languages. Mercury is another such, not so beginner friendly but very expressive and flexible.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pg0jX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is absolutely nothing wrong with a higher-order/TC query/logic language. Prolog is one such, is very useful for some types of problems, and is I believe easier for non-developers to learn than most TC languages. Mercury is another such, not so beginner friendly but very expressive and flexible."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129245.444489",
        "client_msg_id": "E1EE9408-AAC0-4C7C-8997-07C50DF58137",
        "text": "Codd\u2019s original conception was that the relational database engine would be used in combination with a TC language. Predicates for filters, for example, are not part of the relational theory but are just supplied from a TC language.\n\nSo your idea for a language that contains both but separates them is not terrible. Although even with SQL, you can see the advantage of separating the relational side. One of the most underappreciated advantage of a separate relational storage engine is that you can use the same data store from multiple programs, written in different languages.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XbmCk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Codd\u2019s original conception was that the relational database engine would be used in combination with a TC language. Predicates for filters, for example, are not part of the relational theory but are just supplied from a TC language.\n\nSo your idea for a language that contains both but separates them is not terrible. Although even with SQL, you can see the advantage of separating the relational side. One of the most underappreciated advantage of a separate relational storage engine is that you can use the same data store from multiple programs, written in different languages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717132374.515389",
        "client_msg_id": "3943CBFB-B006-471E-9C45-C837A3901C48",
        "text": "SQLite is interesting, in that actually leans a fair way into injecting the TC language. The features are not as well known as they should be, and depend on whether the language embedding supports it, but in SQLite, the host application/language can potentially define:\n\u2022 regular functions;\n\u2022 aggregate functions; and;\n\u2022 (what most folks don\u2019t know) custom type deserialisers.\nPostgres has close similar features also.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F0WaF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "SQLite is interesting, in that actually leans a fair way into injecting the TC language. The features are not as well known as they should be, and depend on whether the language embedding supports it, but in SQLite, the host application/language can potentially define:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "regular functions;"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "aggregate functions; and;"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "(what most folks don\u2019t know)"
                                    },
                                    {
                                        "type": "text",
                                        "text": " custom type deserialisers."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPostgres has close similar features also."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717169977.510959",
        "client_msg_id": "ed6732ed-c0e7-47f7-a41a-710fb7fbc39a",
        "text": "The fact that all queries terminate isn't the actual benefit. As a result of that fact, the user can alter the data arbitrarily, and there is no possibility that by doing so they cause queries to become non-terminating. That's the actual upside. The user can't break it. If you are using a higher-order system, you have to either a) be careful not to use potentially infinite structures in your queries (in which case why not just use FPL), or b) guard against the user adding data that causes infinite loops. For my use case, b) was already taken care of in the context of the limited queries I have. Thanks for the enlightening chat!",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dcMSy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The fact that all queries terminate isn't the actual benefit. As a result of that fact, the user can alter the data arbitrarily, and there is no possibility that by doing so they cause queries to become non-terminating. That's the actual upside. The user can't break it. If you are using a higher-order system, you have to either a) be careful not to use potentially infinite structures in your queries (in which case why not just use FPL), or b) guard against the user adding data that causes infinite loops. For my use case, b) was already taken care of in the context of the limited queries I have. Thanks for the enlightening chat!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717182741.068059",
        "client_msg_id": "31118997-B818-49AE-82DC-6FE5BE375F29",
        "text": "You certainly need TC behaviour to be available. But separating what you can into the relational model has enormous benefits in terms of simplicity and flexibility.",
        "team": "T5TCAFTA9",
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DNe4X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You certainly need TC behaviour to be available. But separating what you can into the relational model has enormous benefits in terms of simplicity and flexibility."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]