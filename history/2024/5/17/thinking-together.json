[
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1715945615.115089",
        "client_msg_id": "a2b96e3e-001c-4542-8226-28115375317d",
        "text": "An interesting video: <https://www.youtube.com/watch?v=gWNXGfXOrro|The 100 Games That Taught Me Game Design>\n\nI would like to see \"The 100 Applications That Taught Me Application Design\".\n\nWhich ones are yours?",
        "team": "T5TCAFTA9",
        "thread_ts": "1715945615.115089",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1715951406.500149",
        "reply_users": [
            "UMQ6LR9NZ"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1715951406.500149",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iVUhF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An interesting video: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=gWNXGfXOrro",
                                "text": "The 100 Games That Taught Me Game Design"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI would like to see \"The 100 Applications That Taught Me Application Design\".\n\nWhich ones are yours?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1715951406.500149",
        "client_msg_id": "8c1b0e03-7e53-4e1b-ac5b-38ca2d57762b",
        "text": "I could list a whole bunch, but two that come quickly to mind are\n\n1. <https://www.youtube.com/watch?v=19RJE4TDwI8|Burning Monkey Solitaire> (which yes, I realize is a game, but the way that it incorporated all kinds of noninvasive feedback mechanisms influenced my early thinking about UX design)\n2. the <http://tinytree.info|Bonsai static site generator> opened my eyes to a non-standard but still predictable way of designing command line UX, and showed me that maybe we can make programs that are more like an Emily Dickinson poem, and less like a dictionary. ",
        "team": "T5TCAFTA9",
        "thread_ts": "1715945615.115089",
        "parent_user_id": "UBN9AFS0N",
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=19RJE4TDwI8",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/19RJE4TDwI8/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https://www.youtube.com/embed/19RJE4TDwI8?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=19RJE4TDwI8",
                "fallback": "YouTube Video: Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell",
                "title": "Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell",
                "title_link": "https://www.youtube.com/watch?v=19RJE4TDwI8",
                "author_name": "hirudov2d",
                "author_link": "https://www.youtube.com/@hirudov2d",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            },
            {
                "from_url": "http://tinytree.info/",
                "service_icon": "http://tinytree.info/favicon.ico",
                "id": 2,
                "original_url": "http://tinytree.info",
                "fallback": "Bonsai, Forward",
                "text": "Build sites that run anywhere",
                "title": "Bonsai, Forward",
                "title_link": "http://tinytree.info/",
                "service_name": "tinytree.info"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GIGi2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I could list a whole bunch, but two that come quickly to mind are\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https://www.youtube.com/watch?v=19RJE4TDwI8",
                                        "text": "Burning Monkey Solitaire"
                                    },
                                    {
                                        "type": "text",
                                        "text": " (which yes, I realize is a game, but the way that it incorporated all kinds of noninvasive feedback mechanisms influenced my early thinking about UX design)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "the "
                                    },
                                    {
                                        "type": "link",
                                        "url": "http://tinytree.info",
                                        "text": "Bonsai static site generator"
                                    },
                                    {
                                        "type": "text",
                                        "text": " opened my eyes to a non-standard but still predictable way of designing command line UX, and showed me that maybe we can make programs that are more like an Emily Dickinson poem, and less like a dictionary. "
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ]
    },
    {
        "user": "U03HC3XHZGW",
        "type": "message",
        "ts": "1715978541.417449",
        "edited": {
            "user": "U03HC3XHZGW",
            "ts": "1715978586.000000"
        },
        "client_msg_id": "a35dc9ae-7bf7-41da-82e0-5c9ca68a78e7",
        "text": "Loose set of thoughts:\n1. could you make a type system that somehow captures all information possible about every value in a codebase? Like where the following is true: if typeof(a) === number, then typeof(a + 1 + 2) === number+3 !== typeof(a) \u2026\n2. I might want to \u201cpin\u201d and \u201cunpin\u201d my types - e.g. before refactoring a function, to \u201cpin\u201d its return type. If I had a more powerful type system like described in part one, I wouldn\u2019t want to have to write out the whole type, I would want to just say \u201cpin this such that whatever changes I make could not possibly effect the outcome of the function for any input, or else give me errors describing exactly what part of the input space no longer maps logically the same to the output space\u201d\n3. Another way to think of this might be to say, rather than writing tests, to be able to say \u201cassume infinite test coverage of this codebase (and all tests are passing), now let me refactor things\u201d.\n4. I have no idea how this would work, but it makes me think of getting fractions into \u201csimplest form\u201d. Maybe you could get two functions into \u201csimplest form\u201d to test their similarity?\nI wonder if anything like that exists, or if this is gesturing at some existing area of research?",
        "team": "T5TCAFTA9",
        "thread_ts": "1715978541.417449",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1716009341.326619",
        "reply_users": [
            "UBKNXPBAB",
            "U018S42NMMM",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XmmcS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Loose set of thoughts:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "could you make a type system that somehow captures all information possible about every value in a codebase? Like where the following is true: if typeof(a) === number, then typeof(a + 1 + 2) === number+3 !== typeof(a) \u2026"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I might want to \u201cpin\u201d and \u201cunpin\u201d my types - e.g. before refactoring a function, to \u201cpin\u201d its return type. If I had a more powerful type system like described in part one, I wouldn\u2019t want to have to write out the whole type, I would want to just say \u201cpin this such that whatever changes I make could not possibly effect the outcome of the function for any input, or else give me errors describing exactly what part of the input space no longer maps logically the same to the output space\u201d"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Another way to think of this might be to say, rather than writing tests, to be able to say \u201cassume infinite test coverage of this codebase (and all tests are passing), now let me refactor things\u201d."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I have no idea how this would work, but it makes me think of getting fractions into \u201csimplest form\u201d. Maybe you could get two functions into \u201csimplest form\u201d to test their similarity?"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if anything like that exists, or if this is gesturing at some existing area of research?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBKNXPBAB",
        "type": "message",
        "ts": "1715988854.390149",
        "edited": {
            "user": "UBKNXPBAB",
            "ts": "1715988903.000000"
        },
        "client_msg_id": "c6cd4aef-a8ca-4c57-b2d4-e73fc376aa7b",
        "text": "Some pointers which may (or may not) relate to your interests here\u2026\n\nre #1: Dependently typed languages let you put a ton of information about a value into its type. For instance, in Idris you can have a type `Vect n a` meaning \u201ca vector of n elements of type a\u201d, and then you can write an \u201cappend\u201d function with type `Vect n a -> Vect m a -> Vect (n + m) a`. Using functions like this, you propagate information about the lengths of vectors as you perform computations on them.\n\nre #2: Neat idea. This may be less ambitious than you\u2019re thinking, but I can imagine an IDE feature saying \u201cturn the inferred type of this value into an explicit type annotation\u201d. That way, you can make types explicit before a refactor to make sure you\u2019re not changing types as you refactor.\n\nre all: Your interests here seem related to software verification and other \u201cformal methods\u201d. In case you haven\u2019t seen that stuff, I\u2019d suggest <https://github.com/dafny-lang/dafny|Dafny> as an accessible starting point. It lets you write functions accompanied by logical specifications the functions are supposed to satisfy, and then to guide the system to proving that the functions satisfy these specifications. (Most systems like this cannot be automated in the same way that type inference is automated, because once you want to prove general properties of programs like \u201cfunctions f and g do the same thing\u201d, you get into things that are <https://en.wikipedia.org/wiki/List_of_undecidable_problems|not computable> in principle.)",
        "team": "T5TCAFTA9",
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z4SJT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some pointers which may (or may not) relate to your interests here\u2026\n\nre #1: Dependently typed languages let you put a ton of information about a value into its type. For instance, in Idris you can have a type "
                            },
                            {
                                "type": "text",
                                "text": "Vect n a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " meaning \u201ca vector of n elements of type a\u201d, and then you can write an \u201cappend\u201d function with type "
                            },
                            {
                                "type": "text",
                                "text": "Vect n a -> Vect m a -> Vect (n + m) a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Using functions like this, you propagate information about the lengths of vectors as you perform computations on them.\n\nre #2: Neat idea. This may be less ambitious than you\u2019re thinking, but I can imagine an IDE feature saying \u201cturn the inferred type of this value into an explicit type annotation\u201d. That way, you can make types explicit before a refactor to make sure you\u2019re not changing types as you refactor.\n\nre all: Your interests here seem related to software verification and other \u201cformal methods\u201d. In case you haven\u2019t seen that stuff, I\u2019d suggest "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/dafny-lang/dafny",
                                "text": "Dafny"
                            },
                            {
                                "type": "text",
                                "text": " as an accessible starting point. It lets you write functions accompanied by logical specifications the functions are supposed to satisfy, and then to guide the system to proving that the functions satisfy these specifications. (Most systems like this cannot be automated in the same way that type inference is automated, because once you want to prove general properties of programs like \u201cfunctions f and g do the same thing\u201d, you get into things that are "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/List_of_undecidable_problems",
                                "text": "not computable"
                            },
                            {
                                "type": "text",
                                "text": " in principle.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1715996424.395829",
        "client_msg_id": "72fd86cb-feb2-449d-b049-918cdf9ed58a",
        "text": "Adjacent to this: There's even an extension of dependent typing, called quantitative typing that let's you track how many times (0,1 or more) a value has been consumed. Idris2 uses this: <https://idris2.readthedocs.io/en/latest/tutorial/multiplicities.html>",
        "team": "T5TCAFTA9",
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bl71A",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Adjacent to this: There's even an extension of dependent typing, called quantitative typing that let's you track how many times (0,1 or more) a value has been consumed. Idris2 uses this: "
                            },
                            {
                                "type": "link",
                                "url": "https://idris2.readthedocs.io/en/latest/tutorial/multiplicities.html"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1716009341.326619",
        "client_msg_id": "b5e687b6-84b6-40fc-be46-a39787379aad",
        "text": "&gt; a type system that somehow captures all information possible about every value in a codebase\nFirst thought: \"all possible information\" about a value includes the value itself. And then you quickly get to dependent types, as <@UBKNXPBAB> suggested.\n\nA more difficult problem is exploiting all that information in a useful way, i.e. come up with useful inference rules. I doubt that a single set of rules, i.e. a single type system, can capture all useful inferences while remaining usable. Unfortunately, the dogma of \"thou shalt not have any type system other than the one of your one and only programming language\" is rarely challenged.",
        "team": "T5TCAFTA9",
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NlAuq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "a type system that somehow captures all information possible about every value in a codebase"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFirst thought: \"all possible information\" about a value includes the value itself. And then you quickly get to dependent types, as "
                            },
                            {
                                "type": "user",
                                "user_id": "UBKNXPBAB"
                            },
                            {
                                "type": "text",
                                "text": " suggested.\n\nA more difficult problem is exploiting all that information in a useful way, i.e. come up with useful inference rules. I doubt that a single set of rules, i.e. a single type system, can capture all useful inferences while remaining usable. Unfortunately, the dogma of \"thou shalt not have any type system other than the one of your one and only programming language\" is rarely challenged."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up_2",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            }
        ]
    }
]