[
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1717623510.659559",
        "client_msg_id": "617ce356-ba92-441f-b78d-f92ac68aa2a5",
        "text": "Two related questions:\n\n\u2022 Is there any good research about using <https://en.wikipedia.org/wiki/Call_graph|call graphs> to create some metrics about the quality of a software architecture? (Since I've never looked into it \u2014 what's the state-of-the-art in measuring software quality, anyhow? I'm more interested in a quality architecture than bugs-per-line-of-code or something, I guess.)\n\u2022 Any favorite tool for visualizing call graphs for JavaScript or PHP? \nMy intuition would tend to say that messy call graphs indicate a worse architecture, but I haven't visualized many and I'm not sure how well that idea holds up in the \"real world\". Maybe call graphs end up being too messy in real programs.",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "reply_count": 12,
        "reply_users_count": 5,
        "latest_reply": "1717784868.126629",
        "reply_users": [
            "U04E5QAD6DD",
            "UC2A2ARPT",
            "U02E4DAQGSZ",
            "U06SS0DHZD1",
            "U04R217NVNF"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o04SX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Two related questions:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Is there any good research about using "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://en.wikipedia.org/wiki/Call_graph",
                                        "text": "call graphs"
                                    },
                                    {
                                        "type": "text",
                                        "text": " to create some metrics about the quality of a software architecture? (Since I've never looked into it \u2014 what's the state-of-the-art in measuring software quality, anyhow? I'm more interested in a quality architecture than bugs-per-line-of-code or something, I guess.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Any favorite tool for visualizing call graphs for JavaScript or PHP? "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nMy intuition would tend to say that messy call graphs indicate a worse architecture, but I haven't visualized many and I'm not sure how well that idea holds up in the \"real world\". Maybe call graphs end up being too messy in real programs."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1717631172.047549",
        "client_msg_id": "A2834AC2-05E0-4BA3-8BB8-09ABDD2ECC61",
        "text": "I think a call graph could indicate both the connection between functions, but also the \u201csize\u201d of the parameter list in those calls. Like state charts, it seems like this could be a nested sort of thing. I bet someone has already done all this. ",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Ktrg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think a call graph could indicate both the connection between functions, but also the \u201csize\u201d of the parameter list in those calls"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Like state charts, it seems like this could be a nested sort of thing"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " I bet someone has already done all this"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1717651719.955129",
        "client_msg_id": "285DE2C2-5DE5-45F1-BC93-0BB2BB956648",
        "text": "As for measuring software quality (which is deceptively subjective), there's a list of metrics <https://en.wikipedia.org/wiki/Software_metric|here> that might be a good starting point.",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tUdwl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As for measuring software quality (which is deceptively subjective), there's a list of metrics "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Software_metric",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": " that might be a good starting point."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1717685159.417809",
        "client_msg_id": "3dab6de1-15df-49b0-9405-cd004545cdb6",
        "text": "Yeah, I know it's terribly subjective. I perhaps was thinking something along the lines of measuring complexity or coupling?\n\nHmm\u2026I think I want less of a _metric_ and more just a _visualization_. If I'm solving a simple problem, the solution should _look_ simple when visualized.\n\nDoes your repo of visual programming languages also include program visualization, <@UC2A2ARPT>?",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5eCvl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I know it's terribly subjective. I perhaps was thinking something along the lines of measuring complexity or coupling?\n\nHmm\u2026I think I want less of a "
                            },
                            {
                                "type": "text",
                                "text": "metric",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and more just a "
                            },
                            {
                                "type": "text",
                                "text": "visualization",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". If I'm solving a simple problem, the solution should "
                            },
                            {
                                "type": "text",
                                "text": "look",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " simple when visualized.\n\nDoes your repo of visual programming languages also include program visualization, "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1717694755.394469",
        "client_msg_id": "d67dc9d5-4fd5-4c5b-8c05-eddd93f9d8f0",
        "text": "Sounds like <https://en.wikipedia.org/wiki/Cyclomatic_complexity>",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y4OyA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds like "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Cyclomatic_complexity"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1717697046.735649",
        "client_msg_id": "8F9CF013-F810-4C37-ADE5-D61AF13216A2",
        "text": "<@U04E5QAD6DD> No, my repo doesn't really include that, but it is adjacent / related.\n\n<@U02E4DAQGSZ> Yeah, that wiki link I shared was the result of me thinking \"this sounds like cyclomatic complexity \u2014 I wonder if there's a whole category of these\", haha.",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cWzCf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U04E5QAD6DD"
                            },
                            {
                                "type": "text",
                                "text": " No, my repo doesn't really include that, but it is adjacent / related"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": " Yeah, that wiki link I shared was the result of me thinking \"this sounds like cyclomatic complexity \u2014 I wonder if there's a whole category of these\", haha"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1717704457.921599",
        "client_msg_id": "d5ad172e-1bae-481e-afd2-32c84a796fae",
        "text": "Isn't cyclomatic complexity more about control flow (i.e., according to Wikipedia, if the program contained no conditionals, the cyclomatic complexity would be 1)?\n\nI'm thinking more about when you organize a imperative program into functions, and measuring more the relationships and coupling between those functions. (I bet some of those other measures get into that sort of thing\u2026I'll have to do some reading,)",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7N+lf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Isn't cyclomatic complexity more about control flow (i.e., according to Wikipedia, if the program contained no conditionals, the cyclomatic complexity would be 1)?\n\nI'm thinking more about when you organize a imperative program into functions, and measuring more the relationships and coupling between those functions. (I bet some of those other measures get into that sort of thing\u2026I'll have to do some reading,)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1717704538.230949",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1717704599.000000"
        },
        "client_msg_id": "A8F28720-3E5D-45FA-9679-52A247B35B99",
        "text": "Right, that's the subjectivity. What does one care about when assessing quality? By some criteria, if two programs perform the same job but one of them has lower cyclomatic complexity, that's the superior program.",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZPEkl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Right, that's the subjectivity. What does one care about when assessing quality? By some criteria, if two programs perform the same job but one of them has lower cyclomatic complexity, that's the superior program."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1717704836.125049",
        "client_msg_id": "e3dc0975-a451-4b83-b1ee-5d73c0944916",
        "text": "Yeah, totally. I think that's where I wondered about call graphs explicitly \u2014 my 20 seconds of experience yesterday making one hinted to me that, given a particular problem, a \"cleaner\" (again subjective) call graph is the better program (to me).\n\nI think I really don't care about a _metric_ so much as some sort of tool to help me help other developers write better organized code. A call graph might be one \u2014 if there was a good, reliable tool for such a thing \u2014 but maybe there are others? In general, I'm surprised that program visualization\u2014for our existing programming languages\u2014isn't a more common thing? Or am I just not in the right circles?",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vs21m",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, totally. I think that's where I wondered about call graphs explicitly \u2014 my 20 seconds of experience yesterday making one hinted to me that, given a particular problem, a \"cleaner\" (again subjective) call graph is the better program (to me).\n\nI think I really don't care about a "
                            },
                            {
                                "type": "text",
                                "text": "metric",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " so much as some sort of tool to help me help other developers write better organized code. A call graph might be one \u2014 if there was a good, reliable tool for such a thing \u2014 but maybe there are others? In general, I'm surprised that program visualization\u2014for our existing programming languages\u2014isn't a more common thing? Or am I just not in the right circles?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1717704900.525809",
        "client_msg_id": "2C78455A-D853-4553-B08D-26CAE35D1EBC",
        "text": "You're 100% right \u2014 program visualization is not nearly as common as it ought to be.",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pwaHr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You're 100% right \u2014 program visualization is not nearly as common as it ought to be"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1717711748.890019",
        "client_msg_id": "2bc55ffb-bc58-46bf-9b63-4be993113f27",
        "text": "yeah cyclomatic is supposed to measure the underlying computational complexity, not source code organisation. There is another one for code organization... I am not sure now, maybe <https://objectscriptquality.com/docs/metrics/lack-cohesion-methods-lcom4|LCOM4>? But then I remembered <https://en.wikipedia.org/wiki/SOLID|SOLID> and feel like those are quite good principles that should and probably do have metrics (?). I dunno why we do not visualize code more, can't say I have used it since leaving university :man-shrugging: Maybe the value is too indirect for the business people that prioritise (?)",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jfNSK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah cyclomatic is supposed to measure the underlying computational complexity, not source code organisation. There is another one for code organization... I am not sure now, maybe "
                            },
                            {
                                "type": "link",
                                "url": "https://objectscriptquality.com/docs/metrics/lack-cohesion-methods-lcom4",
                                "text": "LCOM4"
                            },
                            {
                                "type": "text",
                                "text": "? But then I remembered "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/SOLID",
                                "text": "SOLID"
                            },
                            {
                                "type": "text",
                                "text": " and feel like those are quite good principles that should and probably do have metrics (?). I dunno why we do not visualize code more, can't say I have used it since leaving university "
                            },
                            {
                                "type": "emoji",
                                "name": "man-shrugging",
                                "unicode": "1f937-200d-2642-fe0f"
                            },
                            {
                                "type": "text",
                                "text": " Maybe the value is too indirect for the business people that prioritise (?)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1717749905.601499",
        "client_msg_id": "80bee57c-4be7-4cf5-b6ef-415cca49f20c",
        "text": "I recall a cool trick to find bad code organization based on git commits. It went roughly like that: (starting assumption) When you do an incremental change in a system, in a well-organized system you would only have to change the source of one function - the function responsible for the thing you want to change. Also many different changes shouldn't all concentrate on the same function because it hurts code reuse. This sounds pretty ambitious and doesn't really hold in any real system BUT it can be used as a proxy to find problematic areas. Take a look at a git log. If there are groups of functions that are usually changed together (in the same commit) - then it means that they share something that could be extracted into a common location. Also any place which is a hotspot of changes (almost every commit touches it) then it probably could be split out. All of this can be formalized as counting bigrams of functions changed in the same commit. I've done some stats like that on a large-ish project at work and the hotspots (functions which were changed in commits) followed something similar to the zipf distribution. It didn't made sense to split everything but it showed some very interesting correlations that nobody had idea about (even the people working on the system).",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bUPNy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I recall a cool trick to find bad code organization based on git commits. It went roughly like that: (starting assumption) When you do an incremental change in a system, in a well-organized system you would only have to change the source of one function - the function responsible for the thing you want to change. Also many different changes shouldn't all concentrate on the same function because it hurts code reuse. This sounds pretty ambitious and doesn't really hold in any real system BUT it can be used as a proxy to find problematic areas. Take a look at a git log. If there are groups of functions that are usually changed together (in the same commit) - then it means that they share something that could be extracted into a common location. Also any place which is a hotspot of changes (almost every commit touches it) then it probably could be split out. All of this can be formalized as counting bigrams of functions changed in the same commit. I've done some stats like that on a large-ish project at work and the hotspots (functions which were changed in commits) followed something similar to the zipf distribution. It didn't made sense to split everything but it showed some very interesting correlations that nobody had idea about (even the people working on the system)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04R217NVNF",
        "type": "message",
        "ts": "1717784868.126629",
        "client_msg_id": "5a2558fc-8372-44ce-bcc2-e7bcdcef5dbe",
        "text": "<@U06SS0DHZD1> There\u2019s a book called Your Code as a Crime Scene that I think covers what you\u2019re talking about (here\u2019s a <https://adamtornhill.com/articles/crimescene/codeascrimescene.htm|blog post by the author> that later was expanded into the book)  There\u2019s an open source tool called codemaat that does a lot of the analytics (and the book covers how to make the visualizations of the data codemaat spits out.)",
        "team": "T5TCAFTA9",
        "thread_ts": "1717623510.659559",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bz6RI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06SS0DHZD1"
                            },
                            {
                                "type": "text",
                                "text": " There\u2019s a book called Your Code as a Crime Scene that I think covers what you\u2019re talking about (here\u2019s a "
                            },
                            {
                                "type": "link",
                                "url": "https://adamtornhill.com/articles/crimescene/codeascrimescene.htm",
                                "text": "blog post by the author"
                            },
                            {
                                "type": "text",
                                "text": " that later was expanded into the book)  There\u2019s an open source tool called codemaat that does a lot of the analytics (and the book covers how to make the visualizations of the data codemaat spits out.)"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]