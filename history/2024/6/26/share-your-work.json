[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719438405.632489",
        "client_msg_id": "560eff1c-72fa-453e-b31d-e580ddc96abd",
        "text": "FTR: Here is the demo video I presented earlier today. I've added links, in the form of a Kinopio page, to the other technologies that I didn't demo.\n\nExploring Techniques and Notations for Augmenting DX\n<https://youtu.be/zXmC3BVIVuQ>",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "reply_count": 11,
        "reply_users_count": 4,
        "latest_reply": "1719775876.539919",
        "reply_users": [
            "U079PRQNZQD",
            "UGWUJUZHT",
            "UJBAJNFLK",
            "U0123H7JRDM"
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "from_url": "https://youtu.be/zXmC3BVIVuQ",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/zXmC3BVIVuQ/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/zXmC3BVIVuQ?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"Exploring Technique and Notations for Augmenting DX\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https://youtu.be/zXmC3BVIVuQ",
                "fallback": "YouTube Video: Exploring Technique and Notations for Augmenting DX",
                "title": "Exploring Technique and Notations for Augmenting DX",
                "title_link": "https://youtu.be/zXmC3BVIVuQ",
                "author_name": "Programming Simplicity",
                "author_link": "https://www.youtube.com/@programmingsimplicity2980",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WVC+r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FTR: Here is the demo video I presented earlier today. I've added links, in the form of a Kinopio page, to the other technologies that I didn't demo.\n\nExploring Techniques and Notations for Augmenting DX\n"
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/zXmC3BVIVuQ"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC",
                    "U0123H7JRDM",
                    "UJBAJNFLK",
                    "U06JCQL6ERJ"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "U079PRQNZQD",
        "type": "message",
        "ts": "1719441363.923539",
        "client_msg_id": "EAD56F0B-6720-4612-84AB-32BB187B64A9",
        "text": "This looks really cool, Paul. Are these synchronous dataflow? Meaning nodes execute once when they have received data at all their input ports?",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ral/y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This looks really cool, Paul. Are these synchronous dataflow? Meaning nodes execute once when they have received data at all their input ports?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1::skin-tone-3",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719458976.961409",
        "client_msg_id": "7e4dc715-c3e1-4680-8819-482ee4712e13",
        "text": "Thanks!\n\nThis is opposite to \"synchronous dataflow\". Nodes execute once for every input. A node can implement \"synchronous dataflow\" if it wants to, but, this is not a fundamental requirement. When I used to design hardware, I found that I could do so *much* more reliably (e.g. 0 defects in the field, guarantees, deliver-once instead of continuous delivery, utterly asynchronous, etc.) than when I switched to designing software. I believe that overkill-synchronous-thinking is a major cause of bugs and I want to find ways to break out of that mindset.",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ccRqv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks!\n\nThis is opposite to \"synchronous dataflow\". Nodes execute once for every input. A node can implement \"synchronous dataflow\" if it wants to, but, this is not a fundamental requirement. When I used to design hardware, I found that I could do so "
                            },
                            {
                                "type": "text",
                                "text": "much",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " more reliably (e.g. 0 defects in the field, guarantees, deliver-once instead of continuous delivery, utterly asynchronous, etc.) than when I switched to designing software. I believe that overkill-synchronous-thinking is a major cause of bugs and I want to find ways to break out of that mindset."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719472909.635179",
        "client_msg_id": "a1781e07-16dc-43d7-a8e2-72842b07dce9",
        "text": "Thanks for posting this video! Question: what's the level of granularity of your diagram notation? Put differently, how is the operation of each node defined? By another diagram, by traditional code, or yet something else?",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WaorO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for posting this video! Question: what's the level of granularity of your diagram notation? Put differently, how is the operation of each node defined? By another diagram, by traditional code, or yet something else?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719483191.966739",
        "client_msg_id": "4733cc74-3c99-48b3-8cba-19b1b2921437",
        "text": "There are 2 kinds of node. Containers are recursively defined - they can contain Containers and Leaves. Leaf nodes contain code and are not recursive.\n\nIn analogy, this is much like Lisp lists. Lists can contain Lists or Atoms. Atoms are the bottom.\n\nContainers run/loop in multiple steps. A Container is \"busy\" if any of its children is \"busy\" (recursively). Leaves run in one gulp.\n\nA Container can inhale a single message from its input queue only when it is not busy.\n\nRouting of messages between children is performed by the Container, not the children. Children cannot know where their inputs come from nor where their outputs are sent to. A Container cannot know what kind of component each child is and may compose a mix of child components of various kinds.\n\nIn analogy, Containers are like \"main loops\" in windowing systems, except that it's turtles all the way down - a \"main loop\" might contain other \"main loops\" and so on.\n\nIn analogy, a Container is like a Unix command-line command. Containers have several stdins and several stdouts. You can't tell from the outside (nor do you care), if the command is a bash script or a lump of C code. But, it is done much more efficiently than using Unix processes (think: closures and OO queue objects).",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ft9hY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are 2 kinds of node. Containers are recursively defined - they can contain Containers and Leaves. Leaf nodes contain code and are not recursive.\n\nIn analogy, this is much like Lisp lists. Lists can contain Lists or Atoms. Atoms are the bottom.\n\nContainers run/loop in multiple steps. A Container is \"busy\" if any of its children is \"busy\" (recursively). Leaves run in one gulp.\n\nA Container can inhale a single message from its input queue only when it is not busy.\n\nRouting of messages between children is performed by the Container, not the children. Children cannot know where their inputs come from nor where their outputs are sent to. A Container cannot know what kind of component each child is and may compose a mix of child components of various kinds.\n\nIn analogy, Containers are like \"main loops\" in windowing systems, except that it's turtles all the way down - a \"main loop\" might contain other \"main loops\" and so on.\n\nIn analogy, a Container is like a Unix command-line command. Containers have several stdins and several stdouts. You can't tell from the outside (nor do you care), if the command is a bash script or a lump of C code. But, it is done much more efficiently than using Unix processes (think: closures and OO queue objects)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719483339.903509",
        "client_msg_id": "06a8ff38-f034-42c9-a23b-ba5f6de42ce1",
        "text": "In this way, you can structure a system in layers that elide details. The details are all still there, but the reader is not forced to understand every niggly detail unless the reader wants to dig deeply.",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ffsgn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In this way, you can structure a system in layers that elide details. The details are all still there, but the reader is not forced to understand every niggly detail unless the reader wants to dig deeply."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719494868.108759",
        "client_msg_id": "d01bd389-f918-4a79-adfe-13a8781b0dec",
        "text": "Thanks <@UGWUJUZHT>, that sounds like a very reasonable design!",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zqKf2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": ", that sounds like a very reasonable design!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "guitar",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1719749744.872729",
        "client_msg_id": "F5844A7C-E109-41A0-9345-5A664A71C234",
        "text": "I was wondering why asynchronous dataflow leads to less bugs the synchronous dataflow? Can you elaborate on this <@UGWUJUZHT> ? :blush: ",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ctuz6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was wondering why asynchronous dataflow leads to less bugs the synchronous dataflow? Can you elaborate on this "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " ? "
                            },
                            {
                                "type": "emoji",
                                "name": "blush",
                                "unicode": "1f60a"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719761155.782009",
        "client_msg_id": "9595928d-3059-4912-a6a1-894769629a8c",
        "text": "#1: Observation - I know how to build hardware and read schematics, and, I know how to write code. The observation which has perplexed me for decades is that when I build hardware, it is much more reliable than when I build software.  Hardware producers would provide guarantees on their products, while software producers hide behind EULAs. (Why?)\n\n#2: Observation - hardware \u201cprogramming language\u201d (schematics) is much more concise than most software programming languages. For example, the game of Pong in 1972 fit on one piece of paper, long before Functional Programming and Type Checking hit the mainstream. The 1972 version of Pong doesn\u2019t even have a CPU in it.\n\n#3: Observation - something in our software workflow is causing bloat. Apps are ridiculously huge today. Software has become ridiculously complicated. For example, I can build a new language much, much faster (10x?, 100x?, \u2026) using t2t (OhmJS + my own nano-DSL \u201cRWR\u201d) than if I use LLVM and friends. I can finish the new language in less time than it takes me to RTFM and to learn LLVM.\n\n#4: Observation: in hardware, every component is - by default - asynchronous. In software, though, every component is - by default - synchronous.\n\nMy guess, my gut feel: simplicity. Asychronousity allows me to use divide-and-conquer and to solve-problems-and-implement components in small pieces, whereas building software is like crafting an intricate Swiss watch with 100\u2019s of tiny gears. If a tooth breaks in any of the synchronous gears, the whole thing doesn\u2019t work. If an async component breaks, I can isolate it and focus on it and fix it. It ain\u2019t inherently more reliable, but, I can fix things easier and better. The simplicity of asynchronous design is like using LEGO blocks - I can imagine and implement much more interesting (aka \u201ccomplicated\u201d) apps using software asynchronous blocks. [aside: today\u2019s \u201ccode libraries\u201d are not LEGO blocks, they must be used in a synchronous manner, it\u2019s synchrony all the way down]. [aside, knowing hardware, I see function-based programming as an inefficient use of CPU power, requiring extra software to support the function-based paradigm (note the use of the term \u201cfunction-based\u201d which is a superset of what we call \u201cfunctional programming\u201d today).",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1zojt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "#1: Observation - I know how to build hardware and read schematics, and, I know how to write code. The observation which has perplexed me for decades is that when I build hardware, it is much more reliable than when I build software.  Hardware producers would provide guarantees on their products, while software producers hide behind EULAs. (Why?)\n\n#2: Observation - hardware \u201cprogramming language\u201d (schematics) is much more concise than most software programming languages. For example, the game of Pong in 1972 fit on one piece of paper, long before Functional Programming and Type Checking hit the mainstream. The 1972 version of Pong doesn\u2019t even have a CPU in it.\n\n#3: Observation - something in our software workflow is causing bloat. Apps are ridiculously huge today. Software has become ridiculously complicated. For example, I can build a new language much, much faster (10x?, 100x?, \u2026) using t2t (OhmJS + my own nano-DSL \u201cRWR\u201d) than if I use LLVM and friends. I can finish the new language in less time than it takes me to RTFM and to learn LLVM.\n\n#4: Observation: in hardware, every component is - by default - asynchronous. In software, though, every component is - by default - synchronous.\n\nMy guess, my gut feel: simplicity. Asychronousity allows me to use divide-and-conquer and to solve-problems-and-implement components in small pieces, whereas building software is like crafting an intricate Swiss watch with 100\u2019s of tiny gears. If a tooth breaks in any of the synchronous gears, the whole thing doesn\u2019t work. If an async component breaks, I can isolate it and focus on it and fix it. It ain\u2019t inherently more reliable, but, I can fix things easier and better. The simplicity of asynchronous design is like using LEGO blocks - I can imagine and implement much more interesting (aka \u201ccomplicated\u201d) apps using software asynchronous blocks. [aside: today\u2019s \u201ccode libraries\u201d are not LEGO blocks, they must be used in a synchronous manner, it\u2019s synchrony all the way down]. [aside, knowing hardware, I see function-based programming as an inefficient use of CPU power, requiring extra software to support the function-based paradigm (note the use of the term \u201cfunction-based\u201d which is a superset of what we call \u201cfunctional programming\u201d today)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U079PRQNZQD",
        "type": "message",
        "ts": "1719774802.282559",
        "client_msg_id": "FB2AA108-5411-4BA6-85DD-44261051D4D6",
        "text": "Great points <@UGWUJUZHT>. Do you have any experience with LabVIEW? It\u2019s a very structured visual programming environment. Just in the last four or five years, they introduced asynchronous data flow wires. They started working on an asynchronous diagram, but that was part of a new, next generation platform that was mothballed.",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1rkOS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great points "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": ". Do you have any experience with LabVIEW? "
                            },
                            {
                                "type": "text",
                                "text": "It\u2019s"
                            },
                            {
                                "type": "text",
                                "text": " a very structured visual programming environment. Just in the last four or five years, they introduced asynchronous data flow wires. They started working on an asynchronous diagram, but that was part of a new, next generation platform that was mothballed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719775035.106879",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1719775153.000000"
        },
        "client_msg_id": "9276ab61-a9bf-40ac-a180-b03b1b2f9e28",
        "text": "I've looked at LabVIEW but haven't used it. Feel free to educate me. <@U079PRQNZQD>",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cKuuN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've looked at LabVIEW but haven't used it. Feel free to educate me. "
                            },
                            {
                                "type": "user",
                                "user_id": "U079PRQNZQD"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719775876.539919",
        "client_msg_id": "94915fe8-b6ec-4360-b74e-d18c1ff86ced",
        "text": "<@UGWUJUZHT> While I agree with all your observations, I am not convinced by the explanation. My own speculative hypothesis for the relevant difference between hardware and software is Turing-completeness leading to chaotic dynamics and thus an infinity of failure modes (see <https://hal.science/hal-02071770/document|here> for a more detailed argumentation). But I am not that convinced of my own hypothesis either.",
        "team": "T5TCAFTA9",
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZMMyp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " While I agree with all your observations, I am not convinced by the explanation. My own speculative hypothesis for the relevant difference between hardware and software is Turing-completeness leading to chaotic dynamics and thus an infinity of failure modes (see "
                            },
                            {
                                "type": "link",
                                "url": "https://hal.science/hal-02071770/document",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": " for a more detailed argumentation). But I am not that convinced of my own hypothesis either."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]