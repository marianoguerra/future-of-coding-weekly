[
    {
        "subtype": "thread_broadcast",
        "user": "U05EREC3DCK",
        "thread_ts": "1707635992.054799",
        "root": {
            "user": "U03GBV8B58V",
            "type": "message",
            "ts": "1707635992.054799",
            "client_msg_id": "12ab9f7c-e9da-4446-8396-92aae182dd95",
            "text": "New visual programming languages don't fail as visual programming languages.\n\nThey fail as programming languages, which is what most new programming languages do.",
            "team": "T5TCAFTA9",
            "thread_ts": "1707635992.054799",
            "reply_count": 19,
            "reply_users_count": 7,
            "latest_reply": "1710632578.134659",
            "reply_users": [
                "UC2A2ARPT",
                "U03GBV8B58V",
                "U06H4766K42",
                "U02U0AS3J49",
                "U0378MDUG1Y",
                "U05EREC3DCK",
                "UE6EFEPTQ"
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "kLeJ4",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "New visual programming languages don't fail as visual programming languages.\n\nThey fail as programming languages, which is what most new programming languages do."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1710503961.422659",
        "client_msg_id": "f6e2b18f-251a-4de6-b065-a2828a820036",
        "text": "The best way I would describe it is like this. Let's say that reality is like a state computation machine. How would it be possible to create a more accurate model of reality than we have currently? It would have to go beyond words, and would have to include visual, kinaesthetic constructs. It would have to be a higher dimensional representation, to the extent that we as humans can perceive a higher dimensional representation. So this means, higher than the 1D text we have, or its 2D UI, single frame in time representation. This would look like some kind of 4D temporal model, where it's possible to see the execution of a program in its entirety, all at once.\n\nIt would not only show semantic relationships in a graph sense, but also model the data structures and their operation over time. So the idea of \"stocks\" of data, and \"flows\" of data (from Donella Meadows, Systems Thinking) would apply here. React.useState might be represented as a small orb of energy, and if we setState, then it would visually change. When we assign const a = b, then it would visually indicate a flow of information from b -&gt; a. I think this would be a much clearer representation of what a program is doing, and free up cognitive load to focus on more important tasks, as opposed to the programmer having to hold a mental model in their head. No matter how good a programmer is, if he or she possesses a better more accurate kinesthetic model of what is happening, their brain power is freed up to solve more problematic and relevant abstractions.\n\nI've been mocking up a prototype of how this would work, and the basic idea is overlaying a tool like VSCode with \"vibes\" as well as flow relations. It's like an annotation layer over existing code, but this is just the basic start of how it would look like. Ultimately, it would look like a mini universe.\n\n<http://www.eusaybia.com|www.eusaybia.com> for a non-programming context demonstration of what I'm talking about.",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EJah7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The best way I would describe it is like this. Let's say that reality is like a state computation machine. How would it be possible to create a more accurate model of reality than we have currently? It would have to go beyond words, and would have to include visual, kinaesthetic constructs. It would have to be a higher dimensional representation, to the extent that we as humans can perceive a higher dimensional representation. So this means, higher than the 1D text we have, or its 2D UI, single frame in time representation. This would look like some kind of 4D temporal model, where it's possible to see the execution of a program in its entirety, all at once.\n\nIt would not only show semantic relationships in a graph sense, but also model the data structures and their operation over time. So the idea of \"stocks\" of data, and \"flows\" of data (from Donella Meadows, Systems Thinking) would apply here. React.useState might be represented as a small orb of energy, and if we setState, then it would visually change. When we assign const a = b, then it would visually indicate a flow of information from b -> a. I think this would be a much clearer representation of what a program is doing, and free up cognitive load to focus on more important tasks, as opposed to the programmer having to hold a mental model in their head. No matter how good a programmer is, if he or she possesses a better more accurate kinesthetic model of what is happening, their brain power is freed up to solve more problematic and relevant abstractions.\n\nI've been mocking up a prototype of how this would work, and the basic idea is overlaying a tool like VSCode with \"vibes\" as well as flow relations. It's like an annotation layer over existing code, but this is just the basic start of how it would look like. Ultimately, it would look like a mini universe.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "http://www.eusaybia.com",
                                "text": "www.eusaybia.com"
                            },
                            {
                                "type": "text",
                                "text": " for a non-programming context demonstration of what I'm talking about."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U06H4766K42"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05EREC3DCK",
        "type": "message",
        "ts": "1710504901.802799",
        "client_msg_id": "b0619ab2-3e33-4183-949f-c097c30bba50",
        "text": "Another concept I've been ideating about is how to bring Literate Programming, by Donald Knuth, into my daily work, which involves modern tools and stacks like VSCode and Node.js. I believe inline, rich text snippets which are integrated with some kind of personal knowledge management system is the way to go. This way, instead of having comments like this:\n\n// TODO: Refactor this to use the revised approach\n\nIt instead would look like using Notion or Obsidian inside VSCode. So above a function, would be a small window into a single page that describes a single function. You can do anything here, like linking references that are relevant to the design of the function. Or you could even have a lengthy design document that explains why a function was written a certain way. Going even further, you could have a page which describes the evolution of a function over time, why at the beginning it was written a certain way, why changes had to be made, and why it looks the way it looks right now.\n\nAnd added bonus of this approach is that now it's possible to have a single source of truth for docs and your code. So rather than maintaining a separate Docusaurus that has to be updated to sync it with evolution in code, you can just maintain documentation in line. And then to publish developer docs online, you merely just take all the little snippets above each function and then aggregate them onto a single page.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710504901.802799",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1710654653.469789",
        "reply_users": [
            "U8A5MS6R1",
            "U05EREC3DCK"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5mNXw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another concept I've been ideating about is how to bring Literate Programming, by Donald Knuth, into my daily work, which involves modern tools and stacks like VSCode and Node.js. I believe inline, rich text snippets which are integrated with some kind of personal knowledge management system is the way to go. This way, instead of having comments like this:\n\n// TODO: Refactor this to use the revised approach\n\nIt instead would look like using Notion or Obsidian inside VSCode. So above a function, would be a small window into a single page that describes a single function. You can do anything here, like linking references that are relevant to the design of the function. Or you could even have a lengthy design document that explains why a function was written a certain way. Going even further, you could have a page which describes the evolution of a function over time, why at the beginning it was written a certain way, why changes had to be made, and why it looks the way it looks right now.\n\nAnd added bonus of this approach is that now it's possible to have a single source of truth for docs and your code. So rather than maintaining a separate Docusaurus that has to be updated to sync it with evolution in code, you can just maintain documentation in line. And then to publish developer docs online, you merely just take all the little snippets above each function and then aggregate them onto a single page."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "U06EU9S1Y68"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U05EREC3DCK",
        "type": "message",
        "ts": "1710505040.164099",
        "client_msg_id": "4d7905c4-1148-4ec1-951a-c7e3a9782fe8",
        "text": "Basically, this approach is powerful because instead of 1D strings of text, now you can have the power of rich text in your code. Including diagrams, and even embedding other programs through &lt;iframes&gt; would be possible. And when your code needs to be compiled, all these rich text snippets are simply removed.",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OF5w7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Basically, this approach is powerful because instead of 1D strings of text, now you can have the power of rich text in your code. Including diagrams, and even embedding other programs through <iframes> would be possible. And when your code needs to be compiled, all these rich text snippets are simply removed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1710549309.108009",
        "client_msg_id": "68dda652-bd2e-41af-862f-79b885a567ba",
        "text": "To expand on this - can we also use hyperlinks to represent links within the code itself? Eg if you have a type annotation `a: TheType`, then `TheType` is not a piece of text but a hypertext link to the type definition. These would be resolved at edit time. Same with method calls that can be resolved. Dynamic dispatch / abstract classes can be represented by a link to the base definition.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710504901.802799",
        "parent_user_id": "U05EREC3DCK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DOPkV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To expand on this - can we also use hyperlinks to represent links within the code itself? Eg if you have a type annotation "
                            },
                            {
                                "type": "text",
                                "text": "a: TheType",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then "
                            },
                            {
                                "type": "text",
                                "text": "TheType",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is not a piece of text but a hypertext link to the type definition. These would be resolved at edit time. Same with method calls that can be resolved. Dynamic dispatch / abstract classes can be represented by a link to the base definition."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05EREC3DCK",
        "type": "message",
        "ts": "1710654653.469789",
        "client_msg_id": "71a04867-8772-47b0-b2a6-349c7dca74a6",
        "text": "That'd be useful. It'd be a type of transclusion then. Instead of having to refactor the class name, or type name, whenever you edit the name, it's editing all instances all at once.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710504901.802799",
        "parent_user_id": "U05EREC3DCK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pz/NK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That'd be useful. It'd be a type of transclusion then. Instead of having to refactor the class name, or type name, whenever you edit the name, it's editing all instances all at once."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]