[
    {
        "subtype": "thread_broadcast",
        "user": "U05EREC3DCK",
        "thread_ts": "1709980143.296959",
        "root": {
            "user": "U03GBV8B58V",
            "type": "message",
            "ts": "1709980143.296959",
            "client_msg_id": "757b125f-d6f3-4adc-ad7c-e99fc2e83b7d",
            "text": "Software products are physical products. That's why they're hard to design and engineer!\n\nThe physicality of software is kept at arms-length in a vector-based design tool. Here, the strength and focus is on surface level aesthetics and exploration though mocks \u2014 many, many mocks. All needed. All useful. But a mock does not a product make. A mock is an incomplete story of software physics. Which brings us the other side of the spectrum...\n\nThe IDEs \u2014 the code editors. The product you ship is here, so \"I guess someone has to go there\". First challenge: To most people it's walls of inexplicable symbols and weird (even hostile?) punctuation. Then, with code, you're essentially play-acting as a computer. You have to \"speak computer\" fluently to feel at home here. It's a love/hate relationship of running programs in your head. Mostly failing to do so. Then learning to get better at debugging. Eureka moments of finally solving the puzzle that unlocks a bugfix! Endlessly restarting programs to reset state. Today, even after multiple decades of investment in IDEs, coding is still 100 times harder and less fun than it should be! How can we truly move the needle?\n\nA traditional IDE deals with the how to fully describe the physics of a software system. Writing and editing algorithms. Managing data flows. Figuring out logic. Painting pixels. Sending data at the speed of light over the network. But the IDE doesn't actually let you _see_ the program as it manifests to the user in the final medium. It's running somewhere else \u2014 the browser, on your phone. This is where vector-tools have the IDEs at least partially beat. Yes, they're just mocks, but the vector-tool tool _sees_ the mocks alongside you. This changes your relationship with the tool. Thinking and touching \u2014 moving, dragging, scaling, rotating, duplicating \u2014 seamlessly blends on a canvas, and it just _feels_ _good, even fun!_ IDEs and editing code as text offers none of those things with today's tools, and it just feels like... friction!\n\nSo the letter to Santa reads as follows:\n\n_Dear Santa, give me the best parts of a vector-based design tool, plus the best parts of an IDE, rolled into one \u2014 but with none of the downsides. Thanks!_\n\nChristmas can't get here fast enough.",
            "team": "T5TCAFTA9",
            "thread_ts": "1709980143.296959",
            "reply_count": 19,
            "reply_users_count": 7,
            "latest_reply": "1711878481.136949",
            "reply_users": [
                "UGWUJUZHT",
                "U03GBV8B58V",
                "UC2A2ARPT",
                "UCUSW7WVD",
                "U5STGTB3J",
                "U04SAJZ155H",
                "U05EREC3DCK"
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "gLmKS",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Software products are physical products. That's why they're hard to design and engineer!\n\nThe physicality of software is kept at arms-length in a vector-based design tool. Here, the strength and focus is on surface level aesthetics and exploration though mocks \u2014 many, many mocks. All needed. All useful. But a mock does not a product make. A mock is an incomplete story of software physics. Which brings us the other side of the spectrum...\n\nThe IDEs \u2014 the code editors. The product you ship is here, so \"I guess someone has to go there\". First challenge: To most people it's walls of inexplicable symbols and weird (even hostile?) punctuation. Then, with code, you're essentially play-acting as a computer. You have to \"speak computer\" fluently to feel at home here. It's a love/hate relationship of running programs in your head. Mostly failing to do so. Then learning to get better at debugging. Eureka moments of finally solving the puzzle that unlocks a bugfix! Endlessly restarting programs to reset state. Today, even after multiple decades of investment in IDEs, coding is still 100 times harder and less fun than it should be! How can we truly move the needle?\n\nA traditional IDE deals with the how to fully describe the physics of a software system. Writing and editing algorithms. Managing data flows. Figuring out logic. Painting pixels. Sending data at the speed of light over the network. But the IDE doesn't actually let you "
                                },
                                {
                                    "type": "text",
                                    "text": "see",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " the program as it manifests to the user in the final medium. It's running somewhere else \u2014 the browser, on your phone. This is where vector-tools have the IDEs at least partially beat. Yes, they're just mocks, but the vector-tool tool "
                                },
                                {
                                    "type": "text",
                                    "text": "sees",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " the mocks alongside you. This changes your relationship with the tool. Thinking and touching \u2014 moving, dragging, scaling, rotating, duplicating \u2014 seamlessly blends on a canvas, and it just "
                                },
                                {
                                    "type": "text",
                                    "text": "feels",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " "
                                },
                                {
                                    "type": "text",
                                    "text": "good, even fun!",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " IDEs and editing code as text offers none of those things with today's tools, and it just feels like... friction!\n\nSo the letter to Santa reads as follows:\n\n"
                                },
                                {
                                    "type": "text",
                                    "text": "Dear Santa, give me the best parts of a vector-based design tool, plus the best parts of an IDE, rolled into one \u2014 but with none of the downsides. Thanks!",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": "\n\nChristmas can't get here fast enough."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1711878481.136949",
        "edited": {
            "user": "U05EREC3DCK",
            "ts": "1711878771.000000"
        },
        "client_msg_id": "35a3c029-b102-4299-9848-1d9e65352a26",
        "text": "<@U03GBV8B58V> I'm working on something a bit like what you're talking about. The biggest problem I see at the moment is that the best programmers (and AI to a large extent these days) have developed a meta cognitive layer over plain textual code, that more accurately describes the data structures and flows of information inherent in code.\n\nSimplest example is assignment\n\nlet fruit = \"banana\"\n\nThe implicit flow is\n\n\"banana\" -> fruit\n\n\"banana\" is also a constant, whereas the variable fruit, is a store of information that may change over time.\n\nSo how to visually represent that fruit is possibly changing, and is a store of information, and that the string \"banana\" is constant, beyond the obvious string marks and let declaration?\n\nWe could show a flowing string of information that goes from \"banana\" to the variable fruit. Fruit could be highlighted with water as a background, and \"banana\" could be highlighted with concrete as a background. Maybe this isn't the best visual representation but you get what I mean.\n\nObviously it gets way more complicated than simple variable declarations and variable assignment but imagine if this kind of visual representation was extended to almost every single aspect of the language?\n\nIf, we could explicitly show this implicit meta cognitive layer as visually overlaid over the text itself, it would be a revolution for newbies and seasoned veterans. For newbies, they would understand the logic and flow of the code much much faster, and for veterans, their brain power would be freed from trying to visualise this meta cognitive structure, to focusing on even higher abstraction problems.\n\nThe main problems I see are:\n1. Identifying all the implicit structures inside our programming languages\n2. Creating an intuitive visual representation of each, that is easily understandable",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jn2+c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U03GBV8B58V"
                            },
                            {
                                "type": "text",
                                "text": " I'm working on something a bit like what you're talking about. The biggest problem I see at the moment is that the best programmers (and AI to a large extent these days) have developed a meta cognitive layer over plain textual code, that more accurately describes the data structures and flows of information inherent in code.\n\nSimplest example is assignment\n\nlet fruit = \"banana\"\n\nThe implicit flow is\n\n\"banana\" -> fruit\n\n\"banana\" is also a constant, whereas the variable fruit, is a store of information that may change over time.\n\nSo how to visually represent that fruit is possibly changing, and is a store of information, and that the string \"banana\" is constant, beyond the obvious string marks and let declaration?\n\nWe could show a flowing string of information that goes from \"banana\" to the variable fruit. Fruit could be highlighted with water as a background, and \"banana\" could be highlighted with concrete as a background. Maybe this isn't the best visual representation but you get what I mean.\n\nObviously it gets way more complicated than simple variable declarations and variable assignment but imagine if this kind of visual representation was extended to almost every single aspect of the language?\n\nIf, we could explicitly show this implicit meta cognitive layer as visually overlaid over the text itself, it would be a revolution for newbies and seasoned veterans. For newbies, they would understand the logic and flow of the code much much faster, and for veterans, their brain power would be freed from trying to visualise this meta cognitive structure, to focusing on even higher abstraction problems.\n\nThe main problems I see are:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Identifying all the implicit structures inside our programming languages"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Creating an intuitive visual representation of each, that is easily understandable"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "U03GBV8B58V"
                ],
                "count": 2
            }
        ]
    }
]