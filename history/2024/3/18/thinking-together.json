[
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710792969.247549",
        "client_msg_id": "4b42c875-97b1-43ad-b148-eb4cc95584c7",
        "text": "Is there any wisdom on *how to best lay out code in a visual code browser*?\n\nIn my experience, code can be layed out either more horizontally on long lines or more vertically on short lines. This is controlled by setting a criterion for how many levels of nesting there can be before a node switches to a multiline layout. Long lines use space efficiently but tend to get hard to read. Short lines are easier to read, as tokens of similar significance line up in columns, but tend to take up much vertical space while leaving most of the horizontal space unused, as the average line is just one key and one value.\n\nShall I accept that code gets very vertical, and use the free horizontal space to add multilevel navigation panels, or is there a third option that is more horizontal while still easy to read? I can go really fancy and add tables and multiple columns, since I have full control over the layout function, but not all code is regular enough to fit a tabular format, and I cannot require the person editing the code to manually bikeshed it by editing whitespace or dragging around visual nodes. I've seen the <https://gitlab.com/procps-ng/procps/-/blob/master/src/top/top.c|horrors of manually bikeshedded plain-text languages> and the horrors of node-based languages where the programmer makes a simple one node change and then has to drag all the nodes around so they line up. Are there any examples of interesting solutions to look at?\n\nHere's how I mean a more horizontal layout:\n\n&gt; *element 1* { _key 1_: value 1, _key 2_: value 2, _key 3_: *surprise* { _key 1_: value 1 } }\n&gt; *element 2* { _key 1_: value 1 }\nHere's how I mean a more vertical layout:\n\n&gt; *element 1* {\n&gt;     _key 1_: value 1,\n&gt;     _key 2_: value 2,\n&gt;     _key 3_: *surprise* {\n&gt;         _key 1_: value 1,\n&gt;     },\n&gt; }\n&gt; *element 2* {\n&gt;     _key 1_: value 1,\n&gt; }\nIn the more horizontal layout, I can barely parse the surprise structure at a glance, and I can barely see if I've made a mistake in editing. It takes a lot less screen space though.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "reply_count": 18,
        "reply_users_count": 5,
        "latest_reply": "1710957971.279669",
        "reply_users": [
            "UMQ6LR9NZ",
            "U04SAJZ155H",
            "US370TRJA",
            "U06M6J30PE3",
            "U016VUZGUUQ"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U4tEa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is there any wisdom on "
                            },
                            {
                                "type": "text",
                                "text": "how to best lay out code in a visual code browser",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "?\n\nIn my experience, code can be layed out either more horizontally on long lines or more vertically on short lines. This is controlled by setting a criterion for how many levels of nesting there can be before a node switches to a multiline layout. Long lines use space efficiently but tend to get hard to read. Short lines are easier to read, as tokens of similar significance line up in columns, but tend to take up much vertical space while leaving most of the horizontal space unused, as the average line is just one key and one value.\n\nShall I accept that code gets very vertical, and use the free horizontal space to add multilevel navigation panels, or is there a third option that is more horizontal while still easy to read? I can go really fancy and add tables and multiple columns, since I have full control over the layout function, but not all code is regular enough to fit a tabular format, and I cannot require the person editing the code to manually bikeshed it by editing whitespace or dragging around visual nodes. I've seen the "
                            },
                            {
                                "type": "link",
                                "url": "https://gitlab.com/procps-ng/procps/-/blob/master/src/top/top.c",
                                "text": "horrors of manually bikeshedded plain-text languages"
                            },
                            {
                                "type": "text",
                                "text": " and the horrors of node-based languages where the programmer makes a simple one node change and then has to drag all the nodes around so they line up. Are there any examples of interesting solutions to look at?\n\nHere's how I mean a more horizontal layout:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "element 1",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " { "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1, "
                            },
                            {
                                "type": "text",
                                "text": "key 2",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 2, "
                            },
                            {
                                "type": "text",
                                "text": "key 3",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": "
                            },
                            {
                                "type": "text",
                                "text": "surprise",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " { "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1 } }\n"
                            },
                            {
                                "type": "text",
                                "text": "element 2",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " { "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1 }"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nHere's how I mean a more vertical layout:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "element 1",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " {\n    "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1,\n    "
                            },
                            {
                                "type": "text",
                                "text": "key 2",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 2,\n    "
                            },
                            {
                                "type": "text",
                                "text": "key 3",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": "
                            },
                            {
                                "type": "text",
                                "text": "surprise",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " {\n        "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1,\n    },\n}\n"
                            },
                            {
                                "type": "text",
                                "text": "element 2",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " {\n    "
                            },
                            {
                                "type": "text",
                                "text": "key 1",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": value 1,\n}"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIn the more horizontal layout, I can barely parse the surprise structure at a glance, and I can barely see if I've made a mistake in editing. It takes a lot less screen space though."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1710795604.617009",
        "client_msg_id": "6b2f0aff-23e0-4109-90f4-1b946eb657b4",
        "text": "Not sure if this really helps, but, navigating your examples with a screen reader (something I use for work but not full time) the first example is read verbatim, like a sentence, whereas the second example is read in a more structured way, making the user navigate from key to value, etc.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qllms",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not sure if this really helps, but, navigating your examples with a screen reader (something I use for work but not full time) the first example is read verbatim, like a sentence, whereas the second example is read in a more structured way, making the user navigate from key to value, etc."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710796898.306469",
        "edited": {
            "user": "U04SAJZ155H",
            "ts": "1710796997.000000"
        },
        "client_msg_id": "2e0cd47e-8848-45c7-b151-5411b2098ea5",
        "text": "<@UMQ6LR9NZ> That's the reading you get from the plain text on Slack. In my real app, you get a different reading. I've found it helpful to test my apps with a screen reader, and I've decided to design separately for visual presentation and screen readers, so there's no need to adjust the visual presentation to work with screen readers. Screen readers get the full hierarchy of all nodes, and the user can use the arrow keys to navigate individual nodes. Each node reads a summary, and the user can navigate into it to read more about the child nodes.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UQUpO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UMQ6LR9NZ"
                            },
                            {
                                "type": "text",
                                "text": " That's the reading you get from the plain text on Slack. In my real app, you get a different reading. I've found it helpful to test my apps with a screen reader, and I've decided to design separately for visual presentation and screen readers, so there's no need to adjust the visual presentation to work with screen readers. Screen readers get the full hierarchy of all nodes, and the user can use the arrow keys to navigate individual nodes. Each node reads a summary, and the user can navigate into it to read more about the child nodes."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UMQ6LR9NZ"
                ],
                "count": 1
            },
            {
                "name": "captain-planet",
                "users": [
                    "UMQ6LR9NZ",
                    "UFEQUBNNT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "US370TRJA",
        "type": "message",
        "ts": "1710821462.327829",
        "client_msg_id": "C277820F-EBE5-4452-BA00-1FA5F7D09873",
        "text": "I think two general books about typography/ print layout may be relevant to . Both make the point that text is scanned / reread repeatedly. Because it isn\u2019t necessarily read linearly, having \u201clandmarks\u201d that gives your eyes something to hook onto and make related structures chunkable as shapes is valuable. These marks are provided by the indentation. Apart from the words, both of these books practice what they preach when it comes to creative and memorable text layouts.\n\n\u2022 what we see when we read by Peter mendelsund \n\u2022 Seeing with fresh eyes by Edward Tufte \nIn visual neuroscience they benchmarked the page width at which reading speed / comprehension drops off a cliff aside from the basic physical constraint of reducing the amount of eye or neck movement to follow along.\n\nThe specific count varies by language / what comprehension means for your context, but it helps provide empirical backing for the intuition for why there\u2019s a sweet spot in between being vertical vs horizontal heavy.\n\nYour code / json data editor sounds neat. I get your concern about the risk of an author getting caught up in formatting bikesheds. One middle ground that comes to mind looking at your examples is letting the code be autoformatted however, but if I add a comment annotation before a section, in \u201cview mode\u201d for the next section, that section could be forced into a vertical or horizontal mode, whatever I the author recommended.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lMESG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think two general books about typography/ print layout may be relevant to . Both make the point that text is scanned / reread repeatedly. Because it isn\u2019t necessarily read linearly, having \u201clandmarks\u201d that gives your eyes something to hook onto and make related structures chunkable as shapes is valuable. These marks are provided by the indentation. Apart from the words, both of these books practice what they preach when it comes to creative and memorable text layouts.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "what we see when we read by Peter mendelsund "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Seeing with fresh eyes by Edward Tufte "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIn visual neuroscience they benchmarked the page width at which reading speed / comprehension drops off a cliff aside from the basic physical constraint of reducing the amount of eye or neck movement to follow along.\n\nThe specific count varies by language / what comprehension means for your context, but it helps provide empirical backing for the intuition for why there\u2019s a sweet spot in between being vertical vs horizontal heavy.\n\nYour code / json data editor sounds neat. I get your concern about the risk of an author getting caught up in formatting bikesheds. One middle ground that comes to mind looking at your examples is letting the code be autoformatted however, but if I add a comment annotation before a section, in \u201cview mode\u201d for the next section, that section could be forced into a vertical or horizontal mode, whatever I the author recommended."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710834246.901459",
        "client_msg_id": "35bcfa7a-018b-4c2d-8601-5a3d6022ab71",
        "text": "<@US370TRJA> You make an interesting point about having an automatic default but letting the author override it for selected code. This is an idea I have already largely rejected. I don't trust myself to manually format my own code. I have way too much cognitive bias for that, so my formatting choices tell only how I was feeling the day the code was formatted, and what code I was reading earlier that day.\n\nThis problem occurs to me with argument lists of function definitions in Rust. Traditionally, argument lists are formatted horizontally, but sometimes they get long, or one argument may have a long name or long type, and then I format them vertically. Then I go edit another function which doesn't have a long argument list, and I format that vertically too, because of the <https://en.wikipedia.org/wiki/Halo_effect|halo effect>. Rust has a tool called _rustfmt_ that does exactly this middleground, automatic formatting with manual overriding in places, and I've not found it helpful.\n\nManual formatting also assumes that everyone views the code the same way as the person who formatted it. That's why we have silly commandments that the tab size must be set to a certain number of columns, or a page must be viewed in IE 5.5 with a screen resolution of 1024\u00d7768 pixels, or perhaps worst of all, assuming that everyone will view the code with a monospace font. (I don't, and even the <https://www.youtube.com/watch?v=uknEhXyZgsg|Smalltalk browser from the 1970s> didn't.)\n\nThanks for the book recommendations! I will need to take more time to look at them. I love a good book about typography.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=uknEhXyZgsg",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/uknEhXyZgsg/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/uknEhXyZgsg?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"Alto System Project: Dan Ingalls demonstrates Smalltalk\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=uknEhXyZgsg",
                "fallback": "YouTube Video: Alto System Project: Dan Ingalls demonstrates Smalltalk",
                "title": "Alto System Project: Dan Ingalls demonstrates Smalltalk",
                "title_link": "https://www.youtube.com/watch?v=uknEhXyZgsg",
                "author_name": "Computer History Museum",
                "author_link": "https://www.youtube.com/@ComputerHistory",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WVk/D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "US370TRJA"
                            },
                            {
                                "type": "text",
                                "text": " You make an interesting point about having an automatic default but letting the author override it for selected code. This is an idea I have already largely rejected. I don't trust myself to manually format my own code. I have way too much cognitive bias for that, so my formatting choices tell only how I was feeling the day the code was formatted, and what code I was reading earlier that day.\n\nThis problem occurs to me with argument lists of function definitions in Rust. Traditionally, argument lists are formatted horizontally, but sometimes they get long, or one argument may have a long name or long type, and then I format them vertically. Then I go edit another function which doesn't have a long argument list, and I format that vertically too, because of the "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Halo_effect",
                                "text": "halo effect"
                            },
                            {
                                "type": "text",
                                "text": ". Rust has a tool called "
                            },
                            {
                                "type": "text",
                                "text": "rustfmt",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that does exactly this middleground, automatic formatting with manual overriding in places, and I've not found it helpful.\n\nManual formatting also assumes that everyone views the code the same way as the person who formatted it. That's why we have silly commandments that the tab size must be set to a certain number of columns, or a page must be viewed in IE 5.5 with a screen resolution of 1024\u00d7768 pixels, or perhaps worst of all, assuming that everyone will view the code with a monospace font. (I don't, and even the "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=uknEhXyZgsg",
                                "text": "Smalltalk browser from the 1970s"
                            },
                            {
                                "type": "text",
                                "text": " didn't.)\n\nThanks for the book recommendations! I will need to take more time to look at them. I love a good book about typography."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "US370TRJA"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710885147.978319",
        "edited": {
            "user": "U06M6J30PE3",
            "ts": "1710885736.000000"
        },
        "client_msg_id": "a118f617-5de0-4789-b62a-946fc5ff5611",
        "text": "Prettier (JS formatter) has a link to a paper on this. They do a kind of recursive line breaking <https://archive.jlongster.com/A-Prettier-Formatter|https://archive.jlongster.com/A-Prettier-Formatter>\n\n<https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf&ved=2ahUKEwi4tPDzqYGFAxXqOEQIHXhtCxMQFnoECBYQAQ&usg=AOvVaw3vySA2A21-D_yQk1Dqqx-O|https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf&ved=2ahUKEwi4tPDzqYGFAxXqOEQIHXhtCxMQFnoECBYQAQ&usg=AOvVaw3vySA2A21-D_yQk1Dqqx-O>",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "attachments": [
            {
                "from_url": "https://archive.jlongster.com/A-Prettier-Formatter",
                "service_icon": "https://archive.jlongster.com/apple-touch-icon.png?v=9BPpBz2Gvb",
                "id": 1,
                "original_url": "https://archive.jlongster.com/A-Prettier-Formatter",
                "fallback": "A Prettier JavaScript Formatter",
                "text": "Today I am announcing prettier, a JavaScript formatter inspired by refmt with advanced support for language features from ES2017, JSX, and Flow.",
                "title": "A Prettier JavaScript Formatter",
                "title_link": "https://archive.jlongster.com/A-Prettier-Formatter",
                "service_name": "archive.jlongster.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bM8uR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Prettier (JS formatter) has a link to a paper on this. They do a kind of recursive line breaking "
                            },
                            {
                                "type": "link",
                                "url": "https://archive.jlongster.com/A-Prettier-Formatter",
                                "text": "https://archive.jlongster.com/A-Prettier-Formatter"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf&ved=2ahUKEwi4tPDzqYGFAxXqOEQIHXhtCxMQFnoECBYQAQ&usg=AOvVaw3vySA2A21-D_yQk1Dqqx-O",
                                "text": "https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf&ved=2ahUKEwi4tPDzqYGFAxXqOEQIHXhtCxMQFnoECBYQAQ&usg=AOvVaw3vySA2A21-D_yQk1Dqqx-O"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710885230.443909",
        "client_msg_id": "c6f71bbc-5a97-419c-a09e-587206f2ba6d",
        "text": "You can do neat things like split horizontal layouts into vertical at the root first and the leaves stay horizontal",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/RvUz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can do neat things like split horizontal layouts into vertical at the root first and the leaves stay horizontal"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "<@U06M6J30PE3> The paper assumes that more horizontal is always better, which is what I was questioning. It crams as much as it can into one line, ignoring readability, then breaks when necessary, and then adds more bits and pieces from the parent level horizontally if possible.\n\nHere's an example I made where I depart from traditional plain text code and format a list as a table with a balance of horizontal and vertical spread.",
        "files": [
            {
                "id": "F06R25CUQD6",
                "created": 1710905244,
                "timestamp": 1710905244,
                "name": "formatted expression.png",
                "title": "formatted expression.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U04SAJZ155H",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 48631,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F06R25CUQD6/formatted_expression.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F06R25CUQD6/download/formatted_expression.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 87,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 117,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 175,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 194,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R25CUQD6-7418645861/formatted_expression_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 233,
                "original_w": 971,
                "original_h": 236,
                "thumb_tiny": "AwALADDRxQT1+lLRigBhPyil/jNLgYpaAEx9fzox9fzpaKAP/9k=",
                "permalink": "https://futureofcoding.slack.com/files/U04SAJZ155H/F06R25CUQD6/formatted_expression.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F06R25CUQD6-488d03ceee",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "U04SAJZ155H",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W8ROC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06M6J30PE3"
                            },
                            {
                                "type": "text",
                                "text": " The paper assumes that more horizontal is always better, which is what I was questioning. It crams as much as it can into one line, ignoring readability, then breaks when necessary, and then adds more bits and pieces from the parent level horizontally if possible.\n\nHere's an example I made where I depart from traditional plain text code and format a list as a table with a balance of horizontal and vertical spread."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1710905357.768639",
        "client_msg_id": "368b850d-0f2c-465e-b899-19b066cfd33e",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H"
    },
    {
        "text": "Here's an example of an object literal with vertical and horizontal spacing:",
        "files": [
            {
                "id": "F06R26F6HLG",
                "created": 1710906222,
                "timestamp": 1710906222,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U06M6J30PE3",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 95258,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F06R26F6HLG/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F06R26F6HLG/download/image.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 149,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 199,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 299,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F06R26F6HLG-c35c70e07d/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 332,
                "original_w": 952,
                "original_h": 395,
                "thumb_tiny": "AwATADCkBkUmDTlOBTSSfXFAC4oxRmjNACY96KSigBy9DQOlC0DpQAdjSE0vY0h60AGTSZoooA//2Q==",
                "permalink": "https://futureofcoding.slack.com/files/U06M6J30PE3/F06R26F6HLG/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F06R26F6HLG-7c2b4ebd63",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "U06M6J30PE3",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hWJZ6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's an example of an object literal with vertical and horizontal spacing:"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1710906225.925409",
        "client_msg_id": "cb3bc3cf-4e01-4dc5-aa0c-18fc6de45c22",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H"
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710906331.746489",
        "client_msg_id": "7fac6ab9-88dd-4ff6-80d4-04114cde12b3",
        "text": "Btw, the underlying system (at least as implemented in Prettier) is flexible enough to achieve basically whatever balance of horizontal and vertical you want, the core insight is just that breaking recursively at a structural level can produce more readable formatting.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E9uOL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Btw, the underlying system (at least as implemented in Prettier) is flexible enough to achieve basically whatever balance of horizontal and vertical you want, the core insight is just that breaking recursively at a structural level can produce more readable formatting."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710906640.374599",
        "client_msg_id": "bd732728-26b9-43a5-9f84-b2a1d4a076b9",
        "text": "If you want to go beyond plain text editors, you could try converting code to/from a HTML representation (or LaTex if such a thing as a real-time renderer for LaTex exists).",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mmeNx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you want to go beyond plain text editors, you could try converting code to/from a HTML representation (or LaTex if such a thing as a real-time renderer for LaTex exists)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710906657.992789",
        "client_msg_id": "b1bb8b84-234e-46e3-8957-6de9c628043c",
        "text": "<@U06M6J30PE3> I suppose Prettier has some extended variant of the method from the paper. That example of an object literal is interesting. It's the kind of example I was thinking of when asking the question. In ordinary plain text code, I would avoid that, as I don't like the runs of space characters, but in a non-plain text layout I can do such things with advantage.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "55gOk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06M6J30PE3"
                            },
                            {
                                "type": "text",
                                "text": " I suppose Prettier has some extended variant of the method from the paper. That example of an object literal is interesting. It's the kind of example I was thinking of when asking the question. In ordinary plain text code, I would avoid that, as I don't like the runs of space characters, but in a non-plain text layout I can do such things with advantage."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710906703.997519",
        "client_msg_id": "62aa2eb4-3e2e-4c58-9073-03e228fb4ecb",
        "text": "I actually forked Prettier and added support for aligning columns that way; Prettier by itself doesn't insert quite so much whitespace (I find it easier to read).",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hhdhR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I actually forked Prettier and added support for aligning columns that way; Prettier by itself doesn't insert quite so much whitespace (I find it easier to read)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710907013.485389",
        "client_msg_id": "34f2a797-1e4e-488f-ab95-c4165074861d",
        "text": "<@U06M6J30PE3> There's Typst, which is like Tex but almost real-time. My primary output is a native app where I render directly to a region of pixels, so I have a lot of freedom. Secondarily, I also want HTML output, because I want it to be easy to share code with people who don't have the native app. The example I posted is HTML, where the big parentheses are a creative use of CSS.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jQv/I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06M6J30PE3"
                            },
                            {
                                "type": "text",
                                "text": " There's Typst, which is like Tex but almost real-time. My primary output is a native app where I render directly to a region of pixels, so I have a lot of freedom. Secondarily, I also want HTML output, because I want it to be easy to share code with people who don't have the native app. The example I posted is HTML, where the big parentheses are a creative use of CSS."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06M6J30PE3",
        "type": "message",
        "ts": "1710907201.613609",
        "client_msg_id": "7a600eb2-09ce-487f-bebb-16462bc85465",
        "text": "You can get pretty far with the DOM editable document command api, though it's an enormous pain.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "okoYS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can get pretty far with the DOM editable document command api, though it's an enormous pain."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710907367.897759",
        "client_msg_id": "2b18396e-615b-4e0e-b68e-10f69f7c8212",
        "text": "I'll keep the HTML read-only and have the native app for editing, or let people use an ordinary plain text editor if they don't have the app. I've done editable DOM many times enough before to know that it's a never-ending pain. Editable DOM apps are always buggy, and it's never going to be fixed.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wmqeU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll keep the HTML read-only and have the native app for editing, or let people use an ordinary plain text editor if they don't have the app. I've done editable DOM many times enough before to know that it's a never-ending pain. Editable DOM apps are always buggy, and it's never going to be fixed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1710947097.533449",
        "edited": {
            "user": "U016VUZGUUQ",
            "ts": "1710947157.000000"
        },
        "client_msg_id": "d3eae0f3-4502-4d85-90ec-2bf6862fece1",
        "text": "Personally in this case I would lean toward more vertical (with good folding), even though in hand written code I tend more horizontal. Vertical seems like the safe choice, with no fine tuning necessary. But if you're already shouldering the burden of a separate UI for screen readers, it seems like it might not be a big lift on top of that to make the balance of horizontal or vertical space into a user setting? I mean, if you're feeling ambitious.\n\nThere's also a sort of middle ground, where the user chooses between vertical and horizontal formatters per syntax tree node, with a UI (and state management) akin to code folding. You could think of horizontal formatting as a folding state intermediate between fully vertical and fully hidden.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vVqfp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Personally in this case I would lean toward more vertical (with good folding), even though in hand written code I tend more horizontal. Vertical seems like the safe choice, with no fine tuning necessary. But if you're already shouldering the burden of a separate UI for screen readers, it seems like it might not be a big lift on top of that to make the balance of horizontal or vertical space into a user setting? I mean, if you're feeling ambitious.\n\nThere's also a sort of middle ground, where the user chooses between vertical and horizontal formatters per syntax tree node, with a UI (and state management) akin to code folding. You could think of horizontal formatting as a folding state intermediate between fully vertical and fully hidden."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1710948167.176889",
        "client_msg_id": "590ccf63-15ca-4b92-af76-29c73411e541",
        "text": "<@U016VUZGUUQ> Yes, I'm feeling ambitious. The layout algorithm is a small enough part of the project that making it more complex is not a big deal. Personally I can't stand folding interfaces. I always end up setting them to the worst possible folding that gets the job done. I could as well keep my old automatic layout that is slightly better than the worst possible.\n\nFor top level navigation, there is a series of menus where the user selects a module, a class and then a method, similar to the Smalltalk browser. That replaces _macro-folding_. Once the user has selected a method, there is no more navigation, as the user likely wants to read the full source code of the selected method. It's here I'm trying to achieve a readable layout without implementing _micro-folding_.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "g8YKo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " Yes, I'm feeling ambitious. The layout algorithm is a small enough part of the project that making it more complex is not a big deal. Personally I can't stand folding interfaces. I always end up setting them to the worst possible folding that gets the job done. I could as well keep my old automatic layout that is slightly better than the worst possible.\n\nFor top level navigation, there is a series of menus where the user selects a module, a class and then a method, similar to the Smalltalk browser. That replaces "
                            },
                            {
                                "type": "text",
                                "text": "macro-folding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Once the user has selected a method, there is no more navigation, as the user likely wants to read the full source code of the selected method. It's here I'm trying to achieve a readable layout without implementing "
                            },
                            {
                                "type": "text",
                                "text": "micro-folding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U06M6J30PE3"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "US370TRJA",
        "type": "message",
        "ts": "1710957971.279669",
        "client_msg_id": "C91BE299-2128-4EC5-8246-66F417AD9EE2",
        "text": "Hi <@U04SAJZ155H> , thanks for the response and the rationale about avoiding the path of author overriding the default for the user.\n\nOne idea I\u2019ll offer is that the annotation is something the reader could offer bring to the table in their viewer. This is similar to how you can opt to fold/expand sections in VSCode for either bracketed code, or sections in markdown. A set of annotations is a filter, with unique filters for each situations. The name escapes me but I thought I saw a cool digital humanities project that used this \u201cstandoff annotation\u201d technique to help people with doing close readings.",
        "team": "T5TCAFTA9",
        "thread_ts": "1710792969.247549",
        "parent_user_id": "U04SAJZ155H",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k43P7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi "
                            },
                            {
                                "type": "user",
                                "user_id": "U04SAJZ155H"
                            },
                            {
                                "type": "text",
                                "text": " , thanks for the response and the rationale about avoiding the path of author overriding the default for the user.\n\nOne idea I\u2019ll offer is that the annotation is something the reader could offer bring to the table in their viewer. This is similar to how you can opt to fold/expand sections in VSCode for either bracketed code, or sections in markdown. A set of annotations is a filter, with unique filters for each situations. The name escapes me but I "
                            },
                            {
                                "type": "text",
                                "text": "thought"
                            },
                            {
                                "type": "text",
                                "text": " I saw a cool digital humanities project that used this \u201cstandoff annotation\u201d technique to help people with doing close readings."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U06M6J30PE3"
                ],
                "count": 1
            }
        ]
    }
]