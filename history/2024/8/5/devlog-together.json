[
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1722836207.656899",
        "client_msg_id": "1ACA686E-FC2F-4C37-9208-93668019F596",
        "text": "Got the visual design of the wiki mostly fleshed out. Fluid layout, one breakpoint that moves elements around for smaller screens, light and dark modes, nice keyboard nav, etc etc. Thoroughly documented too, since I figure some folks might want to peek at the css but aren't up on all the new weird stuff you can do.\n\nAlso, I'll be eating my hat now: everyone who scolded me for attempting to parse a markdown-like syntax with Regex, well, yeah, it kinda stinks. Not sure what to do about this, given the values I'd like to impart in this project. Since it's not a blocker on writing pages, I think I'll ship it half-finished and we can talk about it. This feels like a great area to draw on the wisdom of the crowd.\n\nMarkdown or not, we'll still need a build script, I reckon, unless we want to _require_ that anyone adding a new page also add their page to any relevant indexes \u2014 since, I reckon, we'll need some indexes just to get through the early phase where the wiki will be sparsely interconnected. To start, I'm thinking one index of broad categories (or maybe tags, dunno), and then another that's just a list of all pages. But if anyone has strong feelings about the right way to do this, I'm at least 75% ears.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "reply_count": 21,
        "reply_users_count": 8,
        "latest_reply": "1723103367.639429",
        "reply_users": [
            "UJBAJNFLK",
            "U02E4DAQGSZ",
            "UMQ6LR9NZ",
            "UC2A2ARPT",
            "UE6EFEPTQ",
            "UCUSW7WVD",
            "U71PMQ1V0",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X5HIp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Got the visual design of the wiki mostly fleshed out"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Fluid layout, one breakpoint that moves elements around for smaller screens, light and dark modes, nice keyboard nav, etc etc"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Thoroughly documented too, since I figure some folks might want to peek at the css but aren't up on all the new weird stuff you can do"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": "\n\nAlso, I'll be eating my hat now: everyone who scolded me for attempting to parse a markdown-like syntax with Regex, well, yeah, it kinda stinks"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Not sure what to do about this, given the values I'd like to impart in this project"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " S"
                            },
                            {
                                "type": "text",
                                "text": "ince it's not a blocker on writing pages"
                            },
                            {
                                "type": "text",
                                "text": ", I think I'll ship it half-finished and we can talk about it"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " This feels like a great area to draw on the wisdom of the crowd"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": "\n\nMarkdown or not, we'll still need a build script, I reckon, unless we want to "
                            },
                            {
                                "type": "text",
                                "text": "require",
                                "style": {
                                    "bold": false,
                                    "italic": true,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " that anyone adding a new page also add their page to any relevant indexes \u2014 since, I reckon, we'll need some indexes just to get through the early phase where the wiki will be sparsely interconnected"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " To start, I'm thinking one index of broad categories (or maybe tags, dunno), and then another that's just a list of all pages"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " But if anyone has strong feelings about the right way to do this, I'm at least 75% ears"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U0123H7JRDM",
                    "U85HCL7JP"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1722839433.212069",
        "client_msg_id": "8045ac54-fd2b-444a-9f4c-31c69c629e5d",
        "text": "Throwing in a couple of rough ideas:\n\u2022 If the spirit is simplicity and minimalism, maybe gemtext would be a better option than Markdown? I haven't looked at gemtext closely enough to say if it's that much easier to parse, but maybe someone else here has.\n\u2022 If the spirit is simplicity and minimalism, then \"all the new weird stuff you can do\" with CSS rings an alarm bell. Does this CSS wizardry require the latest and greatest browser from Google or Mozilla,or will the site be usable with older and indie browsers?\n\u2022 Indexes: the only way I see to remove the need for them is a good search engine. But maybe we want a search engine anyway, and then we could perhaps start at that end and see if we still want indexes.\n\u2022 The last two points also raise the question of the preferred mode of interaction with the conversations. Is it a Web interface? Or is the Web interface merely one tool out of many? A search engine could also be a locally-run tool, or a tool running as a separate Web service.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AZQ3K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Throwing in a couple of rough ideas:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "If the spirit is simplicity and minimalism, maybe gemtext would be a better option than Markdown? I haven't looked at gemtext closely enough to say if it's that much easier to parse, but maybe someone else here has."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "If the spirit is simplicity and minimalism, then \"all the new weird stuff you can do\" with CSS rings an alarm bell. Does this CSS wizardry require the latest and greatest browser from Google or Mozilla,or will the site be usable with older and indie browsers?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Indexes: the only way I see to remove the need for them is a good search engine. But maybe we want a search engine anyway, and then we could perhaps start at that end and see if we still want indexes."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The last two points also raise the question of the preferred mode of interaction with the conversations. Is it a Web interface? Or is the Web interface merely one tool out of many? A search engine could also be a locally-run tool, or a tool running as a separate Web service."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1722856842.030409",
        "client_msg_id": "51a0d3bb-8925-4245-b75a-98d816c00038",
        "text": "FWIW I needed a super simple CMS and I discovered you can reference a publicly accessible google sheet with CORS enabled from the FE\n```const sheetId = '1Z7Dja43FepxVOJc5_pMdP0etERM6h0BPAWT74zjdbno';\nconst sheetName = 'Sheet1';\nconst url = `<https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&amp;sheet=${sheetName}>`;\n  \nreturn d3.csv(url)```\nCould you push the build step into a google sheet?\n\ne.g. author write blog post and uploads.\nAuthor views google sheet and adds tags =&gt; various downstream sheets update.\nWebsite viewer goes to page `?tag=foo`\npage fetches sheet for that tag and has a list of articles in a JSON.\n\nYou will still need JS thought to unroll that JSON to renderable content, which may be against a design goal (?). Where is the feature matrix? I have been keen to understand this project more but I have not seen it on the slack yet",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2mA9I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW I needed a super simple CMS and I discovered you can reference a publicly accessible google sheet with CORS enabled from the FE\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "const sheetId = '1Z7Dja43FepxVOJc5_pMdP0etERM6h0BPAWT74zjdbno';\nconst sheetName = 'Sheet1';\nconst url = `"
                            },
                            {
                                "type": "link",
                                "url": "https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${sheetName}"
                            },
                            {
                                "type": "text",
                                "text": "`;\n  \nreturn d3.csv(url)"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Could you push the build step into a google sheet?\n\ne.g. author write blog post and uploads.\nAuthor views google sheet and adds tags => various downstream sheets update.\nWebsite viewer goes to page "
                            },
                            {
                                "type": "text",
                                "text": "?tag=foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\npage fetches sheet for that tag and has a list of articles in a JSON.\n\nYou will still need JS thought to unroll that JSON to renderable content, which may be against a design goal (?). Where is the feature matrix? I have been keen to understand this project more but I have not seen it on the slack yet"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1722856970.936049",
        "client_msg_id": "39a91894-dc5b-428a-bc48-2fc90d63c821",
        "text": "&gt; \u2022 If the spirit is simplicity and minimalism, then \u201call the new weird stuff you can do\u201d with CSS rings an alarm bell. Does this CSS wizardry require the latest and greatest browser from Google or Mozilla,or will the site be usable with older and indie browsers?\nI\u2019d encourage the group not to worry about this too much, at least not until we have evidence that something is broken. CSS, similar to HTML, tends to degrade relatively gracefully, and it is easy to write fallback styles for. If the latest and greatest doesn\u2019t work, something older can step in to clean it up.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4550y",
                "elements": [
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "If the spirit is simplicity and minimalism, then \u201call the new weird stuff you can do\u201d with CSS rings an alarm bell. Does this CSS wizardry require the latest and greatest browser from Google or Mozilla,or will the site be usable with older and indie browsers?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI\u2019d encourage the group not to worry about this too much, at least not until we have evidence that something is broken. CSS, similar to HTML, tends to degrade relatively gracefully, and it is easy to write fallback styles for. If the latest and greatest doesn\u2019t work, something older can step in to clean it up."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            },
            {
                "name": "ivan",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "+1::skin-tone-3",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1722924496.552249",
        "client_msg_id": "1b4d3e38-ace7-4b6e-ac14-931997e82b1d",
        "text": "<@UJBAJNFLK>\n\u2022 Gemtext: doesn't ring a bell, so I'll definitely take a look at it. Thank you for the rec.\n\u2022 CSS: I'm using features like rule nesting and custom properties, which make it faster to iterate on the design. Once the dust has settled, I can spend a few cycles making sure everything degrades gracefully \u2014 this adds bulk and cyclomatic complexity, so it's actually against the spirit of simplicity and minimalism, but it's worth doing to give as many folks as possible a nice experience.\n\u2022 I'm going to say that a search engine that's somehow specific to this wiki is out of scope for now. We could add, say, a search box that just drops the user on duck duck go with a `site:` query, maybe. But especially when the quantity of text on the site is relatively small, search is going to be a bit shot-in-the-dark. Good to think about for down the road, sure.\n\u2022 Yeah! The thing I'm setting up is (A) a git repo with all the wiki entries as either html files or some sort of md-like plain text files, (B) a build script that generates nice static html pages based on the wiki entries, and (C) the means of serving those html pages with nice styling at some official URL. Anyone can clone the repo and do whatever else they want with it. I'd love to see people build alternative tooling around this corpus of wiki entries.\n<@U02E4DAQGSZ>\n\u2022 I don't really want to couple anything to Google (or Amazon, etc). Everything that I've set up so far just assumes much more bog-standard / portable tech, like \"a programming language with regexes\" or \"a web server that can serve html files\". On the initial call where we hashed out this idea, one compelling thought was that by hosting the wiki git repo on GitHub, folks could use their web-based editor to write/edit wiki entries. So we are doing that, but that's just additive, not essential.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9WpqT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Gemtext: doesn't ring a bell, so I'll definitely take a look at it. Thank you for the rec."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "CSS: I'm using features like rule nesting and custom properties, which make it faster to iterate on the design. Once the dust has settled, I can spend a few cycles making sure everything degrades gracefully \u2014 this adds bulk and cyclomatic complexity, so it's actually against the spirit of simplicity and minimalism, but it's worth doing to give as many folks as possible a nice experience."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I'm going to say that a search engine that's somehow specific to this wiki is out of scope for now. We could add, say, a search box that just drops the user on duck duck go with a "
                                    },
                                    {
                                        "type": "text",
                                        "text": "site:",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " query, maybe. But especially when the quantity of text on the site is relatively small, search is going to be a bit shot-in-the-dark. Good to think about for down the road, sure."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Yeah! The thing I'm setting up is (A) a git repo with all the wiki entries as either html files or some sort of md-like plain text files, (B) a build script that generates nice static html pages based on the wiki entries, and (C) the means of serving those html pages with nice styling at some official URL. Anyone can clone the repo and do whatever else they want with it. I'd love to see people build alternative tooling around this corpus of wiki entries."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I don't really want to couple anything to Google (or Amazon, etc). Everything that I've set up so far just assumes much more bog-standard / portable tech, like \"a programming language with regexes\" or \"a web server that can serve html files\". On the initial call where we hashed out this idea, one compelling thought was that by hosting the wiki git repo on GitHub, folks could use their web-based editor to write/edit wiki entries. So we are doing that, but that's just additive, not essential."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02E4DAQGSZ",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1722930831.519519",
        "client_msg_id": "b9557fd8-d1d0-4626-87a9-82a1b6779956",
        "text": "On \"parsing markdown with regex\", I'm sure most will know this famous StackOverflow reply:\n\n<https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454>",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GwvEA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On \"parsing markdown with regex\", I'm sure most will know this famous StackOverflow reply:\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "sweat_smile",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723065586.163539",
        "client_msg_id": "bf744cae-a28a-49e7-983c-236c99c6032b",
        "text": "Gemtext is definitely easier to parse. That was the whole design goal. Evidence: count the number of Gemini clients out there written in less than 200 lines of code.\n\nThe drawback of Gemtext: no inline formatting, no inline links. You can only format at line granularity.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qDF4q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Gemtext is definitely easier to parse. That was the whole design goal. Evidence: count the number of Gemini clients out there written in less than 200 lines of code.\n\nThe drawback of Gemtext: no inline formatting, no inline links. You can only format at line granularity."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723066184.066909",
        "client_msg_id": "60ae5fcb-cc66-41c3-9a7a-bd159de1d453",
        "text": "<@UE6EFEPTQ> \u2014 Yes. A classic.\n<@UCUSW7WVD> (cc <@UJBAJNFLK>) \u2014 Had a look at Gemtext. I really like it! I think it would be trivial (and sensible) to extend this syntax to support inline links and formatting (including code, using a modal processor just like you do for lines). I'm going to give it a shot and see how it goes.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pg3b2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UE6EFEPTQ"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 Yes. A classic.\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " (cc "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": ") \u2014 Had a look at Gemtext. I really like it! I think it would be trivial (and sensible) to extend this syntax to support inline links and formatting (including code, using a modal processor just like you do for lines). I'm going to give it a shot and see how it goes."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "astonished",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723066468.541039",
        "client_msg_id": "48de9d31-1510-4bf5-b436-733048c85263",
        "text": "Astonished?\n\nIt's simple, you just implement an FSM, and split the incoming character stream on any syntactically-relevant character, then backtrack if you hit a node in the FSM with no outbound edges.\n\n<https://www.urbandictionary.com/define.php?term=%2FS|/s>",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "46srZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Astonished?\n\nIt's simple, you just implement an FSM, and split the incoming character stream on any syntactically-relevant character, then backtrack if you hit a node in the FSM with no outbound edges.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.urbandictionary.com/define.php?term=%2FS",
                                "text": "/s"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U71PMQ1V0",
        "type": "message",
        "ts": "1723068340.322439",
        "client_msg_id": "614fc32f-a12a-42e1-b5dd-cae9ee26ddd5",
        "text": "I suspect markdown would also be really easy to parse if you refuse to implement all the stupid edge cases eg if someone writes `am _I bold* or_ italic*` just replace it with an error message.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6VuUi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I suspect markdown would also be really easy to parse if you refuse to implement all the stupid edge cases eg if someone writes "
                            },
                            {
                                "type": "text",
                                "text": "am _I bold* or_ italic*",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " just replace it with an error message."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723068402.282409",
        "client_msg_id": "AE78719C-232A-4D90-AC25-FC402CCDFA2C",
        "text": "Shhhh you're spoiling my \"actually I will implement a superset of gemtext\" gambit to ship decent md ;)",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N6z4t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Shhhh you're spoiling my \"actually I will implement a superset of gemtext\" gambit to ship decent md ;)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "saluting_face",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U71PMQ1V0",
        "type": "message",
        "ts": "1723068761.184629",
        "client_msg_id": "34b1297d-5f56-411b-8f3e-343d7bc70436",
        "text": "&gt; Astonished?\nParsing is one of those funny things where the existence of lots of interesting theory and papers creates the impression that you need complicated tools, whereas in practice almost every industrial parser I've ever seen is just hand-written recursive descent because that is by far the easiest option.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QUmTM",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Astonished?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nParsing is one of those funny things where the existence of lots of interesting theory and papers creates the impression that you need complicated tools, whereas in practice almost every industrial parser I've ever seen is just hand-written recursive descent because that is by far the easiest option."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723069148.595929",
        "client_msg_id": "48bd569d-4899-4559-b0b2-3fab5eae3f92",
        "text": "Yeah. Alex Warth (known for OhmJS among other things) has been teaching a little \"prototyping programming languages\" course internally at I&amp;S. One of the major themes is just that \u2014 unless you're actually building an industrial-scale compiler, most of the standard advice given about writing compilers is bunk. Just do something quick and dirty and direct and manual. It's fine. It's _plenty_ fast, and robust.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oNUe9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah. Alex Warth (known for OhmJS among other things) has been teaching a little \"prototyping programming languages\" course internally at I&S. One of the major themes is just that \u2014 unless you're actually building an industrial-scale compiler, most of the standard advice given about writing compilers is bunk. Just do something quick and dirty and direct and manual. It's fine. It's "
                            },
                            {
                                "type": "text",
                                "text": "plenty",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " fast, and robust."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723069260.843259",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1723069323.000000"
        },
        "client_msg_id": "7e4cd883-8700-4825-810b-69fe74274b22",
        "text": "So it's funny to hear that even for the industrial stuff, most of the sophisticated theory doesn't apply.\n\nI guess the one place that stuff is actually useful is when writing\u2026 textbooks about compilers.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7y4Lv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So it's funny to hear that even for the industrial stuff, most of the sophisticated theory doesn't apply.\n\nI guess the one place that stuff is actually useful is when writing\u2026 textbooks about compilers."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723078840.806409",
        "client_msg_id": "dc3ac2dd-9858-4581-b64e-0147a000da1c",
        "text": "My astonishment is about getting into notation design, not parsing. What could possibly go wrong :smile:",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LK+eV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My astonishment is about getting into notation design, not parsing. What could possibly go wrong "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723078921.457019",
        "client_msg_id": "109c37fc-02c6-45ac-979d-ea1013625a1b",
        "text": "I will be counting the days until people start complaining about the notation or asking for features.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AqoVM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I will be counting the days until people start complaining about the notation or asking for features."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1723080410.845889",
        "client_msg_id": "488CCCB1-D0AE-43DB-A498-BA5937C1BCC2",
        "text": "<https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1722442852630609|-7> ",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9tCNM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1722442852630609",
                                "text": "-7"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723081015.810969",
        "client_msg_id": "4fd51a84-27b6-4422-beda-1598a7ed252a",
        "text": "Exactly. And that was just about how to _implement_ a notation.\n\nIt's fine. If I'm worried about bikeshedding I shouldn't add to it :smile: :homer-backing-away:",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1FQLK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Exactly. And that was just about how to "
                            },
                            {
                                "type": "text",
                                "text": "implement ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "a notation.\n\nIt's fine. If I'm worried about bikeshedding I shouldn't add to it "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": " :homer-backing-away:"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723081327.363749",
        "client_msg_id": "e61aa9a8-dd7c-4192-981a-3082786a114a",
        "text": "Y'all just got me to de-emoji myself by clubbing me with the unwashed masses who haven't written a recursive descent parser or three :sweat_smile:\n\n(Parsing has its depths. It's hard to make sure all possible illegal statements behave well and raise errors. Favorite target of fuzzers! Probably less important in a safe language, but be prepared for the odd DoS vulnerability caused by an infinite loop in a year or 3.)",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XJj3W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Y'all just got me to de-emoji myself by clubbing me with the unwashed masses who haven't written a recursive descent parser or three "
                            },
                            {
                                "type": "emoji",
                                "name": "sweat_smile",
                                "unicode": "1f605"
                            },
                            {
                                "type": "text",
                                "text": "\n\n(Parsing has its depths. It's hard to make sure all possible illegal statements behave well and raise errors. Favorite target of fuzzers! Probably less important in a safe language, but be prepared for the odd DoS vulnerability caused by an infinite loop in a year or 3.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "clubs",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            },
            {
                "name": "smile",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1723083924.530079",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1723084366.000000"
        },
        "client_msg_id": "f818fda1-c568-4120-9dc1-d9bf43a55b9f",
        "text": "Going back, this is a good suggestion:\n\n> I suspect markdown would also be really easy to parse if you refuse to implement all the stupid edge cases eg if someone writes `am _I bold* or_ italic*` just replace it with an error message.\nThe key is doing it without eating people's comments. May be safer to just leave the whole message unformatted.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X8Nf3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Going back, this is a good suggestion:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I suspect markdown would also be really easy to parse if you refuse to implement all the stupid edge cases eg if someone writes "
                            },
                            {
                                "type": "text",
                                "text": "am _I bold* or_ italic*",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " just replace it with an error message."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe key is doing it without eating people's comments. May be safer to just leave the whole message unformatted."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1723086751.928109",
        "client_msg_id": "7576f37d-633f-401d-a51c-94bff6414746",
        "text": "Drive-by comments and observations...\n1. A major cause of difficulty in parsing is: ASCII. ASCII provides so few characters that we are inclined to overload their meaning. For example \u201cbegin string\u201d and \u201cend string\u201d are both represented by the same quote characters in traditional programming languages. Parentheses can bracket expressions or invoke functions or define arg lists in function definitions. Unicode, though, has tons of characters, hence I, for one, have no compunction about choosing a single, non-overloaded meaning for specific characters, and, I have no compunction about choosing left and right bracketing characters for each different kind of bracketing that I feel is needed. The concept of nested comments seemed revolutionary in the past, but, would be natural using non-overloaded characters. Likewise, nested strings become easy to imagine. (Note that the Unix program \u201cM4\u201d does define different begin and end quote characters for some of its strings).\n2. Recursive descent + backtracking = PEG. Recursive descent does better than CFG and REGEX for practical parsing, with the exception that you have to manually pre-refactor the grammar to fold together all common prefixes (left hand side of phrases). PEG adds the nuance that it can try to parse a phrase, and, if the attempt fails, PEG backs up and retries some other parse branch. With backtracking, manual common prefix refactoring is no longer necessary (the machine does it for you). Backtracking was well-known early on, but, frowned upon by those with 1950s biases. Early\u2019s parser and PROLOG were side-stepped for \u201cmore efficient\u201d, gotcha-full approaches. Backtracking ain\u2019t all that hard if you ignore your inner 1950s biases. [I even have a JS backtracker (a Prolog) lying around, only lightly tested, on my repo somewhere, generated by my first use of OhmJS. I transpiled Nils Holm\u2019s Scheme program to JS. If I can do it, anyone can.]. \n",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lGz5F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Drive-by comments and observations...\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A major cause of difficulty in parsing is: ASCII. ASCII provides so few characters that we are inclined to overload their meaning. For example \u201cbegin string\u201d and \u201cend string\u201d are both represented by the same quote characters in traditional programming languages. Parentheses can bracket expressions or invoke functions or define arg lists in function definitions. Unicode, though, has tons of characters, hence I, for one, have no compunction about choosing a single, non-overloaded meaning for specific characters, and, I have no compunction about choosing left and right bracketing characters for each different kind of bracketing that I feel is needed. The concept of nested comments seemed revolutionary in the past, but, would be natural using non-overloaded characters. Likewise, nested strings become easy to imagine. (Note that the Unix program \u201cM4\u201d does define different begin and end quote characters for some of its strings)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Recursive descent + backtracking = PEG. Recursive descent does better than CFG and REGEX for practical parsing, with the exception that you have to manually pre-refactor the grammar to fold together all common prefixes (left hand side of phrases). PEG adds the nuance that it can try to parse a phrase, and, if the attempt fails, PEG backs up and retries some other parse branch. With backtracking, manual common prefix refactoring is no longer necessary (the machine does it for you). Backtracking was well-known early on, but, frowned upon by those with 1950s biases. Early\u2019s parser and PROLOG were side-stepped for \u201cmore efficient\u201d, gotcha-full approaches. Backtracking ain\u2019t all that hard if you ignore your inner 1950s biases. [I even have a JS backtracker (a Prolog) lying around, only lightly tested, on my repo somewhere, generated by my first use of OhmJS. I transpiled Nils Holm\u2019s Scheme program to JS. If I can do it, anyone can.]. "
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1723103367.639429",
        "client_msg_id": "00e6ed6f-496f-412e-8512-ad0da1a18bbb",
        "text": "I like the idea of building on gemtext. I see a simple specification as a necessary foundation for simple implementations. So: make it as simple as you can. If gemtext goes too far, then add what's missing to gemtext.\n\nThere is, of course, the risk of \"oh, it's our own notation, so we can do all these wonderful things with it\". Followed by extensive bikeshedding sessions. Here's an idea for dealing with it: (1) Whoever proposes a modification to the notation has to supply working code that implements the change. We won't even discuss unimplemented ideas. (2) We'll set a limit to allowed code size. Something like \"no more than 1.2 times the size of Ivan's first working version, for at least one year\".",
        "team": "T5TCAFTA9",
        "thread_ts": "1722836207.656899",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XqKPs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like the idea of building on gemtext. I see a simple specification as a necessary foundation for simple implementations. So: make it as simple as you can. If gemtext goes too far, then add what's missing to gemtext.\n\nThere is, of course, the risk of \"oh, it's our own notation, so we can do all these wonderful things with it\". Followed by extensive bikeshedding sessions. Here's an idea for dealing with it: (1) Whoever proposes a modification to the notation has to supply working code that implements the change. We won't even discuss unimplemented ideas. (2) We'll set a limit to allowed code size. Something like \"no more than 1.2 times the size of Ivan's first working version, for at least one year\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGWUJUZHT",
                    "UC2A2ARPT"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]