[
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724157392.101319",
        "client_msg_id": "0ab5dd4c-2ec1-48c5-8267-877b8554866d",
        "text": "After lots of reading (books and other people's code), watching video's, thinking, asking chatgpt for help (it needed help itself), experimenting and frustration, I finally managed to get a neural network working including the training using backward propagation, in my visual programming system!! You can see a small video where I demo it here: <https://youtu.be/xOKzC77NgRU>\n\nThe results are far from perfect and neither is the visual flow itself. Currently I only used a subset of mnist to train (9000 images) and on every training iteration the weights are updated per training image. Also the network can for sure be improvement by using a different layer setup and configuration parameters (different learning rate and activation / cost functions). From a visual programming perspective there are also lots of things to improve: currently a lot of the needed functionality is inside the nodes instead of being visible in the flow. So the neural and training nodes are black boxes as well as the node that loads the mnist dataset and handles some of the logic in the training proces. I want to change this in the near future though. You currently can't even see the resulting weights and biases.\n\nHopefully it is clear from the neural node types how the neural network is structured: it shows the number of nodes in the layer and an icon illustrating whether a node represents an input, hidden or output layer.\n\nIn the video I show a slow and fast run of the training proces: by putting the speed slider to the right you can run the flow without animations otherwise it takes too long.\n\nThere's also a custom node type that can be used to draw a digit manually and provide the digit which the drawing represents for purpose of calculating the error cost/loss.\n\nAnyway, for now I am happy with the result. More to follow in the future :-)",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "reply_count": 12,
        "reply_users_count": 2,
        "latest_reply": "1724237665.962249",
        "reply_users": [
            "UGWUJUZHT",
            "U0123H7JRDM"
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "from_url": "https://youtu.be/xOKzC77NgRU",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/xOKzC77NgRU/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/xOKzC77NgRU?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"Neural network training using mnist dataset in code-flow-canvas\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https://youtu.be/xOKzC77NgRU",
                "fallback": "YouTube Video: Neural network training using mnist dataset in code-flow-canvas",
                "title": "Neural network training using mnist dataset in code-flow-canvas",
                "title_link": "https://youtu.be/xOKzC77NgRU",
                "author_name": "Maikel van de Lisdonk",
                "author_link": "https://www.youtube.com/@maikelvandelisdonk7024",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "REQDf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "After lots of reading (books and other people's code), watching video's, thinking, asking chatgpt for help (it needed help itself), experimenting and frustration, I finally managed to get a neural network working including the training using backward propagation, in my visual programming system!! You can see a small video where I demo it here: "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/xOKzC77NgRU"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThe results are far from perfect and neither is the visual flow itself. Currently I only used a subset of mnist to train (9000 images) and on every training iteration the weights are updated per training image. Also the network can for sure be improvement by using a different layer setup and configuration parameters (different learning rate and activation / cost functions). From a visual programming perspective there are also lots of things to improve: currently a lot of the needed functionality is inside the nodes instead of being visible in the flow. So the neural and training nodes are black boxes as well as the node that loads the mnist dataset and handles some of the logic in the training proces. I want to change this in the near future though. You currently can't even see the resulting weights and biases.\n\nHopefully it is clear from the neural node types how the neural network is structured: it shows the number of nodes in the layer and an icon illustrating whether a node represents an input, hidden or output layer.\n\nIn the video I show a slow and fast run of the training proces: by putting the speed slider to the right you can run the flow without animations otherwise it takes too long.\n\nThere's also a custom node type that can be used to draw a digit manually and provide the digit which the drawing represents for purpose of calculating the error cost/loss.\n\nAnyway, for now I am happy with the result. More to follow in the future :-)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UFEQUBNNT",
                    "U06SS0DHZD1"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "U06JCQL6ERJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724185891.935759",
        "client_msg_id": "9615479e-345f-484c-84b8-ff796855f327",
        "text": "At about 00:25 I see feedback and fan-out (to the gray boxes on the right plus to the feedback loop). Can you comment about that? For example, is there some sort of queuing and propagation delay going on?",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+dAhl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At about 00:25 I see feedback and fan-out (to the gray boxes on the right plus to the feedback loop). Can you comment about that? For example, is there some sort of queuing and propagation delay going on?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724186789.056469",
        "client_msg_id": "08570A86-C5BA-4F1D-98B5-1801B39426A4",
        "text": "There's no queuing but when a node triggers multiple nodes, these run in parallel independently of each other",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0EzXw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's no queuing but when a node triggers multiple nodes, these run in parallel independently of each other"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724187127.684959",
        "client_msg_id": "a490bbbd-c25b-42ec-80fe-79c2968a967e",
        "text": "How is \"run in parallel\" implemented? Do you spawn several threads (using a thread library, for example)? For fan-out, do you make copies of the data for each target node?",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9BlpQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How is \"run in parallel\" implemented? Do you spawn several threads (using a thread library, for example)? For fan-out, do you make copies of the data for each target node?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724220287.964339",
        "client_msg_id": "53DB276B-6A8D-4AC6-9F88-96B105E8A66D",
        "text": "Yeah sorry, I should have said \"parallel\". Because of the animation system it only appears that the nodes runs in parallel. The nodes are normal functions that can either run in sync or async when it returns a promise to the flow-engine. When the animation system is disables (by putting the speed slider in the top left at max) , the flow runs normally and nodes have to wait on each other. I probably could use a pool of web workers to improve this",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VGVWY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah sorry, I should have said \"parallel\". Because of the animation system it only appears that the nodes runs in parallel. The nodes are normal functions that can either run in sync or async when it returns a promise to the flow-engine. When the animation system is disables (by putting the speed slider in the top left at max) , the flow runs normally and nodes have to wait on each other. I probably could use a pool of web workers to improve this"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724223008.953699",
        "client_msg_id": "5DB9E30D-B7E1-494C-A420-68F8464987F5",
        "text": "Input send to each node is currently not copied/cloned. The input data is in most cases just a simple string but can be an object or array. And depending on the exact implementation of a node, the input data is passed through or not. In the passed I've build a different system which cloned the input payload to a node and a node could add or change data of that payload and it was passed on. But it was quite heavy on memory. That's why I am trying a different approach in this implementation",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f8leX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Input send to each node is currently not copied/cloned. The input data is in most cases just a simple string but can be an object or array. And depending on the exact implementation of a node, the input data is passed through or not. In the passed I've build a different system which cloned the input payload to a node and a node could add or change data of that payload and it was passed on. But it was quite heavy on memory. That's why I am trying a different approach in this implementation"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724236136.426989",
        "client_msg_id": "d737fed6-abc3-4f51-9241-54278d428e8e",
        "text": "over on the FBP slack (Flow-Based Programming) someone suggested using copy-on-write instead of copy ; this suggestion lingers in my mind but I haven't tried it yet ; aside: in general I've just stopped worrying about \"efficiency\", machines are so fast today that I don't need to care about implementation details, knowing that whatever I do can be production-engineered later to be a bit faster, \"getting it right\" is my foremost concern",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qusvu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "over on the FBP slack (Flow-Based Programming) someone suggested using copy-on-write instead of copy ; this suggestion lingers in my mind but I haven't tried it yet ; aside: in general I've just stopped worrying about \"efficiency\", machines are so fast today that I don't need to care about implementation details, knowing that whatever I do can be production-engineered later to be a bit faster, \"getting it right\" is my foremost concern"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724236586.093899",
        "client_msg_id": "f16a1ad9-f28c-4d92-afe1-8685ee0ad02f",
        "text": "I'm thinking on \"... either run in sync or async when it returns a promise to the flow-engine. ...\". From my perspective, the goal is to reach into a bowl full of Arduinos and put the code for each rectangle on the diagram onto its own Arduino. It's not clear (by this I mean: I don't know) whether a promise-based approach is realistic ... pondering ... I'd be interested in your thoughts ...",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EaDjY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm thinking on \"... either run in sync or async when it returns a promise to the flow-engine. ...\". From my perspective, the goal is to reach into a bowl full of Arduinos and put the code for each rectangle on the diagram onto its own Arduino. It's not clear (by this I mean: I don't know) whether a promise-based approach is realistic ... pondering ... I'd be interested in your thoughts ..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724236958.707729",
        "client_msg_id": "996D3B85-FD10-4228-BD02-9A53DD02473A",
        "text": "My first thought is that in that scenario you always want to return a promise because you're (probably) dealing with hardware communication and want to return from the node when the needed communication is done. In my scenario I used it when a node needs to do fetches for example (the node that initiates the training in the neural network example fetches the mnist dataset).",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "srJDZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My first thought is that in that scenario you always want to return a promise because you're (probably) dealing with hardware communication and want to return from the node when the needed communication is done. In my scenario I used it when a node needs to do fetches for example (the node that initiates the training in the neural network example fetches the mnist dataset)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724237028.099499",
        "client_msg_id": "1cceb4e1-5f57-491d-a47a-e0a216069e30",
        "text": "... how do you send a promise across a thin wire from one node to another? ...",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kEGMw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... how do you send a promise across a thin wire from one node to another? ..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724237130.514899",
        "client_msg_id": "B3EC230F-C7B8-44E2-B413-DBAED3F2551F",
        "text": "I meant the internal code implementation of the node. The information that is send over the wire should be serializable to json (in my case at least)",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aa6OZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I meant the internal code implementation of the node. The information that is send over the wire should be serializable to json (in my case at least)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1724237438.335859",
        "client_msg_id": "12f5793b-c67d-4812-8698-1770492dfb93",
        "text": "Have you thought about what the information sent across a wire needs to be? (I don't mean to derail you, if you haven't thought about it, then there is no need to spend lots of time trying to answer)",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WKmhn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Have you thought about what the information sent across a wire needs to be? (I don't mean to derail you, if you haven't thought about it, then there is no need to spend lots of time trying to answer)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1724237665.962249",
        "client_msg_id": "31E3288E-04BD-452F-9FA0-0D8734D73559",
        "text": "Currently it varies per node/node port, and I can specify some constraints so that only node-ports that can receive that data can connect to each other. That implementation is still limited and I want to expand on it further in the future",
        "team": "T5TCAFTA9",
        "thread_ts": "1724157392.101319",
        "parent_user_id": "U0123H7JRDM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uze6g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Currently it varies per node/node port, and I can specify some constraints so that only node-ports that can receive that data can connect to each other. That implementation is still limited and I want to expand on it further in the future"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]