[
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727827197.316359",
        "edited": {
            "user": "UDCLA1HU4",
            "ts": "1727827233.000000"
        },
        "client_msg_id": "6ca4f7f0-7651-4d1e-944f-43efc4e0c11f",
        "text": "This is a very random thought - but something that I've been occasionally wondering for some time now. If we have lambda calculus as a model of functional languages and Turing machines as a model of imperative languages, what would be a good model for programming systems that have \"document\" as the basic underlying structure (Subtext is an example of this) - i.e., you have some tree structure and the program evaluates by modifying this document - appending new things or rewriting evaluated bits. (Lambda calculus itself is basically a tree, but what if this also allows imperative document edits?)\n\nCould this be something like a \"Turing machine\" that works on trees rather than tapes? There would be \"current location\" which can move in various ways around the tree and modify it. If your document has references (perhaps you can have `../../foo` to refer to `foo` of a parent of a parent), the machine would have to somehow walk up the tree, remembering that it wants to copy a value back to the original location - and then walk over the tree back to put the value in place of the reference).\n\nIs this something completely silly or something that lots of people have already done but under different names?",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "reply_count": 18,
        "reply_users_count": 8,
        "latest_reply": "1728223573.895489",
        "reply_users": [
            "UK3LH8CF5",
            "UJBAJNFLK",
            "U013ZLJARC7",
            "UE6EFEPTQ",
            "UCUSW7WVD",
            "UDCLA1HU4",
            "UFPRPSA4S",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uPL3E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a very random thought - but something that I've been occasionally wondering for some time now. If we have lambda calculus as a model of functional languages and Turing machines as a model of imperative languages, what would be a good model for programming systems that have \"document\" as the basic underlying structure (Subtext is an example of this) - i.e., you have some tree structure and the program evaluates by modifying this document - appending new things or rewriting evaluated bits. (Lambda calculus itself is basically a tree, but what if this also allows imperative document edits?)\n\nCould this be something like a \"Turing machine\" that works on trees rather than tapes? There would be \"current location\" which can move in various ways around the tree and modify it. If your document has references (perhaps you can have "
                            },
                            {
                                "type": "text",
                                "text": "../../foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to refer to "
                            },
                            {
                                "type": "text",
                                "text": "foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of a parent of a parent), the machine would have to somehow walk up the tree, remembering that it wants to copy a value back to the original location - and then walk over the tree back to put the value in place of the reference).\n\nIs this something completely silly or something that lots of people have already done but under different names?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "U014WA16VNJ",
                    "UFPRPSA4S",
                    "UML4ZEKDK"
                ],
                "count": 5
            },
            {
                "name": "thinking_face",
                "users": [
                    "U01DWJSAF2B"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1727839827.395039",
        "client_msg_id": "6F57AAF3-08C1-4FFF-B62D-4EF67138FD6E",
        "text": "I might be missing some nuance here. But what you are describing sounds to me pretty similar to term or graph rewriting systems. <https://en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems|https://en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems> They are Turing complete formalism. And there has been plenty of working using them for transforming documents, but also general evaluation. They do work exactly as you described. You have a tree structure and you modify it by rewriting things. ",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ahmbb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I might be missing some nuance here. But what you are describing sounds to me pretty similar to term or graph rewriting systems. "
                            },
                            {
                                "type": "link",
                                "url": "https://en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems",
                                "text": "https://en.m.wikipedia.org/wiki/Rewriting#Term_rewriting_systems"
                            },
                            {
                                "type": "text",
                                "text": " They are Turing complete formalism"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " And there has been plenty of working using them for transforming documents"
                            },
                            {
                                "type": "text",
                                "text": ","
                            },
                            {
                                "type": "text",
                                "text": " but also general evaluation"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " They do work exactly as you described"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " You have a tree structure and you modify it by rewriting things"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727847147.660189",
        "client_msg_id": "e9d777e2-3bc1-469e-9c1e-cef0c89874ea",
        "text": "Supporting <@UK3LH8CF5>'s suggestion because that's exactly how my <https://leibniz.khinsen.net/|Digital Scientific Notation> works. It's a term rewriting system embedded in a Wiki-like graph of cross-linked pages.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AIA9/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Supporting "
                            },
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": "'s suggestion because that's exactly how my "
                            },
                            {
                                "type": "link",
                                "url": "https://leibniz.khinsen.net/",
                                "text": "Digital Scientific Notation"
                            },
                            {
                                "type": "text",
                                "text": " works. It's a term rewriting system embedded in a Wiki-like graph of cross-linked pages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1727849045.817219",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1727885193.000000"
        },
        "client_msg_id": "5B6B9236-33D1-4C38-9839-3E18801BFFEF",
        "text": "Note also that Lisp was originally conceived of as an automated form of term rewriting, the keyword \u201clambda\u201d having been borrowed based on an incomplete understanding of Church\u2019s paper. The first Lisp that was actually based on the lambda calculus was scheme.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X4nHZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Note also that Lisp was originally conceived"
                            },
                            {
                                "type": "text",
                                "text": " of"
                            },
                            {
                                "type": "text",
                                "text": " as an automated form of term rewriting, the keyword \u201clambda\u201d having been borrowed based on an incomplete understanding of Church\u2019s paper. The first Lisp that was actually based on the lambda calculus was scheme."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "ok_hand",
                "users": [
                    "UJFN50C00",
                    "U014WA16VNJ"
                ],
                "count": 2
            },
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1727857436.296279",
        "client_msg_id": "0c24f806-5ec3-44a9-85e1-ec5e7bf667df",
        "text": "you're getting some \"already done under different names\", so I'll add mine! my PL is really just a graph rewriter.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lh334",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you're getting some \"already done under different names\", so I'll add mine! my PL is really just a graph rewriter."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1727879746.740669",
        "client_msg_id": "bd49037a-90b9-4e61-9bfa-bc767a3bf983",
        "text": "<@UFPRPSA4S>'s <https://futureofcoding.slack.com/archives/C5U3SEW6A/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A|recent idea> seems tantalizingly related, but breaks my brain to think about..",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "attachments": [
            {
                "from_url": "https://futureofcoding.slack.com/archives/C5U3SEW6A/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A",
                "ts": "1727247298.811129",
                "author_id": "UFPRPSA4S",
                "channel_id": "C5U3SEW6A",
                "channel_team": "T5TCAFTA9",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "C5U3SEW6A",
                        "ts": "1727247298.811129",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "sO9yD",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that."
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "files": [
                    {
                        "id": "F07NH9CRN31",
                        "created": 1727247255,
                        "timestamp": 1727247255,
                        "name": "unnamed.png",
                        "title": "unnamed.png",
                        "mimetype": "image/png",
                        "filetype": "png",
                        "pretty_type": "PNG",
                        "user": "UFPRPSA4S",
                        "user_team": "T5TCAFTA9",
                        "editable": false,
                        "size": 16669,
                        "mode": "hosted",
                        "is_external": false,
                        "external_type": "",
                        "is_public": true,
                        "public_url_shared": false,
                        "display_as_bot": false,
                        "username": "",
                        "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F07NH9CRN31/unnamed.png",
                        "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F07NH9CRN31/download/unnamed.png",
                        "media_display_type": "unknown",
                        "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_64.png",
                        "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_80.png",
                        "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_360.png",
                        "thumb_360_w": 360,
                        "thumb_360_h": 291,
                        "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_480.png",
                        "thumb_480_w": 480,
                        "thumb_480_h": 388,
                        "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_160.png",
                        "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_720.png",
                        "thumb_720_w": 720,
                        "thumb_720_h": 582,
                        "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_800.png",
                        "thumb_800_w": 800,
                        "thumb_800_h": 646,
                        "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_960.png",
                        "thumb_960_w": 960,
                        "thumb_960_h": 776,
                        "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F07NH9CRN31-ff3be74698/unnamed_1024.png",
                        "thumb_1024_w": 1024,
                        "thumb_1024_h": 828,
                        "original_w": 1084,
                        "original_h": 876,
                        "thumb_tiny": "AwAmADDTPSkGSO1B6GlHSgBOfajnOOKWkYEkY4oAT5s44p1FFAAeRQOgopq7SAO+KAHUUirgDpmloAKKKKACkAwPWlooAKKKKACiiigD/9k=",
                        "permalink": "https://futureofcoding.slack.com/files/UFPRPSA4S/F07NH9CRN31/unnamed.png",
                        "permalink_public": "https://slack-files.com/T5TCAFTA9-F07NH9CRN31-f5f24c4c5a",
                        "comments_count": 0,
                        "is_starred": false,
                        "has_rich_preview": false,
                        "file_access": "visible"
                    }
                ],
                "id": 1,
                "original_url": "https://futureofcoding.slack.com/archives/C5U3SEW6A/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A",
                "fallback": "[September 24th, 2024 11:54 PM] robinps2: Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that.",
                "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that.",
                "author_name": "Robin Allison",
                "author_link": "https://futureofcoding.slack.com/team/UFPRPSA4S",
                "author_icon": "https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-48.png",
                "author_subname": "Robin Allison",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in Slack Conversation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jEyro",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFPRPSA4S"
                            },
                            {
                                "type": "text",
                                "text": "'s "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C5U3SEW6A/p1727247298811129?thread_ts=1727247298.811129&cid=C5U3SEW6A",
                                "text": "recent idea"
                            },
                            {
                                "type": "text",
                                "text": " seems tantalizingly related, but breaks my brain to think about.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727906391.078199",
        "edited": {
            "user": "UDCLA1HU4",
            "ts": "1727906403.000000"
        },
        "client_msg_id": "de611ea5-6ead-4aa2-a4ba-3bd5ca330e41",
        "text": "Term rewriting is a nice reference I did not think of! I guess one difference between those and what I've been thinking about is that I imagined that you'd have a special \"current\" location in the tree (like instruction pointer...).\n\nYou can certainly do this with term rewriting systems too though, if you just have a special term like `[X]`  that marks the term/tree node `X`  as being the current one.\n\nI guess term rewriting systems are basically how people define operational semantics of programming languages. It's strange people do not talk more about the connection between the two!",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GHzMb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Term rewriting is a nice reference I did not think of! I guess one difference between those and what I've been thinking about is that I imagined that you'd have a special \"current\" location in the tree (like instruction pointer...).\n\nYou can certainly do this with term rewriting systems too though, if you just have a special term like "
                            },
                            {
                                "type": "text",
                                "text": "[X]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  that marks the term/tree node "
                            },
                            {
                                "type": "text",
                                "text": "X",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  as being the current one.\n\nI guess term rewriting systems are basically how people define operational semantics of programming languages. It's strange people do not talk more about the connection between the two!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727906657.735399",
        "client_msg_id": "a2560fe1-2f73-4886-8c25-7d3e5cc17487",
        "text": "<@UFPRPSA4S>'s idea reminded me of something I wrote about in a post inspired by spaces in cities (see <https://tomasp.net/blog/2023/vague-spaces/>) There are some thoughts about how programs live in a different kind of space than cities (which have fixed space they have to fit into, whereas program spaces can expand - but spreadsheet space expands in only limited ways - you cannot create arbitrary amount of space in any particular location - which I guess this idea was getting at?).",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8+cos",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFPRPSA4S"
                            },
                            {
                                "type": "text",
                                "text": "'s idea reminded me of something I wrote about in a post inspired by spaces in cities (see "
                            },
                            {
                                "type": "link",
                                "url": "https://tomasp.net/blog/2023/vague-spaces/"
                            },
                            {
                                "type": "text",
                                "text": ") There are some thoughts about how programs live in a different kind of space than cities (which have fixed space they have to fit into, whereas program spaces can expand - but spreadsheet space expands in only limited ways - you cannot create arbitrary amount of space in any particular location - which I guess this idea was getting at?)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727907073.490539",
        "client_msg_id": "8fdedadf-de7b-4aa2-802e-719695e3c23b",
        "text": "... but using some kind of term rewriting system as the basis for document-like programming systems seems like a nice way of doing things - and it looks like there's lots of (some, at least) people here thinking in this direction!",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ULavb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... but using some kind of term rewriting system as the basis for document-like programming systems seems like a nice way of doing things - and it looks like there's lots of (some, at least) people here thinking in this direction!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727936087.586529",
        "client_msg_id": "45159eb5-501b-42af-8321-330d64825b03",
        "text": "Maybe term rewriting systems _should_ have something like a \"current node\". Rule application order is something usually swept under the rug. It's there, but everybody hopes it doesn't matter, and it's usually implicit (part of the rewriting engine) rather than explicit (part of the rule set).",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dDFbc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe term rewriting systems "
                            },
                            {
                                "type": "text",
                                "text": "should",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have something like a \"current node\". Rule application order is something usually swept under the rug. It's there, but everybody hopes it doesn't matter, and it's usually implicit (part of the rewriting engine) rather than explicit (part of the rule set)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFPRPSA4S",
        "type": "message",
        "ts": "1727936520.898839",
        "client_msg_id": "6eb9b506-6dbb-49f0-95d6-72874b039f98",
        "text": "<@UCUSW7WVD> I think there might be a connection here too. I don\u2019t know if I can speak to document-based languages in general, but at least for subtext, there is the loose connection in that both are based on spreadsheets. Beyond that non-abelian spreadsheets serve as mathematical models, although they aren\u2019t models of computation specifically. They actually take computation mostly for granted, although I think that can be an interesting perspective too. When I was first reading Tomas\u2019 question it occurred to me that non-abelian spreadsheets could be thought of as a model of the \u2018document\u2019 part of \u2018document-based programs\u2019.\n\n<@UDCLA1HU4> Part of the point is absolutely that the space these things is is fixed, has particular characteristics, and is not created arbitrarily. I\u2019m not sure if this makes them less like regular programs though. Generally the space of a non-abelian spreadsheet is far more expansive than the two dimensional space of a spreadsheet or paper or city. For one the \u201ctwo dimensional\u201d non-abelian spreadsheet has uncountably many cells, whereas a normal spreadsheet has countably many cells. And this only gets worse in the countably infinite dimensional case you need to account for syntax trees.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kfKJk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I think there might be a connection here too. I don\u2019t know if I can speak to document-based languages in general, but at least for subtext, there is the loose connection in that both are based on spreadsheets. Beyond that non-abelian spreadsheets serve as mathematical models, although they aren\u2019t models of computation specifically. They actually take computation mostly for granted, although I think that can be an interesting perspective too. When I was first reading Tomas\u2019 question it occurred to me that non-abelian spreadsheets could be thought of as a model of the \u2018document\u2019 part of \u2018document-based programs\u2019.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UDCLA1HU4"
                            },
                            {
                                "type": "text",
                                "text": " Part of the point is absolutely that the space these things is is fixed, has particular characteristics, and is not created arbitrarily. I\u2019m not sure if this makes them less like regular programs though. Generally the space of a non-abelian spreadsheet is far more expansive than the two dimensional space of a spreadsheet or paper or city. For one the \u201ctwo dimensional\u201d non-abelian spreadsheet has uncountably many cells, whereas a normal spreadsheet has countably many cells. And this only gets worse in the countably infinite dimensional case you need to account for syntax trees."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1727954487.856939",
        "client_msg_id": "3f7ad5c6-8673-41d7-b246-81c7477306a4",
        "text": "<@UDCLA1HU4>\n1) WRT to \"current node\", we already know how to do this using textual code and have many programming languages for this purpose. So, divide-and-conquer says that all you need to do is to map \"trees\" onto textual code, then you're done.\n\n2) Here is my (probably over-simplified) understanding of term rewriting augmented by the concept of \"current node\":\n\n1. Programmer writes an AST (the \"inhaler AST\")\n2. Programmer writes a 1:1 corresponding rewrite AST that dove-tails with the inhaler AST. (Or, programmer annotates the above inhaler AST (this, though, violates the principles of KISS and human-readability))\n3. Term rewriter app inhales linear text and makes a CST (concrete parse tree) by culling the AST driven by the inhaled text (commonly known as \"parsing\")\n4. Term rewriter app walks the rewrite AST using the newly-created CST.\n5. Term rewriter app unparses the rewritten walked-tree into (new) linear text (\"code\").\n6. Run the generated code.\nIf that's even close to what you're imagining, then I contend that this is \"easily possible\" to do using modern technology whilst loosening the thumbscrews, i.e. using OhmJS plus a nano-DSL written in OhmJS. I call it \"t2t\" (text-to-text transpilation) and am actively experimenting with it and its implications (meta-syntaxes, metaprogramming, etc.). More info/blather/discussion if interested.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lQaHm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDCLA1HU4"
                            },
                            {
                                "type": "text",
                                "text": "\n1) WRT to \"current node\", we already know how to do this using textual code and have many programming languages for this purpose. So, divide-and-conquer says that all you need to do is to map \"trees\" onto textual code, then you're done.\n\n2) Here is my (probably over-simplified) understanding of term rewriting augmented by the concept of \"current node\":\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Programmer writes an AST (the \"inhaler AST\")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Programmer writes a 1:1 corresponding rewrite AST that dove-tails with the inhaler AST. (Or, programmer annotates the above inhaler AST (this, though, violates the principles of KISS and human-readability))"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app inhales linear text and makes a CST (concrete parse tree) by culling the AST driven by the inhaled text (commonly known as \"parsing\")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app walks the rewrite AST using the newly-created CST."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app unparses the rewritten walked-tree into (new) linear text (\"code\")."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Run the generated code."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIf that's even close to what you're imagining, then I contend that this is \"easily possible\" to do using modern technology whilst loosening the thumbscrews, i.e. using OhmJS plus a nano-DSL written in OhmJS. I call it \"t2t\" (text-to-text transpilation) and am actively experimenting with it and its implications (meta-syntaxes, metaprogramming, etc.). More info/blather/discussion if interested."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727961243.777349",
        "client_msg_id": "16dfd1d6-4e21-429b-82a5-32e41c0cda89",
        "text": "<@UGWUJUZHT> The problem with your proposal is that it doesn't fit the way rewriting-based documents are used in practice. They are more like spreadsheets. The fundamental action of the computer is not \"run a program\" but \"update everything after the user has made a change to the document\". The point of a \"current node\", as I see it, would be to make it clearer to the user what exactly happens during such an update. It's more of a user interface than a programming issue.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RAQyV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " The problem with your proposal is that it doesn't fit the way rewriting-based documents are used in practice. They are more like spreadsheets. The fundamental action of the computer is not \"run a program\" but \"update everything after the user has made a change to the document\". The point of a \"current node\", as I see it, would be to make it clearer to the user what exactly happens during such an update. It's more of a user interface than a programming issue."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1728035142.700859",
        "client_msg_id": "6841f479-a6fe-4d4d-8f79-77bb0659c35b",
        "text": "<@UJBAJNFLK> Continuing to ponder, some half-baked thoughts:\n1) \"run a program\" and \"update everything after the user has made a change to the document\" are the same thing, except maybe differing in speed ; if your machine is fast enough, there is no point in trying to optimize the update by keeping update pointers, just re-do the whole thing in one fell swoop so fast that a human user perceives them to both be the same ; you want the action(s) to \"feel\" like a REPL\n2) possible relationship: \"... current node ... a user interface than a programming issue ...\" ; Lisp lists are \"trees\". I use a Lisp debugger (Lispworks) that lets me single step through Lisp code (\"trees\") in the same way that an assembler debugger lets me step through lines of code ; does this sound like \"current node\"-iness?",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gaI/O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " Continuing to ponder, some half-baked thoughts:\n1) \"run a program\" and \"update everything after the user has made a change to the document\" are the same thing, except maybe differing in speed ; if your machine is fast enough, there is no point in trying to optimize the update by keeping update pointers, just re-do the whole thing in one fell swoop so fast that a human user perceives them to both be the same ; you want the action(s) to \"feel\" like a REPL\n2) possible relationship: \"... current node ... a user interface than a programming issue ...\" ; Lisp lists are \"trees\". I use a Lisp debugger (Lispworks) that lets me single step through Lisp code (\"trees\") in the same way that an assembler debugger lets me step through lines of code ; does this sound like \"current node\"-iness?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1728132331.851319",
        "client_msg_id": "7ef566db-5249-4aa3-95a1-c3af8fcfab67",
        "text": "<@UGWUJUZHT> I guess we first have to agree on what we mean by \"program\", in particular if and how it is distinct from \"input data\". At the bit level, there is no such distinction. Both program and input data are bit patterns in memory that the computer acts on. But in what I see as the most common usage of the term, a \"program\" is something long-lived that reads \"input data\" for one of its many execution phases. With that distinction in place, it's the rewriting engine that is the program, and all the rules and terms/graphs to be rewritten are input data. Just like Excel is the program and all of the spreadsheet, including the formulas, is input data. But if you look at it from the point of view of semantics, it's the rewrite rules that are the program. Which are changed all the time in a computational document. Describing the interaction between a human and a computer via a rewriting-based document is running generated code is not wrong, but it's not helpful either unless you are thinking about writing a rewrite rule compiler.\n\nAs for 2), that's a very nice example. But I haven't seen anything similar for rewriting. I tried building my own, but gave up because it turned out not to be that useful. I came up with different debugging tools, none of which traces the work done by the computer.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ona/w",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " I guess we first have to agree on what we mean by \"program\", in particular if and how it is distinct from \"input data\". At the bit level, there is no such distinction. Both program and input data are bit patterns in memory that the computer acts on. But in what I see as the most common usage of the term, a \"program\" is something long-lived that reads \"input data\" for one of its many execution phases. With that distinction in place, it's the rewriting engine that is the program, and all the rules and terms/graphs to be rewritten are input data. Just like Excel is the program and all of the spreadsheet, including the formulas, is input data. But if you look at it from the point of view of semantics, it's the rewrite rules that are the program. Which are changed all the time in a computational document. Describing the interaction between a human and a computer via a rewriting-based document is running generated code is not wrong, but it's not helpful either unless you are thinking about writing a rewrite rule compiler.\n\nAs for 2), that's a very nice example. But I haven't seen anything similar for rewriting. I tried building my own, but gave up because it turned out not to be that useful. I came up with different debugging tools, none of which traces the work done by the computer."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1728176946.384549",
        "client_msg_id": "890d955b-be00-4c66-8be7-13aabe162598",
        "text": "<@UJBAJNFLK>, You touch upon a good point. My feeling about \"what is a program\" is somehow different and I'm struggling to put it into words.\n\nObservation / pondering: control flow is not data. Smalltalk's encapsulation of data is not sufficient to isolate control flow, like how Unix pipelines isolate control flow.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XCwhw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": ", You touch upon a good point. My feeling about \"what is a program\" is somehow different and I'm struggling to put it into words.\n\nObservation / pondering: control flow is not data. Smalltalk's encapsulation of data is not sufficient to isolate control flow, like how Unix pipelines isolate control flow."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1728203918.216799",
        "client_msg_id": "1ef418ed-d33e-4dd1-a5b2-0dd65ae90e53",
        "text": "<@UGWUJUZHT> Smalltalk is an interesting case. Control flow in Smalltalk is entirely implemented in terms of the method dispatch algorithm. That's similar to rewrite engines in that it's hidden from view. All you see in the code is messages sent around.\n\nThat's somewhat unrelated to your observation that data encapsulation doesn't imply control flow encapsulation. Or maybe it is related. I am decided for now.",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ptmaY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " Smalltalk is an interesting case. Control flow in Smalltalk is entirely implemented in terms of the method dispatch algorithm. That's similar to rewrite engines in that it's hidden from view. All you see in the code is messages sent around.\n\nThat's somewhat unrelated to your observation that data encapsulation doesn't imply control flow encapsulation. Or maybe it is related. I am decided for now."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1728210579.504329",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1728219709.000000"
        },
        "client_msg_id": "cf174db8-3a01-49fa-85dc-9d962507202f",
        "text": "<@UJBAJNFLK> Aye, and there's the rub. In my books, Smalltalk does not do message-passing (!). Smalltalk does method-calling. Method-calling involves blocking. Blocking is usually implemented as a state machine that performs low-level synchronization. In my mind, message-passing is \"fire and forget\".\n\nBlocking mixed with FTL (faster-than-light) rewriting (\"referential transparency\") works when your medium is paper, but, is overly-restrictive when your medium is reprogrammable electronic machines (aka \"computers\").\n\nContinued...<https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky>",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "attachments": [
            {
                "from_url": "https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky",
                "thumb_url": "https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9d69eba9-d5d3-4387-a046-9b881b00bd45_131x131.png",
                "thumb_width": 131,
                "thumb_height": 131,
                "service_icon": "https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky",
                "fallback": "Control Flow is Not Data",
                "text": "2024-10-06",
                "title": "Control Flow is Not Data",
                "title_link": "https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7o2EZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " Aye, and there's the rub. In my books, Smalltalk does not do message-passing (!). Smalltalk does method-calling. Method-calling involves blocking. Blocking is usually implemented as a state machine that performs low-level synchronization. In my mind, message-passing is \"fire and forget\".\n\nBlocking mixed with FTL (faster-than-light) rewriting (\"referential transparency\") works when your medium is paper, but, is overly-restrictive when your medium is reprogrammable electronic machines (aka \"computers\").\n\nContinued..."
                            },
                            {
                                "type": "link",
                                "url": "https://programmingsimplicity.substack.com/p/control-flow-is-not-data?r=1egdky"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1728223573.895489",
        "client_msg_id": "4783b789-bd63-4260-8b41-e86665872c47",
        "text": "FWIW, some brainstorming, trying to get back to the original question <https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky>",
        "team": "T5TCAFTA9",
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "attachments": [
            {
                "image_url": "https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9f8e2a0-2210-45f3-94d6-74d6ebc6fca7_271x191.png",
                "image_width": 271,
                "image_height": 191,
                "image_bytes": 6568,
                "from_url": "https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky",
                "service_icon": "https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky",
                "fallback": "Tree Current Node Brainstorming",
                "text": "2024-10-06",
                "title": "Tree Current Node Brainstorming",
                "title_link": "https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UhqQ/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW, some brainstorming, trying to get back to the original question "
                            },
                            {
                                "type": "link",
                                "url": "https://programmingsimplicity.substack.com/p/tree-current-node-brainstorming?r=1egdky"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]