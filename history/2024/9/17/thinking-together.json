[
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1726569392.396589",
        "client_msg_id": "10c584c8-0ffe-4ee5-aa6a-4ed25d14f7c7",
        "text": "What is \"program\"? essentially, conceptually.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "reply_count": 16,
        "reply_users_count": 9,
        "latest_reply": "1727106583.853929",
        "reply_users": [
            "U01AD80KMLK",
            "U8A5MS6R1",
            "U07BD7U4S4R",
            "U02E4DAQGSZ",
            "UBKNXPBAB",
            "UCUSW7WVD",
            "UE6EFEPTQ",
            "UNS7QDKFV",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ByidS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What is \"program\"? essentially, conceptually."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1726572745.880619",
        "client_msg_id": "77fcecb0-a106-45c8-874a-74392bca90eb",
        "text": "What is the ontology that you accept for answering the question?\n\nIt can go from \"it is a sequence of instructions\" to \"it is the human-readable specification of an application that can be executed on a chip\" to \"it's a valid string according to the grammar of a specific programming language\". Is a \"program\" the same as an \"app\" or the same as a \"source code\"? Without context, it is difficult to even start answering the question.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M8can",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What is the ontology that you accept for answering the question?\n\nIt can go from \"it is a sequence of instructions\" to \"it is the human-readable specification of an application that can be executed on a chip\" to \"it's a valid string according to the grammar of a specific programming language\". Is a \"program\" the same as an \"app\" or the same as a \"source code\"? Without context, it is difficult to even start answering the question."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1::skin-tone-3",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1726593896.503759",
        "client_msg_id": "5f6200c0-6920-4228-8e5c-bcd32543cafb",
        "text": "from a system-centric pov, a program is just a message to a system that modifies the system's behavior. incidentally, data is the same.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uGrpO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "from a system-centric pov, a program is just a message to a system that modifies the system's behavior. incidentally, data is the same."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1726596090.415489",
        "edited": {
            "user": "U07BD7U4S4R",
            "ts": "1726597335.000000"
        },
        "client_msg_id": "c5b60556-3ff0-49b7-be5c-b2594be14abb",
        "text": "> Without context, it is difficult to even start answering the question.\nfair.\n\nI have a strong lasting feeling that most of daily programming routines I do as developer \u2013 are incidental complexity\u2122.\nSo I am trying to figure out what is the essential complexity\u2122 of programming.\nAssuming mapping from program to how-to-run-it-on-hardware is factored out \u2013 what is left?\nCan that execution mapping *really* be factored out?\nIs there a language for \"what is left\"?\nis it eg. Prolog? TLA+?\nWhat should that language help with?\n\nMy take on it so far is \"program is mapping from state to state\". Which makes it a function?\nIs \"real\" program different from a function only because it is also \"mapped onto hardware\"? Or is there something else missing?\n\nIf program is a function, then programming language is a tool for \"convenient\" description of state-to-state mapping?",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3/MU3",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Without context, it is difficult to even start answering the question."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "fair.\n\nI have a strong lasting feeling that most of daily programming routines I do as developer \u2013 are incidental complexity\u2122.\nSo I am trying to figure out what is the essential complexity\u2122 of programming.\nAssuming mapping from program to how-to-run-it-on-hardware is factored out \u2013 what is left?\nCan that execution mapping "
                            },
                            {
                                "type": "text",
                                "text": "really",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be factored out?\nIs there a language for \"what is left\"?\nis it eg. Prolog? TLA+?\nWhat should that language help with?\n\nMy take on it so far is \"program is mapping from state to state\". Which makes it a function?\nIs \"real\" program different from a function only because it is also \"mapped onto hardware\"? Or is there something else missing?\n\nIf program is a function, then programming language is a tool for \"convenient\" description of state-to-state mapping?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1726599370.463999",
        "edited": {
            "user": "U02E4DAQGSZ",
            "ts": "1726607635.000000"
        },
        "client_msg_id": "3c2b8784-db31-4691-b260-66fed6704498",
        "text": "no the state-to-state thing is not important IMHO. IO i.e. stdin/stdout, thats the important bit. Moving state around a RAM chip is not useful, its only when the computer is between keyboard and monitor that it becomes useful and interesting. IO, the side-effects, is the point, to me anyway. So I do think the hardware mapping is the important bit.\nWhen considering the internals, I think the state-to-state bit is useful when domain mapping, converting between domain representations and abstraction levels. Then thats when the computer becomes a tool for the mind (coz it unburdens you from doing domain mappings in your head)",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y5FtQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "no the state-to-state thing is not important IMHO. IO i.e. stdin/stdout, thats the important bit. Moving state around a RAM chip is not useful, its only when the computer is between keyboard and monitor that it becomes useful and interesting. IO, the side-effects, is the point, to me anyway. So I do think the hardware mapping is the important bit.\nWhen considering the internals, I think the state-to-state bit is useful when domain mapping, converting between domain representations and abstraction levels. Then thats when the computer becomes a tool for the mind (coz it unburdens you from doing domain mappings in your head)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UBKNXPBAB",
        "type": "message",
        "ts": "1726612368.150259",
        "edited": {
            "user": "UBKNXPBAB",
            "ts": "1726612427.000000"
        },
        "client_msg_id": "3030a59b-e79f-44f2-bb16-31ebe8c4d0c6",
        "text": "I\u2019ll just drop in some commentary I made on another forum:\n\n> It\u2019s sort of \u201cfolk wisdom\u201d in some of my social circles that it is actually very hard to define programming, or to draw clean lines between programming and not-programming.\n> \n> For example, \u201cprogramming = writing textual code\u201d breaks down because of visual programming languages, structured editors, etc. The broader \u201cprogramming = manipulating symbolic representations roughly equivalent to textual code\u201d breaks down because of Drawing Dynamic Visualizations / Wrangler / programming-by-demonstration.\n> \n> So sometimes I go for ends rather than means, like \u201cprogramming = authoring dynamic artifacts\u201d. But lol what are dynamic artifacts? Oh, they\u2019re \u201cartifacts that respond differently to changing inputs / interactions / circumstances\u201d, in contrast to \u201cstatic artifacts\u201d. But \n> ```n = 0\n> for i in range(10):\n>   i += n\n> print(n)```\n> only ever produces one output value... Is it a dynamic artifact? Is a HTML website that responds to changing screen size with CSS rules a dynamic artifact? Which of these are programming?",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DEJ0x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019ll just drop in some commentary I made on another forum:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s sort of \u201cfolk wisdom\u201d in some of my social circles that it is actually very hard to define programming, or to draw clean lines between programming and not-programming.\n\nFor example, \u201cprogramming = writing textual code\u201d breaks down because of visual programming languages, structured editors, etc. The broader \u201cprogramming = manipulating symbolic representations roughly equivalent to textual code\u201d breaks down because of Drawing Dynamic Visualizations / Wrangler / programming-by-demonstration.\n\nSo sometimes I go for ends rather than means, like \u201cprogramming = authoring dynamic artifacts\u201d. But lol what are dynamic artifacts? Oh, they\u2019re \u201cartifacts that respond differently to changing inputs / interactions / circumstances\u201d, in contrast to \u201cstatic artifacts\u201d. But "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "n = 0\nfor i in range(10):\n  i += n\nprint(n)"
                            }
                        ],
                        "border": 1
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "only ever produces one output value... Is it a dynamic artifact? Is a HTML website that responds to changing screen size with CSS rules a dynamic artifact? Which of these are programming?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1726613637.526809",
        "client_msg_id": "d4346ddc-ef1f-4b30-a685-fc150b54eaaa",
        "text": "state-to-state is one model of behavior and in general a program is a representation of some subset of system behavior.\n\na typical 'program' is missing a lot of aspects. notably any notion of persistence is absent. data lives on longer than programs. newer programs have to contend with data left over by old programs (or earlier versions). this is why i think the typical notion of a program as this transient entity you run, which computes something and then is done, does not get close to covering the entire span of system behavior.\n\nthere is a fair bit of incidental vs accidental complexity discussion in the past in this slack if you search the history. there was also the related tarpit episode <https://futureofcoding.org/episodes/063.html>",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2vAW3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "state-to-state is one model of behavior and in general a program is a representation of some subset of system behavior.\n\na typical 'program' is missing a lot of aspects. notably any notion of persistence is absent. data lives on longer than programs. newer programs have to contend with data left over by old programs (or earlier versions). this is why i think the typical notion of a program as this transient entity you run, which computes something and then is done, does not get close to covering the entire span of system behavior.\n\nthere is a fair bit of incidental vs accidental complexity discussion in the past in this slack if you search the history. there was also the related tarpit episode "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.org/episodes/063.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1726632927.680669",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1726633436.000000"
        },
        "client_msg_id": "22130799-27a5-4d90-8f9f-5fbb98b2e61f",
        "text": "<@UBKNXPBAB> movies support moving pictures but you can freeze an image or even go to black. Analogously, it seems to me that the dynamism is a possibility the medium provides, whether or not any particular work uses it.\n\nI gather people were making stage plays in the new medium for decades while gradually understanding dawned of all the new possibilities that it opened up.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3njqd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBKNXPBAB"
                            },
                            {
                                "type": "text",
                                "text": " movies support moving pictures but you can freeze an image or even go to black. Analogously, it seems to me that the dynamism is a possibility the medium provides, whether or not any particular work uses it.\n\nI gather people were making stage plays in the new medium for decades while gradually understanding dawned of all the new possibilities that it opened up."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBKNXPBAB",
        "type": "message",
        "ts": "1726651545.837029",
        "client_msg_id": "09aea324-0bd7-455a-a6e7-4ed585fa6818",
        "text": "<@UCUSW7WVD> I don\u2019t think that quite gets at what\u2019s interesting to me about the Python test case. I don\u2019t see that script as, like, a degenerate program, in the same way that a single-frozen-frame movie would be a degenerate movie. I think that script DOES take advantage of the dynamism the medium provides. But its output is entirely static! This means you shouldn\u2019t judge something to be a \u201cprogram\u201d or a \u201cdynamic artifact\u201d solely on the basis of its externally visible behavior treated as a black box. Sometimes you care about how the externally visible behavior responds to edits in the artifact itself. But I don\u2019t know how to pin this down.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AtUcw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I don\u2019t think that quite gets at what\u2019s interesting to me about the Python test case. I don\u2019t see that script as, like, a degenerate program, in the same way that a single-frozen-frame movie would be a degenerate movie. I think that script DOES take advantage of the dynamism the medium provides. But its output is entirely static! This means you shouldn\u2019t judge something to be a \u201cprogram\u201d or a \u201cdynamic artifact\u201d solely on the basis of its externally visible behavior treated as a black box. Sometimes you care about how the externally visible behavior responds to edits in the artifact itself. But I don\u2019t know how to pin this down."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1726652964.016439",
        "client_msg_id": "ea9e86e7-7683-437f-8c68-b20b6b0db2ac",
        "text": "<@U07BD7U4S4R> I think you've basically nailed it in what you said there. This is exactly how I started my journey: looking for \"the essence of programming\". I described it as seeking a \"Target and Domain Independent\" programming language: one that was unconstrained by having to execute it on specific hardware Target, and untarnished by the needs of any given Domain. My conclusion was exactly what you're saying: that programs move one state to the next. That's basically it.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tKLi/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U07BD7U4S4R"
                            },
                            {
                                "type": "text",
                                "text": " I think you've basically nailed it in what you said there. This is exactly how I started my journey: looking for \"the essence of programming\". I described it as seeking a \"Target and Domain Independent\" programming language: one that was unconstrained by having to execute it on specific hardware Target, and untarnished by the needs of any given Domain. My conclusion was exactly what you're saying: that programs move one state to the next. That's basically it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1726712831.583009",
        "client_msg_id": "782749d7-b141-4f07-ad6d-96d1459e4300",
        "text": "re: state vs. IO\nit seems to me that IO is state too. The question is: at what point it becomes more useful/convenient to start distinguishing between the two.\nWhat would be the difference?\nShould *the* programming language treat them as the same, but let user introduce the difference when necessary. Or should the difference be baked in already?\nWhat is the difference, again?\nWhat other differences between seemingly same things are better (\"better\" when, for whom?) to be baked into *the* language?\n\nIt seems that the programming languages game is all about designing syntax(tool) convenience proportionally to task frequency. Seeing a lot of same things as different \u2013 breeds proliferation of tools. So maybe seeing similar things as the same would reduce tools ... \"fragmentation\"? (e.g. java's classes with their personal new-every-time-DSLs vs clojure's \"everything is a map, but these several functions is all you ever have to learn\")",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qzwlh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "re: state vs. IO\nit seems to me that IO is state too. The question is: at what point it becomes more useful/convenient to start distinguishing between the two.\nWhat would be the difference?\nShould "
                            },
                            {
                                "type": "text",
                                "text": "the",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " programming language treat them as the same, but let user introduce the difference when necessary. Or should the difference be baked in already?\nWhat is the difference, again?\nWhat other differences between seemingly same things are better (\"better\" when, for whom?) to be baked into "
                            },
                            {
                                "type": "text",
                                "text": "the",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " language?\n\nIt seems that the programming languages game is all about designing syntax(tool) convenience proportionally to task frequency. Seeing a lot of same things as different \u2013 breeds proliferation of tools. So maybe seeing similar things as the same would reduce tools ... \"fragmentation\"? (e.g. java's classes with their personal new-every-time-DSLs vs clojure's \"everything is a map, but these several functions is all you ever have to learn\")"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UNS7QDKFV",
        "type": "message",
        "ts": "1726870764.838899",
        "client_msg_id": "609f6ac6-c40e-4f1d-aabc-4c12333882e8",
        "text": "Related to the 'incidental complexity' question - sometimes I get frustrated with all the code it seems to take to do even simple tasks.  I question why there are so many lines of code?  Why can't the computer just do what I intend?  I've thought about categorizing the lines of code in some of my programs to see what all those lines are doing.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dZzr5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Related to the 'incidental complexity' question - sometimes I get frustrated with all the code it seems to take to do even simple tasks.  I question why there are so many lines of code?  Why can't the computer just do what I intend?  I've thought about categorizing the lines of code in some of my programs to see what all those lines are doing."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U07BD7U4S4R"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1726880650.143199",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1726880717.000000"
        },
        "client_msg_id": "2c522794-1567-45ed-af73-a46429a8077e",
        "text": "I've heard this line of reasoning before, and it's worth questioning the premise. For some arbitrary computing task, how do we know how simple it is? I don't think we can, short of building it from scratch for ourselves. And so we can't really make any assumptions about the level of essential/incidental complexity of a task without a lot of careful effort and analysis. It's tedious, error-prone, intricately-detailed work.\n\nIt's definitely a common reaction, and I've been guilty of it myself. My best guess these days is that it's a cognitive fallacy related to <https://en.wikipedia.org/wiki/Moravec%27s_paradox|Moravec's Paradox>. People just have really poor intuitions when it comes to computation. Simple things a child can learn without us grown-ups exerting any effort require tremendous quantities of effort for a computer to \"learn\". And the human reaction is repeated disbelief. That can't be right!",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "C1vWb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've heard this line of reasoning before, and it's worth questioning the premise. For some arbitrary computing task, how do we know how simple it is? I don't think we can, short of building it from scratch for ourselves. And so we can't really make any assumptions about the level of essential/incidental complexity of a task without a lot of careful effort and analysis. It's tedious, error-prone, intricately-detailed work.\n\nIt's definitely a common reaction, and I've been guilty of it myself. My best guess these days is that it's a cognitive fallacy related to "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Moravec%27s_paradox",
                                "text": "Moravec's Paradox"
                            },
                            {
                                "type": "text",
                                "text": ". People just have really poor intuitions when it comes to computation. Simple things a child can learn without us grown-ups exerting any effort require tremendous quantities of effort for a computer to \"learn\". And the human reaction is repeated disbelief. That can't be right!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1726889073.112009",
        "client_msg_id": "9fd9cd95-b304-4651-a71d-fc549364bacb",
        "text": "Here's how I see it: *everything* is complicated...\nThe idea of creating general purpose languages is a loser...\n<https://open.substack.com/pub/programmingsimplicity/p/programming-is-too-complicated?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true>",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sNRem",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's how I see it: "
                            },
                            {
                                "type": "text",
                                "text": "everything",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is complicated...\nThe idea of creating general purpose languages is a loser...\n"
                            },
                            {
                                "type": "link",
                                "url": "https://open.substack.com/pub/programmingsimplicity/p/programming-is-too-complicated?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1726889710.189559",
        "client_msg_id": "af72e3b7-e437-4e3c-9ac6-5854d26f6807",
        "text": "<http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail|Reality has a surprising amount of detail.>",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TznRh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail",
                                "text": "Reality has a surprising amount of detail."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UGWUJUZHT",
                    "UNS7QDKFV"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1726988428.754969",
        "client_msg_id": "7a7c57b7-0fed-4d90-b7a3-ac89b9846324",
        "text": "For some reason I get \"then it does not matter\" from \"everything is complicated\" comments.\n\nIf everything is complicated, why not deal with essential complexity instead of incidental one?\nFeels like comparable amount of work, but radically different outcomes.\n\n<https://www.youtube.com/watch?v=kZRE7HIO3vk|The Thirty Million Line Problem>\n<https://youtu.be/rX0ItVEVjHc?t=1372|Mike Acton \"Data-Oriented Design\">\n\nSometimes treating different things the same way makes things easier or even simpler.\nSometimes treating similar things differently does.\n\nbut it seems to me, scanning this space of variations is more tractable from the root tree-side, where combinatorics haven't really kick in yet.",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h8T4+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For some reason I get \"then it does not matter\" from \"everything is complicated\" comments.\n\nIf everything is complicated, why not deal with essential complexity instead of incidental one?\nFeels like comparable amount of work, but radically different outcomes.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=kZRE7HIO3vk",
                                "text": "The Thirty Million Line Problem"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/rX0ItVEVjHc?t=1372",
                                "text": "Mike Acton \"Data-Oriented Design\""
                            },
                            {
                                "type": "text",
                                "text": "\n\nSometimes treating different things the same way makes things easier or even simpler.\nSometimes treating similar things differently does.\n\nbut it seems to me, scanning this space of variations is more tractable from the root tree-side, where combinatorics haven't really kick in yet."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1727106583.853929",
        "client_msg_id": "2a2bac27-af33-4800-9dcd-873e8684a4c5",
        "text": "&gt; <https://www.youtube.com/watch?v=kZRE7HIO3vk|The Thirty Million Line Problem>  \nI watched this several years ago and deeply disagree with the conclusion. IIRC, Moratori blames USB Plug'N'Play on the exponential rise in complexity in software development. He bases his conclusion on a graph that shows the correlation between complexity and the invention of USB Plug'N'Play. Basic science says that correlation does not imply causation. The fact that the hockey stick curve of complexity jumps upwards at the same time as USB Plug'N'Play was invented does not necessarily mean that USB Plug'N'Play *caused* the rise in complexity. In fact, a different explanation for this particular correlation might be as a manifestation of incidental complexity caused by something much deeper and invented much earlier (hint: over-use of the function-based paradigm).\n\n[Note that this, also, ties in with bicycles-for-the-mind thread. Programmers have forgotten how the hardware works and have veered off into believing that there is only one way to program hardware - i.e. with lines of code written in programming languages buttressed by operating systems.]",
        "team": "T5TCAFTA9",
        "thread_ts": "1726569392.396589",
        "parent_user_id": "U07BD7U4S4R",
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=kZRE7HIO3vk",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "thumb_url": "https://i.ytimg.com/vi/kZRE7HIO3vk/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/kZRE7HIO3vk?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"The Thirty Million Line Problem\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=kZRE7HIO3vk",
                "fallback": "YouTube Video: The Thirty Million Line Problem",
                "title": "The Thirty Million Line Problem",
                "title_link": "https://www.youtube.com/watch?v=kZRE7HIO3vk",
                "author_name": "Molly Rocket",
                "author_link": "https://www.youtube.com/@MollyRocket",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ge+t/",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=kZRE7HIO3vk",
                                "text": "The Thirty Million Line Problem"
                            },
                            {
                                "type": "text",
                                "text": "  "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI watched this several years ago and deeply disagree with the conclusion. IIRC, Moratori blames USB Plug'N'Play on the exponential rise in complexity in software development. He bases his conclusion on a graph that shows the correlation between complexity and the invention of USB Plug'N'Play. Basic science says that correlation does not imply causation. The fact that the hockey stick curve of complexity jumps upwards at the same time as USB Plug'N'Play was invented does not necessarily mean that USB Plug'N'Play "
                            },
                            {
                                "type": "text",
                                "text": "caused",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the rise in complexity. In fact, a different explanation for this particular correlation might be as a manifestation of incidental complexity caused by something much deeper and invented much earlier (hint: over-use of the function-based paradigm).\n\n[Note that this, also, ties in with bicycles-for-the-mind thread. Programmers have forgotten how the hardware works and have veered off into believing that there is only one way to program hardware - i.e. with lines of code written in programming languages buttressed by operating systems.]"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    }
]