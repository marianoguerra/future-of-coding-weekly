[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1714383312.740829",
        "client_msg_id": "24690557-35a0-4b34-aa6c-a036a59528e3",
        "text": "preliminary musings on bloatware <https://guitarvydas.github.io/2024/04/27/Bloatware.html>",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "reply_count": 5,
        "reply_users_count": 3,
        "latest_reply": "1714481367.217799",
        "reply_users": [
            "UCUSW7WVD",
            "UJBAJNFLK",
            "U04SAJZ155H"
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8i1cL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "preliminary musings on bloatware "
                            },
                            {
                                "type": "link",
                                "url": "https://guitarvydas.github.io/2024/04/27/Bloatware.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1714385788.488249",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1714385840.000000"
        },
        "client_msg_id": "f1b0c4cf-0e02-4eae-94de-d6c958f40d21",
        "text": "This is extremely clarifying, because it makes it clear you're going in the exact opposite direction to me :smile:\n\nIt's only a slight exaggeration to say I want to ship the IDE to \"end-users\" (scare quotes because I believe the demographic shouldn't exist). The source code should always be available.\n\nSo it now seems to me that we've been nodding along to each other that bloat is bad, but our definitions of \"bloat\" are in opposition. From my perspective, opcodes and the transistors they run on are a necessary evil. Both are bloat without the source code and late binding needed to keep the human in the loop exercising agency over them. Anything else is just disempowering legalism (<https://futureofcoding.org/episodes/065>) that is superfluous to requirements.",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1Af7B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is extremely clarifying, because it makes it clear you're going in the exact opposite direction to me "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt's only a slight exaggeration to say I want to ship the IDE to \"end-users\" (scare quotes because I believe the demographic shouldn't exist). The source code should always be available.\n\nSo it now seems to me that we've been nodding along to each other that bloat is bad, but our definitions of \"bloat\" are in opposition. From my perspective, opcodes and the transistors they run on are a necessary evil. Both are bloat without the source code and late binding needed to keep the human in the loop exercising agency over them. Anything else is just disempowering legalism ("
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.org/episodes/065"
                            },
                            {
                                "type": "text",
                                "text": ") that is superfluous to requirements."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1714404322.426909",
        "client_msg_id": "87670709-25b6-45b9-ad65-b09a246cc2d6",
        "text": "Interesting constrast. I am mostly on <@UCUSW7WVD>'s side of what I consider important (non-bloat). But I think there's still a lot of overlap between both sides' definitions of bloat. For example code that exists due to technical debt.",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bBSTV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting constrast. I am mostly on "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "'s side of what I consider important (non-bloat). But I think there's still a lot of overlap between both sides' definitions of bloat. For example code that exists due to technical debt."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1714404482.101119",
        "client_msg_id": "035235dd-931f-4d96-acc9-6ca21ce0a134",
        "text": "Yeah, there's a reason this wasn't obvious. Mainstream software is bloated by both our definitions!",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lI5nG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, there's a reason this wasn't obvious. Mainstream software is bloated by both our definitions!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UBKNXPBAB",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1714480419.940219",
        "client_msg_id": "68d8d2b7-827f-4d3c-bceb-0d617d0e4937",
        "text": "Traditional C compilers output code in _assembly language_, which is piped to an _assembler_, which is a program that outputs _machine code_. Modern compilers internally generate code in an _intermediate representation_, and then output machine code without going through assembly language. If you want to read the output in assembly language, you have to run a disassembler.",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cryy7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Traditional C compilers output code in "
                            },
                            {
                                "type": "text",
                                "text": "assembly language",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which is piped to an "
                            },
                            {
                                "type": "text",
                                "text": "assembler",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which is a program that outputs "
                            },
                            {
                                "type": "text",
                                "text": "machine code",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Modern compilers internally generate code in an "
                            },
                            {
                                "type": "text",
                                "text": "intermediate representation",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and then output machine code without going through assembly language. If you want to read the output in assembly language, you have to run a disassembler."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04SAJZ155H",
        "type": "message",
        "ts": "1714481367.217799",
        "edited": {
            "user": "U04SAJZ155H",
            "ts": "1714481782.000000"
        },
        "client_msg_id": "70aa9dc6-1532-4ecd-8970-fb4e5516f02b",
        "text": "The assumption that the ideal application to ship to end users is all machine code and that anything else is bloat is an interesting one. If you look into it, it quickly becomes obvious that the machine code tends to be more bloated than the source code. That's on x86, an instruction set architecture that was designed to make the machine code as short as possible, at the expense of making the interpreter implemented in hardware more complex and less efficient. Modern alternatives to x86 care less about the compactness of the machine code.\n\nIt may actually be less bloated not to ship machine code, but instead ship an intermediate representation that can be JIT-compiled to machine code. Formats such as minified JS, Web Assembly and Dalvik bytecode are examples of more compact formats for shipping that in the end are passed to a JIT compiler that outputs less compact machine code.\n\nNot only are instructions in intermediate representation shorter than in machine code, but intermediate representation can also take advantage of polymorphism, allowing polymorphic code to be shipped only once, whereas the final machine code may come in multiple monomorphic copies.",
        "team": "T5TCAFTA9",
        "thread_ts": "1714383312.740829",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kg8e3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The assumption that the ideal application to ship to end users is all machine code and that anything else is bloat is an interesting one. If you look into it, it quickly becomes obvious that the machine code tends to be more bloated than the source code. That's on x86, an instruction set architecture that was designed to make the machine code as short as possible, at the expense of making the interpreter implemented in hardware more complex and less efficient. Modern alternatives to x86 care less about the compactness of the machine code.\n\nIt may actually be less bloated not to ship machine code, but instead ship an intermediate representation that can be JIT-compiled to machine code. Formats such as minified JS, Web Assembly and Dalvik bytecode are examples of more compact formats for shipping that in the end are passed to a JIT compiler that outputs less compact machine code.\n\nNot only are instructions in intermediate representation shorter than in machine code, but intermediate representation can also take advantage of polymorphism, allowing polymorphic code to be shipped only once, whereas the final machine code may come in multiple monomorphic copies."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]