[
    {
        "text": "Prof Eric Hehner's <https://www.youtube.com/watch?v=wgd6MtQHuLQ&amp;list=PLfsVAYSMwskseQbJ242TApAzA7fW83KyH&amp;index=5|theory of bunches> (think of the comma in `x,y,z` as a binary operator on bunches) seems very foundational and delightfully elegant. Once you see it, you can't see but think that the way we have handled collections of various kinds (sets, strings, tuples) is ad-hoc and not systematic.\n\nWhat if we had notation that supported all these structures? :thinking_face:",
        "files": [
            {
                "id": "F07EDFTGLUU",
                "created": 1722048637,
                "timestamp": 1722048637,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U018S42NMMM",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 663526,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F07EDFTGLUU/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F07EDFTGLUU/download/image.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 259,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 346,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 519,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 576,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 692,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F07EDFTGLUU-6a291749f4/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 738,
                "original_w": 1810,
                "original_h": 1304,
                "thumb_tiny": "AwAiADDSpM56EUvOe2KKAAZ7mg57H9KTn60c59KAFoGfbFIMnrilHX2oAOc0Umeeho4DYA/SgAxxjJpce5pM89D+VGfY/lQADr3FKBznJpOD1B/EUtABRRRQAUUUUAFFFFAH/9k=",
                "permalink": "https://futureofcoding.slack.com/files/U018S42NMMM/F07EDFTGLUU/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F07EDFTGLUU-c7fdb8af7e",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "U018S42NMMM",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S3cQ7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Prof Eric Hehner's "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=wgd6MtQHuLQ&list=PLfsVAYSMwskseQbJ242TApAzA7fW83KyH&index=5",
                                "text": "theory of bunches"
                            },
                            {
                                "type": "text",
                                "text": " (think of the comma in "
                            },
                            {
                                "type": "text",
                                "text": "x,y,z",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as a binary operator on bunches) seems very foundational and delightfully elegant. Once you see it, you can't see but think that the way we have handled collections of various kinds (sets, strings, tuples) is ad-hoc and not systematic.\n\nWhat if we had notation that supported all these structures? "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1722048644.159519",
        "client_msg_id": "1845736e-bfb8-4bb5-9c82-b3098488299f",
        "thread_ts": "1722048644.159519",
        "reply_count": 4,
        "reply_users_count": 3,
        "latest_reply": "1722055971.575679",
        "reply_users": [
            "UFEQUBNNT",
            "UCUSW7WVD",
            "U018S42NMMM"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1722049278.755519",
        "client_msg_id": "2F99FD42-03A9-47F8-AADD-CF0C26C74FC0",
        "text": "Added to my reading bag!\n\nI loved <https://www.hillelwayne.com/post/graph-types/|The Hunt for the Missing Data Type> and this seems like it\u2019s in a similar vein? Data structures that are surprisingly distant in implementation space given how near they are in conceptual space?",
        "team": "T5TCAFTA9",
        "thread_ts": "1722048644.159519",
        "parent_user_id": "U018S42NMMM",
        "attachments": [
            {
                "from_url": "https://www.hillelwayne.com/post/graph-types/",
                "service_icon": "https://www.hillelwayne.com/favicon.ico",
                "ts": 1709337600,
                "id": 1,
                "original_url": "https://www.hillelwayne.com/post/graph-types/",
                "fallback": "Hillel Wayne: The Hunt for the Missing Data Type",
                "text": "A (directed) graph is a set of nodes, connected by arrows (edges). The nodes and edges may contain data. Here are some graphs:\n\n \nAll graphs made with graphviz (source)\n\nGraphs are ubiquitous in software engineering:\n Package dependencies form directed graphs, as do module imports. The internet is a graph of links between webpages. Model checkers analyze software by exploring the \u201cstate space\u201d of all possible configurations.",
                "title": "The Hunt for the Missing Data Type",
                "title_link": "https://www.hillelwayne.com/post/graph-types/",
                "service_name": "Hillel Wayne"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wE24v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Added to my reading bag!\n\nI loved "
                            },
                            {
                                "type": "link",
                                "url": "https://www.hillelwayne.com/post/graph-types/",
                                "text": "The Hunt for the Missing Data Type"
                            },
                            {
                                "type": "text",
                                "text": " and this seems like it\u2019s in a similar vein? Data structures that are surprisingly distant in implementation space given how near they are in conceptual space?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1722052139.762239",
        "client_msg_id": "9b0864ed-a9e4-434c-ad59-78a96bfcc4fc",
        "text": "Link to a paper: <https://www.cs.toronto.edu/~hehner/CH.pdf|https://www.cs.toronto.edu/~hehner/CH.pdf>",
        "team": "T5TCAFTA9",
        "thread_ts": "1722048644.159519",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sfUYV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Link to a paper: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.cs.toronto.edu/~hehner/CH.pdf",
                                "text": "https://www.cs.toronto.edu/~hehner/CH.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1722052300.036029",
        "client_msg_id": "e8acddf5-3940-4460-bbac-b981388a4a17",
        "text": "<@UCUSW7WVD> It's in this book (chapter 2): <http://www.cs.toronto.edu/~hehner/aPToP/>",
        "team": "T5TCAFTA9",
        "thread_ts": "1722048644.159519",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zAVDJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " It's in this book (chapter 2): "
                            },
                            {
                                "type": "link",
                                "url": "http://www.cs.toronto.edu/~hehner/aPToP/"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1722055971.575679",
        "client_msg_id": "238c1b4d-0f7d-4399-b51d-7b924ec054a3",
        "text": "Yes! I read parts of that book a couple of years ago. But didn't have the link handy on my phone earlier.",
        "team": "T5TCAFTA9",
        "thread_ts": "1722048644.159519",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pg+bG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes! I read parts of that book a couple of years ago. But didn't have the link handy on my phone earlier."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013GB24BD4",
        "type": "message",
        "ts": "1722111297.263109",
        "text": "Thought the format may better fit here",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "ts": "1721506929.399589",
                "author_id": "U013GB24BD4",
                "channel_id": "CCL5VVBAN",
                "channel_team": "T5TCAFTA9",
                "is_msg_unfurl": true,
                "is_reply_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "CCL5VVBAN",
                        "ts": "1721506929.399589",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "pWkPi",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "Thank you so much for your feedback "
                                                },
                                                {
                                                    "type": "user",
                                                    "user_id": "U0296ACR13M"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": ". It's really interesting to think about the strengths and weaknesses of these different paradigms.\n\nI would say that with any sufficiently complex application, it comes down to what tooling is available and whether the codebase has consistent standards. I spend much of my day job in more standard code, in complex distributed codebases.\n\nIt's invaluable to be able to use an IDE, navigate through definitions, search across the full codebase, seamless debugging and lately even having the ability to analyze and explain larger parts of the codebase with AI in tools such as Cursor. This all can help understand new code. Using common or at least consistent patterns, good naming and all that stuff will make it easier. It can still involve learning new paradigms, libraries and so on.\n\nI would say that a lot of the same applies to working in node based environments. With the added complexity of usually having to lay out things yourself, which can absolutely make or break readability - whereas formatters are absolutely standard for text code nowadays. Also, given the lack of standardization in node based tools (yes, it's often nodes, but with so many flavors), each language requires its own IDE, putting a lot of strain on developers to match the mature tooling for text code.\n\nStill, I find that some types of flows, especially data piping, and some types of use-cases, such as realtime multimedia applications, generally work better for me in visual environments. vvvv gamma ("
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https://visualprogramming.net/"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": "), which all of Schema is created with, seems to be the closest to a full featured IDE I've come across in visual programming. I've also found that Reactive programming is incredibly intuitive in this environment, compared to C# for instance. Though  it still has some way to go, such as improved tooling for git or multiwindow.\n\nDuring development I've certainly had moments where the realtime code update and amazing protocol abstractions made it a joy, while there were others where the tooling and constant tidying needed made me wish for more standard lands.\n\nGoing back to the original point with complexity, In Schema, while theoretically possible, I do not encourage there to be a huge amount of complexity at the same time. First of all, there is a big focus on fairly high level nodes aimed mainly at animation and a good amount of things happening implicitly, such as referencing extents of objects in space. Of course, all this interconnected machinery is its own complexity, even when there may be less \"code\" to see at a time.\n\nSecondly, there are a number of ways of switching up parts of the stacks using assigning via Director, layers, groupings, referencing other objects and modifying slightly. With the general idea that you can get a lot of variety by combining and switching around small-ish stacks of blocks.\n\nAdditionally, when you look at a Block based code, which may seem visual, it's actually no more than nested functions, not far from Lisp or any code AST in general.\n\nBlockly, for instance, is often used to build out regular text code. Though I agree drag and dropping everything is a pretty obnoxious way if you know your way around code.\n\nAs a matter of fact, all of Schema Block stacks can actually be represented as a very succinct YAML ("
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https://docs.scenic.tools/future-concepts/scenicscript"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": "), which allows for a human readable transfer format, text editing (helpful on terminal devices also), LLM completions and more.\n\nWhat the UI in Schema helps with is interfacing with the parameters and providing immediate in-place feedback of the individual data processing steps (similar to TouchDesigner which does this very well). It also providing domain specific overlays such as MIDI mapping or DMX channel output visualization.\n\nOverall I am trying to strike a balance between the two worlds while finding new ways to interact with code.\n\nThis new Cursor work aims to make the block programming feel as efficient, if not more than, writing textual code, while also making it more accessible and fun with the goal of enabling full game controller support.\n\nI really appreciate that you find some of these approaches novel "
                                                },
                                                {
                                                    "type": "emoji",
                                                    "name": "heart",
                                                    "unicode": "2764-fe0f"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "color": "D0D0D0",
                "from_url": "https://futureofcoding.slack.com/archives/CCL5VVBAN/p1721506929399589?thread_ts=1720889347.004269&cid=CCL5VVBAN",
                "is_share": true,
                "fallback": "[July 20th, 2024 10:22 PM] hi565: Thank you so much for your feedback <@U0296ACR13M>. It's really interesting to think about the strengths and weaknesses of these different paradigms.\n\nI would say that with any sufficiently complex application, it comes down to what tooling is available and whether the codebase has consistent standards. I spend much of my day job in more standard code, in complex distributed codebases.\n\nIt's invaluable to be able to use an IDE, navigate through definitions, search across the full codebase, seamless debugging and lately even having the ability to analyze and explain larger parts of the codebase with AI in tools such as Cursor. This all can help understand new code. Using common or at least consistent patterns, good naming and all that stuff will make it easier. It can still involve learning new paradigms, libraries and so on.\n\nI would say that a lot of the same applies to working in node based environments. With the added complexity of usually having to lay out things yourself, which can absolutely make or break readability - whereas formatters are absolutely standard for text code nowadays. Also, given the lack of standardization in node based tools (yes, it's often nodes, but with so many flavors), each language requires its own IDE, putting a lot of strain on developers to match the mature tooling for text code.\n\nStill, I find that some types of flows, especially data piping, and some types of use-cases, such as realtime multimedia applications, generally work better for me in visual environments. vvvv gamma (<https://visualprogramming.net/>), which all of Schema is created with, seems to be the closest to a full featured IDE I've come across in visual programming. I've also found that Reactive programming is incredibly intuitive in this environment, compared to C# for instance. Though  it still has some way to go, such as improved tooling for git or multiwindow.\n\nDuring development I've certainly had moments where the realtime code update and amazing protocol abstractions made it a joy, while there were others where the tooling and constant tidying needed made me wish for more standard lands.\n\nGoing back to the original point with complexity, In Schema, while theoretically possible, I do not encourage there to be a huge amount of complexity at the same time. First of all, there is a big focus on fairly high level nodes aimed mainly at animation and a good amount of things happening implicitly, such as referencing extents of objects in space. Of course, all this interconnected machinery is its own complexity, even when there may be less \"code\" to see at a time.\n\nSecondly, there are a number of ways of switching up parts of the stacks using assigning via Director, layers, groupings, referencing other objects and modifying slightly. With the general idea that you can get a lot of variety by combining and switching around small-ish stacks of blocks.\n\nAdditionally, when you look at a Block based code, which may seem visual, it's actually no more than nested functions, not far from Lisp or any code AST in general.\n\nBlockly, for instance, is often used to build out regular text code. Though I agree drag and dropping everything is a pretty obnoxious way if you know your way around code.\n\nAs a matter of fact, all of Schema Block stacks can actually be represented as a very succinct YAML (<https://docs.scenic.tools/future-concepts/scenicscript>), which allows for a human readable transfer format, text editing (helpful on terminal devices also), LLM completions and more.\n\nWhat the UI in Schema helps with is interfacing with the parameters and providing immediate in-place feedback of the individual data processing steps (similar to TouchDesigner which does this very well). It also providing domain specific overlays such as MIDI mapping or DMX channel output visualization.\n\nOverall I am trying to strike a balance between the two worlds while finding new ways to interact with code.\n\nThis new Cursor work aims to make the block programming feel as efficient, if not more than, writing textual code, while also making it more accessible and fun with the goal of enabling full game controller support.\n\nI really appreciate that you find some of these approaches novel :heart:",
                "text": "Thank you so much for your feedback <@U0296ACR13M>. It's really interesting to think about the strengths and weaknesses of these different paradigms.\n\nI would say that with any sufficiently complex application, it comes down to what tooling is available and whether the codebase has consistent standards. I spend much of my day job in more standard code, in complex distributed codebases.\n\nIt's invaluable to be able to use an IDE, navigate through definitions, search across the full codebase, seamless debugging and lately even having the ability to analyze and explain larger parts of the codebase with AI in tools such as Cursor. This all can help understand new code. Using common or at least consistent patterns, good naming and all that stuff will make it easier. It can still involve learning new paradigms, libraries and so on.\n\nI would say that a lot of the same applies to working in node based environments. With the added complexity of usually having to lay out things yourself, which can absolutely make or break readability - whereas formatters are absolutely standard for text code nowadays. Also, given the lack of standardization in node based tools (yes, it's often nodes, but with so many flavors), each language requires its own IDE, putting a lot of strain on developers to match the mature tooling for text code.\n\nStill, I find that some types of flows, especially data piping, and some types of use-cases, such as realtime multimedia applications, generally work better for me in visual environments. vvvv gamma (<https://visualprogramming.net/>), which all of Schema is created with, seems to be the closest to a full featured IDE I've come across in visual programming. I've also found that Reactive programming is incredibly intuitive in this environment, compared to C# for instance. Though  it still has some way to go, such as improved tooling for git or multiwindow.\n\nDuring development I've certainly had moments where the realtime code update and amazing protocol abstractions made it a joy, while there were others where the tooling and constant tidying needed made me wish for more standard lands.\n\nGoing back to the original point with complexity, In Schema, while theoretically possible, I do not encourage there to be a huge amount of complexity at the same time. First of all, there is a big focus on fairly high level nodes aimed mainly at animation and a good amount of things happening implicitly, such as referencing extents of objects in space. Of course, all this interconnected machinery is its own complexity, even when there may be less \"code\" to see at a time.\n\nSecondly, there are a number of ways of switching up parts of the stacks using assigning via Director, layers, groupings, referencing other objects and modifying slightly. With the general idea that you can get a lot of variety by combining and switching around small-ish stacks of blocks.\n\nAdditionally, when you look at a Block based code, which may seem visual, it's actually no more than nested functions, not far from Lisp or any code AST in general.\n\nBlockly, for instance, is often used to build out regular text code. Though I agree drag and dropping everything is a pretty obnoxious way if you know your way around code.\n\nAs a matter of fact, all of Schema Block stacks can actually be represented as a very succinct YAML (<https://docs.scenic.tools/future-concepts/scenicscript>), which allows for a human readable transfer format, text editing (helpful on terminal devices also), LLM completions and more.\n\nWhat the UI in Schema helps with is interfacing with the parameters and providing immediate in-place feedback of the individual data processing steps (similar to TouchDesigner which does this very well). It also providing domain specific overlays such as MIDI mapping or DMX channel output visualization.\n\nOverall I am trying to strike a balance between the two worlds while finding new ways to interact with code.\n\nThis new Cursor work aims to make the block programming feel as efficient, if not more than, writing textual code, while also making it more accessible and fun with the goal of enabling full game controller support.\n\nI really appreciate that you find some of these approaches novel :heart:",
                "author_name": "Dominik Jan\u010d\u00edk",
                "author_link": "https://futureofcoding.slack.com/team/U013GB24BD4",
                "author_icon": "https://avatars.slack-edge.com/2020-05-16/1127224771285_65426aae1dc71e1ba6d6_48.jpg",
                "author_subname": "Dominik Jan\u010d\u00edk",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in Slack Conversation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Zm1K9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thought the format may better fit here"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]