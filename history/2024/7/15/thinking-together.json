[
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1721073254.172849",
        "client_msg_id": "76d0faa8-14b7-40d5-916a-a07b65d8ffb9",
        "text": "After reading a linkedin post by a friend of mine, today, in which he describes \"protective randomness\" as a virtue of human systems, the absence of which makes certain AI applications frightening, (<https://www.linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&amp;utm_medium=member_android|https://www.linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&amp;utm_medium=member_android>) I have come to the conclusion that this may be the best argument I have heard to object to the determinism in Rules as Code: that the systems we have for dealing with the output of the interpretation of statute not only anticipate but depend on variability of interpretation for their effective operation, and that they operate to do more than merely resolve disputes over legal interpretation, so the absence of those disputes is not an unmitigated benefit. Take for instance the conversation that happens between law makers and judges. A law is drafted, there are disputes over how to interpret it, in part fueled by examples of differing interpretations from administrative decision makers. Those differences in interpretation can help people know on what grounds they might object to a particular decision. Those objections go to judges, and judges might differ again, which has the same effect. And the differing interpretations of the judges in the context of things worth arguing about brings to legislators' attention places where the rule itself is both problematic from a fairness and/or interpretation standpoint, and where that problem causes significant issues in the real world, equipping them with information about where to focus when considering amendments. All of those benefits accrue even if no decision is ever made to resolve the dispute. If you replace variable administrative decision makers with a deterministic system based on a best shared interpretation, that review system, which not only accounts for but depends on variable outputs to function, stops working as effectively. That is not to say that what you lose is not worth what you gain. But it is a coherent argument about what is lost, and how, from consistent automated application of laws, and it is prescriptive about where and how rules as code should best be applied to avoid those losses. Which now makes me wonder whether armed with this idea, I would have a more generous read of the Laurence Driver paper.\n\nFor context, the linked post is aimed more at attempting to understand some forms of anxiety around AI applications, and particularly in the context of copyright violation, which Colarusso considers complaining about the wrong thing. But the idea metastasized in my head, and now I might have to give Driver the benefit of the doubt.",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UqL6O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "After reading a linkedin post by a friend of mine, today, in which he describes \"protective randomness\" as a virtue of human systems, the absence of which makes certain AI applications frightening, ("
                            },
                            {
                                "type": "link",
                                "url": "https://www.linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&utm_medium=member_android",
                                "text": "https://www.linkedin.com/posts/colarusso_protective-randomness-why-we-fear-the-ai-activity-7218600315464413184-rpc2?utm_source=share&utm_medium=member_android"
                            },
                            {
                                "type": "text",
                                "text": ") I have come to the conclusion that this may be the best argument I have heard to object to the determinism in Rules as Code: that the systems we have for dealing with the output of the interpretation of statute not only anticipate but depend on variability of interpretation for their effective operation, and that they operate to do more than merely resolve disputes over legal interpretation, so the absence of those disputes is not an unmitigated benefit. Take for instance the conversation that happens between law makers and judges. A law is drafted, there are disputes over how to interpret it, in part fueled by examples of differing interpretations from administrative decision makers. Those differences in interpretation can help people know on what grounds they might object to a particular decision. Those objections go to judges, and judges might differ again, which has the same effect. And the differing interpretations of the judges in the context of things worth arguing about brings to legislators' attention places where the rule itself is both problematic from a fairness and/or interpretation standpoint, and where that problem causes significant issues in the real world, equipping them with information about where to focus when considering amendments. All of those benefits accrue even if no decision is ever made to resolve the dispute. If you replace variable administrative decision makers with a deterministic system based on a best shared interpretation, that review system, which not only accounts for but depends on variable outputs to function, stops working as effectively. That is not to say that what you lose is not worth what you gain. But it is a coherent argument about what is lost, and how, from consistent automated application of laws, and it is prescriptive about where and how rules as code should best be applied to avoid those losses. Which now makes me wonder whether armed with this idea, I would have a more generous read of the Laurence Driver paper.\n\nFor context, the linked post is aimed more at attempting to understand some forms of anxiety around AI applications, and particularly in the context of copyright violation, which Colarusso considers complaining about the wrong thing. But the idea metastasized in my head, and now I might have to give Driver the benefit of the doubt."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U05UK5T7LPP"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1721078225.245659",
        "client_msg_id": "53377c84-d2d7-44c6-9b6b-c89caba9fb2d",
        "text": "I have a blog about matters related to the topics here. Just dropped this, which discusses why more of typical business logic should be implemented in the database: <https://frest.substack.com/p/state-farming>",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8/okl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have a blog about matters related to the topics here. Just dropped this, which discusses why more of typical business logic should be implemented in the database: "
                            },
                            {
                                "type": "link",
                                "url": "https://frest.substack.com/p/state-farming"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "thread_broadcast",
        "user": "U05PY5AQCA2",
        "thread_ts": "1720190169.723829",
        "root": {
            "user": "UGWUJUZHT",
            "type": "message",
            "ts": "1720190169.723829",
            "client_msg_id": "dd3e5184-cced-4dc7-85c2-a7dd11880114",
            "text": "pond\u2019ring aloud:\n\nI wonder if the problem with VPLs is the word \u201clanguage\u201d.\n\nIt appears to me that the word \u201cprogramming\u201d has been generally accepted to mean \u201csequential language\u201d or writing sequential codes (aka \u201ccoding\u201d). I view this view as being too restrictive. Programming is more than just commanding a machine with sequentialistic instructions. Programming a *CPU*, though, is - by definition - sequentialistic. But,,, programming a *machine(s)* need not be sequentialistic. Especially in the age of nothing-is-central. In fact, LLMs are an example of non-sequentialism. The machines that run LLMs were programmed, arduously, in sequential notation, but, the inner success of LLMs is not sequential, but something else (massively parallel plinko?).\n\nVPLs and DPLs are, to me, not sequentialistic things. Maybe they should be called \u201cnotations\u201d instead of \u201clanguages\u201d? VNP and DNP? Visual Notation for Programming, Diagrammatic Notation for Programming? [In which case, \u201cprogramming languages\u201d as we know them, are TNPs - Textual Notations for Programming].\n\nIn fact, programming is not the difficult part. Re-programming is the novel aspect of Design that computers bring to the world. We have been programming machines to do *single* things for centuries (using metal lathes, etc.). This time through, though, we have built machines capable of doing *many* things.",
            "team": "T5TCAFTA9",
            "thread_ts": "1720190169.723829",
            "reply_count": 18,
            "reply_users_count": 7,
            "latest_reply": "1721081856.860579",
            "reply_users": [
                "U01E8D4TS7M",
                "UGWUJUZHT",
                "U5STGTB3J",
                "U0378MDUG1Y",
                "UJBAJNFLK",
                "U8A5MS6R1",
                "U05PY5AQCA2"
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "koQJx",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "pond\u2019ring aloud:\n\nI wonder if the problem with VPLs is the word \u201clanguage\u201d.\n\nIt appears to me that the word \u201cprogramming\u201d has been generally accepted to mean \u201csequential language\u201d or writing sequential codes (aka \u201ccoding\u201d). I view this view as being too restrictive. Programming is more than just commanding a machine with sequentialistic instructions. Programming a "
                                },
                                {
                                    "type": "text",
                                    "text": "CPU",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": ", though, is - by definition - sequentialistic. But,,, programming a "
                                },
                                {
                                    "type": "text",
                                    "text": "machine(s)",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " need not be sequentialistic. Especially in the age of nothing-is-central. In fact, LLMs are an example of non-sequentialism. The machines that run LLMs were programmed, arduously, in sequential notation, but, the inner success of LLMs is not sequential, but something else (massively parallel plinko?).\n\nVPLs and DPLs are, to me, not sequentialistic things. Maybe they should be called \u201cnotations\u201d instead of \u201clanguages\u201d? VNP and DNP? Visual Notation for Programming, Diagrammatic Notation for Programming? [In which case, \u201cprogramming languages\u201d as we know them, are TNPs - Textual Notations for Programming].\n\nIn fact, programming is not the difficult part. Re-programming is the novel aspect of Design that computers bring to the world. We have been programming machines to do "
                                },
                                {
                                    "type": "text",
                                    "text": "single",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " things for centuries (using metal lathes, etc.). This time through, though, we have built machines capable of doing "
                                },
                                {
                                    "type": "text",
                                    "text": "many",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " things."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1721078680.266679",
        "client_msg_id": "0e329142-4e97-4a26-8159-0d7b2bd7e243",
        "text": "That folks synonimise programming with programming languages is hugely distorting.\n\nThe most successful non-programmer programming systems are Excel and end-user databases like FileMaker and access.\n\nExcel has declarative formulas but much of the programming is in the structure of the spreadsheets.\n\nA relational database with a strong user-modifiable UI is a great way of solving problems that would otherwise need a programmer. Our whole industry has almost ignored the Relational Model because it has been synonimised with the execrable SQL.\n\nI am working toward a system that resembles FileMaker but that brings in any and all data that I can into the same UI. Imagine FileMaker but there are relations representing your calendar, your filesystem, your email and social media feeds, a vast array of online data sources and services, all in one UI and freely joinable etc.\n\n*This* is the way to enable non-programmers to solve their computing problems.\n\nI would throw in regular programming _also_, but  a relational query interface over everything just solves *so* many problems.",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "r/BJV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That folks synonimise programming with programming languages is hugely distorting.\n\nThe most successful non-programmer programming systems are Excel and end-user databases like FileMaker and access.\n\nExcel has declarative formulas but much of the programming is in the structure of the spreadsheets.\n\nA relational database with a strong user-modifiable UI is a great way of solving problems that would otherwise need a programmer. Our whole industry has almost ignored the Relational Model because it has been synonimised with the execrable SQL.\n\nI am working toward a system that resembles FileMaker but that brings in any and all data that I can into the same UI. Imagine FileMaker but there are relations representing your calendar, your filesystem, your email and social media feeds, a vast array of online data sources and services, all in one UI and freely joinable etc.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "This",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is the way to enable non-programmers to solve their computing problems.\n\nI would throw in regular programming "
                            },
                            {
                                "type": "text",
                                "text": "also",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but  a relational query interface over everything just solves "
                            },
                            {
                                "type": "text",
                                "text": "so",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " many problems."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]