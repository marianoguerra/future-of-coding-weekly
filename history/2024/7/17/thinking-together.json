[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1721246911.989019",
        "client_msg_id": "0acefafc-1166-4462-ac78-a998c7505926",
        "text": "Thinking about Schematics vs. Code. [This began as a short reply to <@U5STGTB3J> regarding my take on electronics schematics in another thread.]\n\n<https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true>",
        "team": "T5TCAFTA9",
        "thread_ts": "1721246911.989019",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1721555013.669599",
        "reply_users": [
            "UJBAJNFLK",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "from_url": "https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true",
                "image_url": "https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fcd646f11-ed8d-4e6e-a505-0bb30e6a46ab_972x628.png",
                "image_width": 972,
                "image_height": 600,
                "image_bytes": 88071,
                "service_icon": "https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true",
                "fallback": "2024-07-17-Thinking About The Game Of Pong In Hardware And Software",
                "text": "In aircraft and flying terminology, there is induced drag and parasitic drag. Induced drag is the kind of drag that you want, while parasitic drag is a side-effect that you wish weren\u2019t there. For an airplane, we want lift which is a kind of drag. We push the plane faster through the air to make a good kind of drag (lift) on the airfoil-shaped wings. As we push the plane forward faster, though, we get unwanted drag (friction) against things like the landing gear. The good kind of drag is called \u201cinduced drag\u201d, while the unwanted kind of drag is called \u201cparasitic drag\u201d.",
                "title": "2024-07-17-Thinking About The Game Of Pong In Hardware And Software",
                "title_link": "https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FontR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thinking about Schematics vs. Code. [This began as a short reply to "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " regarding my take on electronics schematics in another thread.]\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://open.substack.com/pub/programmingsimplicity/p/2024-07-17-thinking-about-the-game?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1721491624.629439",
        "client_msg_id": "e492bce0-eaa4-4220-b098-996ffc2baeed",
        "text": "Thanks <@UGWUJUZHT> for this detailed explanation with a nice example!\n\nThere's one aspect I find missing from the discussion: CPUs. Early CPUs, the ones for which our languages, compilers, etc. were designed, have no accessible parallelism (and the very early ones no parallelism at all). There's a single instruction stream. In that universe, function-based programming did not any additional synchronicity constraint.\n\nToday, all CPUs and GPUs have some level of parallelism, but it's not under the control of the software. If I have a four-core processor, I can run up to four independent threads. That's a pretty severe constraint on asynchronicity in software as well.\n\nSo I wonder how we could possibly get to your dream situation of \"as many asynchronously working subsystems as our design requires\" with today's processors and no software layer for multithreading on top of them.",
        "team": "T5TCAFTA9",
        "thread_ts": "1721246911.989019",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wQeOJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " for this detailed explanation with a nice example!\n\nThere's one aspect I find missing from the discussion: CPUs. Early CPUs, the ones for which our languages, compilers, etc. were designed, have no accessible parallelism (and the very early ones no parallelism at all). There's a single instruction stream. In that universe, function-based programming did not any additional synchronicity constraint.\n\nToday, all CPUs and GPUs have some level of parallelism, but it's not under the control of the software. If I have a four-core processor, I can run up to four independent threads. That's a pretty severe constraint on asynchronicity in software as well.\n\nSo I wonder how we could possibly get to your dream situation of \"as many asynchronously working subsystems as our design requires\" with today's processors and no software layer for multithreading on top of them."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1721555013.669599",
        "client_msg_id": "2050d27b-78b8-4cd3-a618-1bf5df0b6a84",
        "text": "The issue of CPUs is addressed, but, maybe not with enough brutality\n\nThere\u2019s approximately 60+ truly-asynchronous processes on the 1972 Pong schematic, but no CPU. The design employs massive parallelism and real internal asynchronousity.\n\nIn 2024, we consider 8-ish cores to be a marvel. The cores share memory, so they cannot even be truly asynchronous.\n\nThat\u2019s some 50 years later. Something is wrong with this picture.\n\nA CPU was originally meant to be a simple sequencer circuit that was not reentrant. There is no reason to make CPU\u2019s multi-threaded, other than co$t. In 1950, it was too expensive to own more than one CPU, so human brain-power was wasted on inventing and adding software to make CPUs multi-threaded. Today, we have access to very cheap hardware actors - Arduinos, Rasberry Pis, etc. (cheaper yet, if you discard Linux and reclaim internal chip space).\n\nN.B. \u201ccentral\u201d is a bad word these days. We probably want DPUs (distributed processing units).\n\nI previously tried to write about hardware actors in <https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html>.\n\nSo, one might imagine a reprogrammable electronic machine (avoid the use of the word \u201ccompute-er\u201d) to be a collection of 1,000s of cheap hardware actors on-a-chip, where only one of them is a big honking Linux blob for running existing bloatware and for backwards compatibility.\n\n<@UJBAJNFLK>",
        "team": "T5TCAFTA9",
        "thread_ts": "1721246911.989019",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html",
                "ts": 1708128000,
                "id": 1,
                "original_url": "https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html",
                "fallback": "Computing Simplicity: Hardware actors",
                "text": "Oops! Your browser doesn't support PDFs! Download Instead",
                "title": "Hardware actors",
                "title_link": "https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html",
                "service_name": "Computing Simplicity"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Apka",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The issue of CPUs is addressed, but, maybe not with enough brutality\n\nThere\u2019s approximately 60+ truly-asynchronous processes on the 1972 Pong schematic, but no CPU. The design employs massive parallelism and real internal asynchronousity.\n\nIn 2024, we consider 8-ish cores to be a marvel. The cores share memory, so they cannot even be truly asynchronous.\n\nThat\u2019s some 50 years later. Something is wrong with this picture.\n\nA CPU was originally meant to be a simple sequencer circuit that was not reentrant. There is no reason to make CPU\u2019s multi-threaded, other than co$t. In 1950, it was too expensive to own more than one CPU, so human brain-power was wasted on inventing and adding software to make CPUs multi-threaded. Today, we have access to very cheap hardware actors - Arduinos, Rasberry Pis, etc. (cheaper yet, if you discard Linux and reclaim internal chip space).\n\nN.B. \u201ccentral\u201d is a bad word these days. We probably want DPUs (distributed processing units).\n\nI previously tried to write about hardware actors in "
                            },
                            {
                                "type": "link",
                                "url": "https://guitarvydas.github.io/2024/02/17/Hardware-Actors.html"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nSo, one might imagine a reprogrammable electronic machine (avoid the use of the word \u201ccompute-er\u201d) to be a collection of 1,000s of cheap hardware actors on-a-chip, where only one of them is a big honking Linux blob for running existing bloatware and for backwards compatibility.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]