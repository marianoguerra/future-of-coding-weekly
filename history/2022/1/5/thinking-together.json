[
    {
        "client_msg_id": "7b19335a-031d-42e0-b767-3c44deb76eee",
        "type": "message",
        "text": "I’m struck by how rare it is for basic control systems knowledge to show up in our projects; my impression is that the common approaches to closed loop feedback are:\n• Ad hoc event handling and state management\n• An exercise left to the user\n• ‘I’m sorry dave, I’m afraid I can’t do that’\nI think we tend this way because the underlying substrates (CPUs, peripherals, ISAs, PL grammars) are so well characterized as to allow formerly unthinkable consistency with open-loop methods.\n\nIt seems like there’s a lot of low hanging fruit here, and it gets at the heart of what ‘liveness’ is about. I’m curious if anyone here has experience working with controls\/dynamical systems, or pointers to FoC type projects being approached in this way.\n\nPS if you’re not familiar with controls, a wikipedia trip makes it seem like a lot of daunting math, but the basics are actually pretty simple. Basically you’ve got your current system state, a function to compute the next state, and then whatever parameters you can actual directly control (“direct manipulation”). If you’ve ever used React or FRP, they get halfway there, then overcomplicate and oversimplify it at the same time. Here’s a friendly intro if you’re curious: <https:\/\/www.youtube.com\/watch?v=O-OqgFE9SD4>.",
        "user": "U9C92716C",
        "ts": "1641389275.367500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6bd6fe3fcf91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-20\/1137095139906_6bd6fe3fcf91b6f41781_72.jpg",
            "first_name": "",
            "real_name": "Dalton Banks",
            "display_name": "daltonb",
            "team": "T5TCAFTA9",
            "name": "dalton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U9C92716C",
            "ts": "1641404799.000000"
        },
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=O-OqgFE9SD4",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/O-OqgFE9SD4?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/O-OqgFE9SD4\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=O-OqgFE9SD4",
                "fallback": "YouTube Video: Control Systems Lectures - Closed Loop Control",
                "title": "Control Systems Lectures - Closed Loop Control",
                "title_link": "https:\/\/www.youtube.com\/watch?v=O-OqgFE9SD4",
                "author_name": "Brian Douglas",
                "author_link": "https:\/\/www.youtube.com\/user\/ControlLectures",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JxU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’m struck by how rare it is for basic control systems knowledge to show up in our projects; my impression is that the common approaches to closed loop feedback are:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Ad hoc event handling and state management"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "An exercise left to the user"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "‘I’m sorry dave, I’m afraid I can’t do that’"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think we tend this way because the underlying substrates (CPUs, peripherals, ISAs, PL grammars) are so well characterized as to allow formerly unthinkable consistency with open-loop methods.\n\nIt seems like there’s a lot of low hanging fruit here, and it gets at the heart of what ‘liveness’ is about. I’m curious if anyone here has experience working with controls\/dynamical systems, or pointers to FoC type projects being approached in this way.\n\nPS if you’re not familiar with controls, a wikipedia trip makes it seem like a lot of daunting math, but the basics are actually pretty simple. Basically you’ve got your current system state, a function to compute the next state, and then whatever parameters you can actual directly control (“direct manipulation”). If you’ve ever used React or FRP, they get halfway there, then overcomplicate and oversimplify it at the same time. Here’s a friendly intro if you’re curious: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=O-OqgFE9SD4"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "reply_count": 9,
        "reply_users_count": 6,
        "latest_reply": "1641953438.032000",
        "reply_users": [
            "UCGR73CAY",
            "U9C92716C",
            "U02E4DAQGSZ",
            "U0282PL61U1",
            "U018AQ13VF1",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UCGR73CAY",
                "ts": "1641399650.368400"
            },
            {
                "user": "U9C92716C",
                "ts": "1641404132.369000"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1641407309.369600"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1641407607.369900"
            },
            {
                "user": "U9C92716C",
                "ts": "1641414892.370500"
            },
            {
                "user": "U0282PL61U1",
                "ts": "1641893642.030800"
            },
            {
                "user": "U018AQ13VF1",
                "ts": "1641929474.031500"
            },
            {
                "user": "U018AQ13VF1",
                "ts": "1641929475.031700"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1641953438.032000"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "star",
                "users": [
                    "USH01JEDQ",
                    "U02E4DAQGSZ",
                    "U027P92A0N5"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "b6731046-ca98-4048-a1d3-218cf23089da",
        "type": "message",
        "text": "I'd love to see your (B) project happen! I am convinced there are many unexplored opportunities to use full human languages or controlled subsets thereof as a means of communicating rigorously with computers.",
        "user": "UJBAJNFLK",
        "ts": "1641389479.367800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bwV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd love to see your (B) project happen! I am convinced there are many unexplored opportunities to use full human languages or controlled subsets thereof as a means of communicating rigorously with computers."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640985572.338200",
        "parent_user_id": "U02M6PM725T",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U02M6PM725T",
                    "UMVFWPZ36"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0a95b035-b536-4a72-a6ab-b88189dcbb89",
        "type": "message",
        "text": "Hi Dalton,\n\nYou may be interested in my project, the Mech programming language, which is designed specifically for these kinds of systems. I actually posted an update about it here just yesterday! <https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1641347451138200>\n\nMy background is in robotics, so I am designing Mech to be the ideal language to use on robotic systems, which of course make heavy use of control! You are right, there is a lot of low-hanging fruit here:\n\n• Units are a big one. Control systems operate in the real world, which has all kinds of dimensions. Adding units to type systems can be a big win, allowing you to verify correctness and improve reliability (<https:\/\/en.wikipedia.org\/wiki\/Mars_Climate_Orbiter|this> should never happen again).\n• Handling time explicitly is important for control systems. Having temporal operators (whenever, until, before, followed by, as soon as) can help programmers reason about control systems.\n• Asynchrony be default. The real world is asynchronous, so control systems must be as well. There's no blocking when it comes to reality.\n• Parallelism by default. A lot of algorithms for control systems are highly parallelizable. \n• Distributed programming by default. Control systems are all about coordinating disparate physical machinery to achieve a desired outcome. It's often the case that this system is composed of upwards of dozens of processing units. Think of all the computers that are in your car. A robot might have a dedicated computer per limb, networked with a CANN bus or ethernet. IOT control systems might have sensors that span a building or an entire town. \n• The same kind of math that GPUs do on games is done for control systems, so native GPGPU support is critical.\n• The real world is continuous but computerized control systems are discrete. It's important to take this into account as well. Consider a real-world control system that handles money. You don't want to use IEEE floating point for that.\n• Data is everything, so logging, searching, slicing, and visualizing data need to be first-class. Visualization is one of the most important debugging techniques for these kinds of systems. Logging must also be built-in and robust to failures. Typically the development cycle for a robot goes like this: 1. write some code 2. run the robot 3. watch the robot crash 4. look at the logs and figure out why the robot crashed 5. goto 1. So automatic logging and replay-ability of logs is also crucial. Once upon a time when I was in gradschool, I heard a tale from before my time of woe due to forgetting to set the logging flag to on. The goal was to make scans like <https:\/\/www.youtube.com\/watch?v=n8YKShFlKvY|these> of the town using the remains of <https:\/\/vimeo.com\/373043|Little Ben>, but parked cars obstructed the sidewalk view from the road. The solution then was to go out at 3 in the morning when all the cars were gone to take these scans. But one tired grad student forgot to set the logging flag to true, so they drove around all night collecting data, but it was all immediately lost. People were not happy with him.\nCurrent approaches rely on middleware to enable some of the above features. <https:\/\/ros.org|ROS> is one such middleware for robots. It's called an operating system but it runs on top of Linux. It provides a networking api to publish and subscribe to messages produced by control nodes. But the problem, aside from the fact that ROS is nigh unusable even for experts, is that the actual programming is still done in C++ or Python. I don't think I have to explain to this crowd how much of a letdown that is. C++ and Python and any other imperative language is the exact wrong kind of tool to use in this scenario.\n\nParallel, async, distributed code is way easier to write if the whole system is designed for it. Parallel\/async code got a reputation for being a nightmare to write because it's a nightmare to write in C++. But that doesn't preclude other systems being better! I think you see a general recognition in the industry that things are going this way. But I don't think they have realized yet that it's better to use a system designed from first principles to support these features than to bolt them on to C++ or Python or Javascript.\n\nMech is still really early, so even it doesn't support all the features I laid out above. But that's one of the goals for the project: to be a better language for robot systems.\n\nAnyway, I'm happy you brought this topic up, because I love talking about it!",
        "user": "UCGR73CAY",
        "ts": "1641399650.368400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "60840a70b1da",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-03-29\/3313499509682_60840a70b1da2b9e5b4a_72.png",
            "first_name": "Corey",
            "real_name": "Corey Montella",
            "display_name": "Corey",
            "team": "T5TCAFTA9",
            "name": "cmontella",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "moyM=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Dalton,\n\nYou may be interested in my project, the Mech programming language, which is designed specifically for these kinds of systems. I actually posted an update about it here just yesterday! "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1641347451138200"
                            },
                            {
                                "type": "text",
                                "text": "\n\nMy background is in robotics, so I am designing Mech to be the ideal language to use on robotic systems, which of course make heavy use of control! You are right, there is a lot of low-hanging fruit here:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Units are a big one. Control systems operate in the real world, which has all kinds of dimensions. Adding units to type systems can be a big win, allowing you to verify correctness and improve reliability ("
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Mars_Climate_Orbiter",
                                        "text": "this"
                                    },
                                    {
                                        "type": "text",
                                        "text": " should never happen again)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Handling time explicitly is important for control systems. Having temporal operators (whenever, until, before, followed by, as soon as) can help programmers reason about control systems."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Asynchrony be default. The real world is asynchronous, so control systems must be as well. There's no blocking when it comes to reality."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Parallelism by default. A lot of algorithms for control systems are highly parallelizable. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Distributed programming by default. Control systems are all about coordinating disparate physical machinery to achieve a desired outcome. It's often the case that this system is composed of upwards of dozens of processing units. Think of all the computers that are in your car. A robot might have a dedicated computer per limb, networked with a CANN bus or ethernet. IOT control systems might have sensors that span a building or an entire town. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The same kind of math that GPUs do on games is done for control systems, so native GPGPU support is critical."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The real world is continuous but computerized control systems are discrete. It's important to take this into account as well. Consider a real-world control system that handles money. You don't want to use IEEE floating point for that."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Data is everything, so logging, searching, slicing, and visualizing data need to be first-class. Visualization is one of the most important debugging techniques for these kinds of systems. Logging must also be built-in and robust to failures. Typically the development cycle for a robot goes like this: 1. write some code 2. run the robot 3. watch the robot crash 4. look at the logs and figure out why the robot crashed 5. goto 1. So automatic logging and replay-ability of logs is also crucial. Once upon a time when I was in gradschool, I heard a tale from before my time of woe due to forgetting to set the logging flag to on. The goal was to make scans like "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.youtube.com\/watch?v=n8YKShFlKvY",
                                        "text": "these"
                                    },
                                    {
                                        "type": "text",
                                        "text": " of the town using the remains of "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/vimeo.com\/373043",
                                        "text": "Little Ben"
                                    },
                                    {
                                        "type": "text",
                                        "text": ", but parked cars obstructed the sidewalk view from the road. The solution then was to go out at 3 in the morning when all the cars were gone to take these scans. But one tired grad student forgot to set the logging flag to true, so they drove around all night collecting data, but it was all immediately lost. People were not happy with him."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCurrent approaches rely on middleware to enable some of the above features. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ros.org",
                                "text": "ROS"
                            },
                            {
                                "type": "text",
                                "text": " is one such middleware for robots. It's called an operating system but it runs on top of Linux. It provides a networking api to publish and subscribe to messages produced by control nodes. But the problem, aside from the fact that ROS is nigh unusable even for experts, is that the actual programming is still done in C++ or Python. I don't think I have to explain to this crowd how much of a letdown that is. C++ and Python and any other imperative language is the exact wrong kind of tool to use in this scenario.\n\nParallel, async, distributed code is way easier to write if the whole system is designed for it. Parallel\/async code got a reputation for being a nightmare to write because it's a nightmare to write in C++. But that doesn't preclude other systems being better! I think you see a general recognition in the industry that things are going this way. But I don't think they have realized yet that it's better to use a system designed from first principles to support these features than to bolt them on to C++ or Python or Javascript.\n\nMech is still really early, so even it doesn't support all the features I laid out above. But that's one of the goals for the project: to be a better language for robot systems.\n\nAnyway, I'm happy you brought this topic up, because I love talking about it!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c8cb2f5a-2046-46e2-94a1-e09db417a1cc",
        "type": "message",
        "text": "Hey, that’s awesome!! Thanks for sharing, you’re in my neck of the woods too (Philly). Everything you laid out here is great. What I’m most interested in is a layer down I think: reifying the _<https:\/\/www.youtube.com\/watch?v=-FvrON0OmYc|dynamics>_ of the systems being programmed (which FRP is silent on). A corollary to this is being able to work easily with data-driven models, which is necessary when practically designing this systems but can also be easier than closed-form equations for beginners. Is this something you’ve thought about incorporating into Mech?\n\nI have a hunch this approach could scale nicely from beginner games, robots, and websites all the way to some very cutting edge stuff based on <https:\/\/diffprogramming.mit.edu\/|differentiable programming>.",
        "user": "U9C92716C",
        "ts": "1641404132.369000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6bd6fe3fcf91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-20\/1137095139906_6bd6fe3fcf91b6f41781_72.jpg",
            "first_name": "",
            "real_name": "Dalton Banks",
            "display_name": "daltonb",
            "team": "T5TCAFTA9",
            "name": "dalton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=-FvrON0OmYc",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/-FvrON0OmYc?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/-FvrON0OmYc\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=-FvrON0OmYc",
                "fallback": "YouTube Video: The Anatomy of a Dynamical System",
                "title": "The Anatomy of a Dynamical System",
                "title_link": "https:\/\/www.youtube.com\/watch?v=-FvrON0OmYc",
                "author_name": "Steve Brunton",
                "author_link": "https:\/\/www.youtube.com\/c\/Eigensteve",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pu9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey, that’s awesome!! Thanks for sharing, you’re in my neck of the woods too (Philly). Everything you laid out here is great. What I’m most interested in is a layer down I think: reifying the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=-FvrON0OmYc",
                                "text": "dynamics",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of the systems being programmed (which FRP is silent on). A corollary to this is being able to work easily with data-driven models, which is necessary when practically designing this systems but can also be easier than closed-form equations for beginners. Is this something you’ve thought about incorporating into Mech?\n\nI have a hunch this approach could scale nicely from beginner games, robots, and websites all the way to some very cutting edge stuff based on "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/diffprogramming.mit.edu\/",
                                "text": "differentiable programming"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C"
    },
    {
        "client_msg_id": "97265482-71b0-4cd1-9c39-598b5f9c3bf3",
        "type": "message",
        "text": "I kind of think the kubernetes control plane is a control theory esq.\n\n<https:\/\/kubernetes.io\/docs\/concepts\/architecture\/controller\/>",
        "user": "U02E4DAQGSZ",
        "ts": "1641407309.369600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/kubernetes.io\/docs\/concepts\/architecture\/controller\/",
                "thumb_url": "https:\/\/kubernetes.io\/images\/favicon.png",
                "thumb_width": 512,
                "thumb_height": 512,
                "service_icon": "https:\/\/kubernetes.io\/favicons\/apple-touch-icon-180x180.png",
                "id": 1,
                "original_url": "https:\/\/kubernetes.io\/docs\/concepts\/architecture\/controller\/",
                "fallback": "Kubernetes: Controllers",
                "text": "In robotics and automation, a control loop is a non-terminating loop that regulates the state of a system. Here is one example of a control loop: a thermostat in a room. When you set the temperature, that's telling the thermostat about your desired state. The actual room temperature is the current state. The thermostat acts to bring the current state closer to the desired state, by turning equipment on or off.",
                "title": "Controllers",
                "title_link": "https:\/\/kubernetes.io\/docs\/concepts\/architecture\/controller\/",
                "service_name": "Kubernetes"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "17Gr2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I kind of think the kubernetes control plane is a control theory esq.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/kubernetes.io\/docs\/concepts\/architecture\/controller\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d235b1f8-4d7a-4184-ae2b-7a3d87c1913d",
        "type": "message",
        "text": "I also have a patent in using kubernetes as an actual robot controller... <https:\/\/uspto.report\/patent\/app\/20200344293>\n\nI think control theory is very applicable to distributed system because failures have to be considered, and not in PL research because a single computer is considered error free (or unrecoverable at least).",
        "user": "U02E4DAQGSZ",
        "ts": "1641407607.369900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3zs=X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also have a patent in using kubernetes as an actual robot controller... "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/uspto.report\/patent\/app\/20200344293"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI think control theory is very applicable to distributed system because failures have to be considered, and not in PL research because a single computer is considered error free (or unrecoverable at least)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4ad21198-7b75-4635-8cc3-329cd90f9d6e",
        "type": "message",
        "text": "Nice! Yes, large industrial systems are where I see ideas from control systems being applied (by necessity). I’d love to see more of that power accessible to end users and smaller communities. Kubernetes is a cool illustration because it’s part of the “abstract” digital world where people forget that they’re working with physical dynamical systems in the end—not to mention the name itself. Alan Kay has recently been hammering on about how software systems should be designed more like the industrial “CAD&lt;-&gt;SIM&lt;-&gt;FAB” approach.\n<https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing>\n<https:\/\/www.quora.com\/What-would-software-CAD-SIM-look-like>",
        "user": "U9C92716C",
        "ts": "1641414892.370500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6bd6fe3fcf91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-20\/1137095139906_6bd6fe3fcf91b6f41781_72.jpg",
            "first_name": "",
            "real_name": "Dalton Banks",
            "display_name": "daltonb",
            "team": "T5TCAFTA9",
            "name": "dalton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "thumb_url": "https:\/\/qph.fs.quoracdn.net\/main-custom-t-788-600x315-pitawsfglqjondnjfdmgqqsnbnracpcv.jpeg",
                "thumb_width": 600,
                "thumb_height": 315,
                "id": 1,
                "original_url": "https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "fallback": "Quora: Does Alan Kay see any new ideas in computing?",
                "text": "Answer: “New” is not what I look for. “Ideas that make a qualitative difference over past techniques” are what I’d like to see. Years ago, I’m fairly sure I was aware of pretty much everything regarding computing that was going on in the world. Today, I’m definitely not aware of everything, so i...",
                "title": "Does Alan Kay see any new ideas in computing?",
                "title_link": "https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "service_name": "Quora"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5bt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nice! Yes, large industrial systems are where I see ideas from control systems being applied (by necessity). I’d love to see more of that power accessible to end users and smaller communities. Kubernetes is a cool illustration because it’s part of the “abstract” digital world where people forget that they’re working with physical dynamical systems in the end—not to mention the name itself. Alan Kay has recently been hammering on about how software systems should be designed more like the industrial “CAD<->SIM<->FAB” approach.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.quora.com\/What-would-software-CAD-SIM-look-like"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    }
]