[
    {
        "client_msg_id": "29f3bec6-7ccc-48b6-a9a3-2924ddfcd2ee",
        "type": "message",
        "text": "<@U01661S9F34> \"Isn't cpu scheduling a state machine by definition?\" The point isn't that using stacks avoids state machines, it's that they do that work for you.\n\nIt's like automatic garbage collection. The point isn't that memory management isn't done, it's that it's done for you.\n\nWriting your own state machines instead of using stacks is like programming with GOTOs instead of using functions. It's technically possible, and in theory may be more efficient, but there are reasons why it's no longer considered good practice.",
        "user": "ULM3U6275",
        "ts": "1648491241.993929",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/ROm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01661S9F34"
                            },
                            {
                                "type": "text",
                                "text": " \"Isn't cpu scheduling a state machine by definition?\" The point isn't that using stacks avoids state machines, it's that they do that work for you.\n\nIt's like automatic garbage collection. The point isn't that memory management isn't done, it's that it's done for you.\n\nWriting your own state machines instead of using stacks is like programming with GOTOs instead of using functions. It's technically possible, and in theory may be more efficient, but there are reasons why it's no longer considered good practice."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "650ba647-f42a-4fb9-bac7-4906580ab1e3",
        "type": "message",
        "text": "<@ULM3U6275>\n&gt; It's like automatic garbage collection. The point isn't that memory management isn't done, it's that it's done for you.\nI don't think it's the difference between manual memory management and GC, it's the difference between reference counting and GC. Both pre-emptive multitasking and co-routines are automatic scheduling algorithms. Neither requires you to build the state machine yourself. The difference is how you influence the scheduling. Pre-emptive schedulers don't take any influence from your program. Whereas coroutines provide \"yield\" points that can be seen as hints to the scheduler to be more in line with the needs of your program.\n\n&gt; is like programming with GOTOs instead of using functions\nI don't think that's accurate at all. Are you saying all state machines can be represented as coroutines? This duality seems much more like the Church-Turing duality of lambda calculus vs. Turing machines. It's theoretically important but not practical by itself.\n\nI'm also not convinced your argument is true if that's the case. Coroutines deal with a particular class of state machines (those dealing with scheduling), they are not appropriate for all state machines.\n\nAre you saying that all state machines are *better* represented as cooroutines? If that's the case, then this is very clearly subjective. That is an  argument similar to the difference between functional and imperative programming. There is no evidence that one is universally better than another. Some things are better represented functionally, and some better procedurally.\n\nAnecdotally, I dislike the GOTO argument. It misses too much nuance, in the same way that \"functional programming is always better\" is a useless statement. Both Knuth and Dijkstra himself walked back the \"GOTO considered harmful\" statements.\n&gt; _Donald E. Knuth:_ I believe that by presenting such a view I am not in fact disagreeing sharply with Dijkstra's ideas, since he recently wrote the following: \"Please don't fall into the trap of believing that I am terribly dogmatical about [the go to statement]. *I have the uncomfortable feeling that others are making a religion out of it, as if the conceptual problems of programming could be solved by a single trick, by a simple form of coding discipline!*\n<https:\/\/pic.plover.com\/knuth-GOTO.pdf>\n\nProgramming abstractions should be ladder that you can both walk up *or down* depending on the *engineering* needs of the particular problem. Dogma has no place in engineering imo. To be fair, we are all human, so that is more of an aspiration than the reality.",
        "user": "U01661S9F34",
        "ts": "1648495082.436399",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648495490.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MGsz1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's like automatic garbage collection. The point isn't that memory management isn't done, it's that it's done for you."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI don't think it's the difference between manual memory management and GC, it's the difference between reference counting and GC. Both pre-emptive multitasking and co-routines are automatic scheduling algorithms. Neither requires you to build the state machine yourself. The difference is how you influence the scheduling. Pre-emptive schedulers don't take any influence from your program. Whereas coroutines provide \"yield\" points that can be seen as hints to the scheduler to be more in line with the needs of your program.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "is like programming with GOTOs instead of using functions"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI don't think that's accurate at all. Are you saying all state machines can be represented as coroutines? This duality seems much more like the Church-Turing duality of lambda calculus vs. Turing machines. It's theoretically important but not practical by itself.\n\nI'm also not convinced your argument is true if that's the case. Coroutines deal with a particular class of state machines (those dealing with scheduling), they are not appropriate for all state machines.\n\nAre you saying that all state machines are "
                            },
                            {
                                "type": "text",
                                "text": "better",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " represented as cooroutines? If that's the case, then this is very clearly subjective. That is an  argument similar to the difference between functional and imperative programming. There is no evidence that one is universally better than another. Some things are better represented functionally, and some better procedurally.\n\nAnecdotally, I dislike the GOTO argument. It misses too much nuance, in the same way that \"functional programming is always better\" is a useless statement. Both Knuth and Dijkstra himself walked back the \"GOTO considered harmful\" statements.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Donald E. Knuth:",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " I believe that by presenting such a view I am not in fact disagreeing sharply with Dijkstra's ideas, since he recently wrote the following: \"Please don't fall into the trap of believing that I am terribly dogmatical about [the go to statement]. "
                            },
                            {
                                "type": "text",
                                "text": "I have the uncomfortable feeling that others are making a religion out of it, as if the conceptual problems of programming could be solved by a single trick, by a simple form of coding discipline!",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/pic.plover.com\/knuth-GOTO.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nProgramming abstractions should be ladder that you can both walk up "
                            },
                            {
                                "type": "text",
                                "text": "or down",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " depending on the "
                            },
                            {
                                "type": "text",
                                "text": "engineering",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " needs of the particular problem. Dogma has no place in engineering imo. To be fair, we are all human, so that is more of an aspiration than the reality."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "bee894c6-fa27-4212-a276-bdf4d5a507c9",
        "type": "message",
        "text": "&gt; coroutines allow us to avoid the complexity of state machines (by using stacks) without making in impossible to write correct code (as preemption does).\n&gt; ...\n&gt; This is unlike multiple threads preemptively writing on the same memory at the same time, which is an environment where even the world's top experts have been shown to be unable to write correct code.\nSorry, I don't buy it. Async lets you write more efficient code around IO scheduling. It solves a particular problem, that is completely orthogonal to correctness or memory safety. Coroutines are about \"when\", not \"where\".\n\nCorountines do not solve multithreaded memory safety. Async and Parallelism are not the same thing. You can still have race conditions with coroutines (Go has had plenty of bugs showing this). Multiple Coroutines can still be scheduled on different CPU cores and write to the same memory. You need something like the Rust borrow checker to solve that problem. Not coroutines.\n\n&gt; Coroutines also have the advantage (depending on how they are implemented) of having far smaller (and extendable) stacks than preemptive threads, which allows them to scale to several orders of magnitude more concurrency than preemptive\/OS threads.\nThis is the problem coroutines solve. Coroutines deal with optimization, not correctness.",
        "user": "U01661S9F34",
        "ts": "1648496141.269119",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648496225.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n2uC",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "coroutines allow us to avoid the complexity of state machines (by using stacks) without making in impossible to write correct code (as preemption does).\n...\nThis is unlike multiple threads preemptively writing on the same memory at the same time, which is an environment where even the world's top experts have been shown to be unable to write correct code."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSorry, I don't buy it. Async lets you write more efficient code around IO scheduling. It solves a particular problem, that is completely orthogonal to correctness or memory safety. Coroutines are about \"when\", not \"where\".\n\nCorountines do not solve multithreaded memory safety. Async and Parallelism are not the same thing. You can still have race conditions with coroutines (Go has had plenty of bugs showing this). Multiple Coroutines can still be scheduled on different CPU cores and write to the same memory. You need something like the Rust borrow checker to solve that problem. Not coroutines.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Coroutines also have the advantage (depending on how they are implemented) of having far smaller (and extendable) stacks than preemptive threads, which allows them to scale to several orders of magnitude more concurrency than preemptive\/OS threads."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis is the problem coroutines solve. Coroutines deal with optimization, not correctness."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "6e33da32-ce74-44b4-8205-9e7186566642",
        "type": "message",
        "text": "<@U01661S9F34> I'm saying that in most every case in which single stack asnyc is used (say, in Javascript) the proper (with i\/o wrappers and a schedule) use of coroutines (i.e. multi-stack async) would result significantly easier to write\/read\/debug\/maintain code (as well as less code). The larger and more complex the app, the larger this difference will tend to be.",
        "user": "ULM3U6275",
        "ts": "1648496367.015009",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZBO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01661S9F34"
                            },
                            {
                                "type": "text",
                                "text": " I'm saying that in most every case in which single stack asnyc is used (say, in Javascript) the proper (with i\/o wrappers and a schedule) use of coroutines (i.e. multi-stack async) would result significantly easier to write\/read\/debug\/maintain code (as well as less code). The larger and more complex the app, the larger this difference will tend to be."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "08edd7b4-3cc4-4905-a589-b5612007ce8f",
        "type": "message",
        "text": "I think this exists already: it's called Node.js, and, afaik, it did not make large complex apps easier to write\/read\/debug\/maintain.\nFrom what I've seen, adding richer type systems with things like typescript or one of the myriad of other languages that use javascript as a compile target have had better success on those fronts.",
        "user": "U01661S9F34",
        "ts": "1648496703.560479",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j3id",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think this exists already: it's called Node.js, and, afaik, it did not make large complex apps easier to write\/read\/debug\/maintain.\nFrom what I've seen, adding richer type systems with things like typescript or one of the myriad of other languages that use javascript as a compile target have had better success on those fronts."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "646aad36-234e-4535-84e1-a5e49d2673cb",
        "type": "message",
        "text": "Node.js doesn't have coroutines.",
        "user": "ULM3U6275",
        "ts": "1648498969.233539",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JCen",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Node.js doesn't have coroutines."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "59fa2a00-1eef-4fc1-ba27-9a44cb56efef",
        "type": "message",
        "text": "Node.js has async, yield, and iterators. That's the required building blocks for coroutines. See the many coroutine libraries on npm for examples. All of this is based on CSP Theory from Hoare. Just varying levels of abstraction.\n<https:\/\/medium.com\/@adambene\/async-await-vs-coroutines-vs-promises-eaedee4e0829|https:\/\/medium.com\/@adambene\/async-await-vs-coroutines-vs-promises-eaedee4e0829>",
        "user": "U01661S9F34",
        "ts": "1648499795.766609",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LRx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Node.js has async, yield, and iterators. That's the required building blocks for coroutines. See the many coroutine libraries on npm for examples. All of this is based on CSP Theory from Hoare. Just varying levels of abstraction.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/medium.com\/@adambene\/async-await-vs-coroutines-vs-promises-eaedee4e0829",
                                "text": "https:\/\/medium.com\/@adambene\/async-await-vs-coroutines-vs-promises-eaedee4e0829"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "2dba9a9d-e3c8-4664-abdf-b9728db07d2a",
        "type": "message",
        "text": "Most Lisps implements coroutines the same way btw: async, yield, and iterators",
        "user": "U01661S9F34",
        "ts": "1648500371.451019",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sATnV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most Lisps implements coroutines the same way btw: async, yield, and iterators"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "67aca224-e455-41a8-8556-d064888ed933",
        "type": "message",
        "text": "Look. You can do some cool stuff with async and coroutines. But it's just another tool in the toolbox imo.  In fact, in my experience, show that async and coroutines make debugging more difficult not less. Coroutines expose more things for the programmer to think about, not less.\n\nStandard sequential architecture *hides* all scheduling from the programmer. The OS or runtime pre-empts your code at arbitrary points. It's invisible to you. You don't think about it. It's like Virtual Memory. Virtual Memory creates the illusion that you have infinite RAM (and the OS in the background pages memory in and out of your process without your program having any knowledge of it at all.)\n\nBut, there are downsides. A database really needs control over when things are paged in and out of memory. But I don't want all programs to do this. It makes life harder on the programmer. I *want* the option to pick the right tool for the job. For databases Virtual memory is the wrong tool, for some other application it's the right one.\n\nPre-emptive scheduling is the same idea. You write your code as if there was a single CPU core and your program is the only thing running. Then the OS will sneakily pause your program and let some other program run, you being non the wiser. This is a great abstraction!\n\nSimilarly, coroutines *explicitly* expose the scheduling points to the user. Preemptive scheduling has the disadvantage of only being able to proceed as a fast as it's slowest I\/O call. If you are building a web server, preemptive scheduling is the wrong tool. You want to process a lot of I\/O and not have have to wait for the slowest one, you really want something like coroutines.\n\nBut! now you have many possible orders of execution that you have to keep track of when debugging. The illusion of a single linear order of execution is gone. You have added more states to your DFA, not less.\n\nI have some experience in this area. I am actually a big fan of coroutines! I spent a year working with the async team working to add coroutines and CSP to the <https:\/\/nim-lang.org|Nim language>. I read a lot of research on this stuff, and I have experience with the inner workings of both the language transforms and the schedulers. CSP has some cool properties. I'm not denying that. It certainly isn't some magic paradigm shifting solution to modern software architecture though.",
        "user": "U01661S9F34",
        "ts": "1648503181.610769",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648504761.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xlu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Look. You can do some cool stuff with async and coroutines. But it's just another tool in the toolbox imo.  In fact, in my experience, show that async and coroutines make debugging more difficult not less. Coroutines expose more things for the programmer to think about, not less.\n\nStandard sequential architecture "
                            },
                            {
                                "type": "text",
                                "text": "hides",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " all scheduling from the programmer. The OS or runtime pre-empts your code at arbitrary points. It's invisible to you. You don't think about it. It's like Virtual Memory. Virtual Memory creates the illusion that you have infinite RAM (and the OS in the background pages memory in and out of your process without your program having any knowledge of it at all.)\n\nBut, there are downsides. A database really needs control over when things are paged in and out of memory. But I don't want all programs to do this. It makes life harder on the programmer. I "
                            },
                            {
                                "type": "text",
                                "text": "want",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the option to pick the right tool for the job. For databases Virtual memory is the wrong tool, for some other application it's the right one.\n\nPre-emptive scheduling is the same idea. You write your code as if there was a single CPU core and your program is the only thing running. Then the OS will sneakily pause your program and let some other program run, you being non the wiser. This is a great abstraction!\n\nSimilarly, coroutines "
                            },
                            {
                                "type": "text",
                                "text": "explicitly",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " expose the scheduling points to the user. Preemptive scheduling has the disadvantage of only being able to proceed as a fast as it's slowest I\/O call. If you are building a web server, preemptive scheduling is the wrong tool. You want to process a lot of I\/O and not have have to wait for the slowest one, you really want something like coroutines.\n\nBut! now you have many possible orders of execution that you have to keep track of when debugging. The illusion of a single linear order of execution is gone. You have added more states to your DFA, not less.\n\nI have some experience in this area. I am actually a big fan of coroutines! I spent a year working with the async team working to add coroutines and CSP to the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/nim-lang.org",
                                "text": "Nim language"
                            },
                            {
                                "type": "text",
                                "text": ". I read a lot of research on this stuff, and I have experience with the inner workings of both the language transforms and the schedulers. CSP has some cool properties. I'm not denying that. It certainly isn't some magic paradigm shifting solution to modern software architecture though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "e39abf37-b0e2-4c46-935a-8425016fd204",
        "type": "message",
        "text": "Here is an example where (formal) CSP works really well. I would like to point out that it is used as an explicit tool to model state machines, explicitly modeling all the states, *not* hiding them:\n<https:\/\/www.reaktor.com\/blog\/why-csp-matters-ii-how-do-i-know-sync-works\/>",
        "user": "U01661S9F34",
        "ts": "1648503764.589209",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jE4bf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here is an example where (formal) CSP works really well. I would like to point out that it is used as an explicit tool to model state machines, explicitly modeling all the states, "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " hiding them:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.reaktor.com\/blog\/why-csp-matters-ii-how-do-i-know-sync-works\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "82676e3a-36fa-4412-a015-2ae4b7c66749",
        "type": "message",
        "text": "Another really cool use of CSP principles is delimited continuations, as seen in Racket: <https:\/\/docs.racket-lang.org\/more\/index.html#(part._.Continuations)>\nIt's a way to do AJAX style stateful request\/response, using only a single handler. It combines server routing and I\/O scheduling of the network call together. IMO this results in much more readable and clean code. Iirc Hacker News uses this trick, still to this day. I wish more modern languages and servers supported the technique.",
        "user": "U01661S9F34",
        "ts": "1648504559.127549",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648504605.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kga2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another really cool use of CSP principles is delimited continuations, as seen in Racket: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/docs.racket-lang.org\/more\/index.html#(part._.Continuations)"
                            },
                            {
                                "type": "text",
                                "text": "\nIt's a way to do AJAX style stateful request\/response, using only a single handler. It combines server routing and I\/O scheduling of the network call together. IMO this results in much more readable and clean code. Iirc Hacker News uses this trick, still to this day. I wish more modern languages and servers supported the technique."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "f5957e59-a143-4030-84e4-a3eefd49078a",
        "type": "message",
        "text": "Did you read the article linked in the original post for this thread? ( <https:\/\/journal.stuffwithstuff.com\/2015\/02\/01\/what-color-is-your-function\/> ) I think it explains JS's async\/await is not the same as coroutines.",
        "user": "ULM3U6275",
        "ts": "1648504857.688159",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "ULM3U6275",
            "ts": "1648504914.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "07btN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Did you read the article linked in the original post for this thread? ( "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/journal.stuffwithstuff.com\/2015\/02\/01\/what-color-is-your-function\/"
                            },
                            {
                                "type": "text",
                                "text": " ) I think it explains JS's async\/await is not the same as coroutines."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "05aeae34-0cfa-4147-a845-facbefa18756",
        "type": "message",
        "text": "I have read the article many times. Did you read my responses? Let me be more clear. JS doesn't have coroutines, but it has the building blocks to make coroutines. Ok, so that isn't at the language runtime level, but it amounts to the same thing.\n\nFrom the article:\n&gt; This is where the “red functions can only be called by red functions” rule comes from. You have to closurify the entire callstack all the way back to `main()` or the event handler.\nWhat's the difference between \"closurify the entire callstack\" and \"reified callstacks\"?\nAn implementation detail, that's what. They are semantically equivalent.\nYou implement a coroutine scheduler using a trampoline at the main and a set of execution stacks.\n\n&gt; Go is the language that does this most beautifully in my opinion. As soon as you do any IO operation, it just parks that goroutine and resumes any other ones that aren’t blocked on IO.\nYou know that \"goroutines\" are just a fancy closure right?\nWhen you write the go program \"read(\"file.txt\")\", it's essentially tranformed into \"await read(\"file.txt\")\"",
        "user": "U01661S9F34",
        "ts": "1648506310.983499",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648506353.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hVJ\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have read the article many times. Did you read my responses? Let me be more clear. JS doesn't have coroutines, but it has the building blocks to make coroutines. Ok, so that isn't at the language runtime level, but it amounts to the same thing.\n\nFrom the article:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is where the “red functions can only be called by red functions” rule comes from. You have to closurify the entire callstack all the way back to "
                            },
                            {
                                "type": "text",
                                "text": "main()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or the event handler."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What's the difference between \"closurify the entire callstack\" and \"reified callstacks\"?\nAn implementation detail, that's what. They are semantically equivalent.\nYou implement a coroutine scheduler using a trampoline at the main and a set of execution stacks.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Go is the language that does this most beautifully in my opinion. As soon as you do any IO operation, it just parks that goroutine and resumes any other ones that aren’t blocked on IO."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYou know that \"goroutines\" are just a fancy closure right?\nWhen you write the go program \"read(\"file.txt\")\", it's essentially tranformed into \"await read(\"file.txt\")\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "06e89a46-c431-4050-a13a-25a0c1c6ec06",
        "type": "message",
        "text": "There is a difference between what is possible and what is practical. For example, if I try to use some open source JS code, will everything be written in async\/await? Or will I have to rewrite it and potentially maintain the async\/await version will future updates of the module? What about all of its dependencies? Do I update and maintain all of those too? While these barriers are theoretically surmountable given unbounded time and resources, they are practically non-starters for most programmers. Coroutines would remove these barriers.",
        "user": "ULM3U6275",
        "ts": "1648507052.374169",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gMdMM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is a difference between what is possible and what is practical. For example, if I try to use some open source JS code, will everything be written in async\/await? Or will I have to rewrite it and potentially maintain the async\/await version will future updates of the module? What about all of its dependencies? Do I update and maintain all of those too? While these barriers are theoretically surmountable given unbounded time and resources, they are practically non-starters for most programmers. Coroutines would remove these barriers."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "f3d5fc62-5978-43a3-9c9a-310b83bd7b73",
        "type": "message",
        "text": "If you want an example of something closer to Go, see my original <https:\/\/ziglang.org\/download\/0.5.0\/release-notes.html#Async-Functions|Zig example> at the top of the the thread. It works very similarly to Go but without the magic that hides it from you.\n\nFrom the zig docs:\n&gt; The point here is that the `amain` function, which is the demo of typical async\/await usage, works in both an async context and blocking context. The programmer was able to express the inherent parallelism of the logic, without resorting to <http:\/\/journal.stuffwithstuff.com\/2015\/02\/01\/what-color-is-your-function\/|function coloring>.\n&gt; There is admittedly a bit of boilerplate in the example. <https:\/\/github.com\/ziglang\/zig\/issues\/3164|Here's the tracking issue for that>.\n&gt; Now for the related <https:\/\/ziglang.org\/download\/0.5.0\/release-notes.html#Standard-Library|Standard Library> updates:\n&gt; This introduces the concept of \"IO mode\" which is configurable by the <https:\/\/ziglang.org\/documentation\/0.5.0\/#Root-Source-File|Root Source File> (e.g. next to *`pub`* *`fn`* *`main`*). Applications can put this in their root source file:\nI personally think the Zig solution is much better than the Go solution.",
        "user": "U01661S9F34",
        "ts": "1648507079.363439",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648507139.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AX+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you want an example of something closer to Go, see my original "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ziglang.org\/download\/0.5.0\/release-notes.html#Async-Functions",
                                "text": "Zig example"
                            },
                            {
                                "type": "text",
                                "text": " at the top of the the thread. It works very similarly to Go but without the magic that hides it from you.\n\nFrom the zig docs:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The point here is that the "
                            },
                            {
                                "type": "text",
                                "text": "amain",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " function, which is the demo of typical async\/await usage, works in both an async context and blocking context. The programmer was able to express the inherent parallelism of the logic, without resorting to "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/journal.stuffwithstuff.com\/2015\/02\/01\/what-color-is-your-function\/",
                                "text": "function coloring"
                            },
                            {
                                "type": "text",
                                "text": ".\nThere is admittedly a bit of boilerplate in the example. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/ziglang\/zig\/issues\/3164",
                                "text": "Here's the tracking issue for that"
                            },
                            {
                                "type": "text",
                                "text": ".\nNow for the related "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ziglang.org\/download\/0.5.0\/release-notes.html#Standard-Library",
                                "text": "Standard Library"
                            },
                            {
                                "type": "text",
                                "text": " updates:\nThis introduces the concept of \"IO mode\" which is configurable by the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ziglang.org\/documentation\/0.5.0\/#Root-Source-File",
                                "text": "Root Source File"
                            },
                            {
                                "type": "text",
                                "text": " (e.g. next to "
                            },
                            {
                                "type": "text",
                                "text": "pub",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "fn",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "main",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). Applications can put this in their root source file:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI personally think the Zig solution is much better than the Go solution."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "a213aed2-a160-4a3d-9b47-442da57c7599",
        "type": "message",
        "text": "&gt; here is a difference between what is possible and what is practical. For example, if I try to use some open source JS code, will everything be written in async\/await? Or will I have to rewrite it and potentially maintain the async\/await version will future updates of the module? What about all of its dependencies? Do I update and maintain all of those too?\nThat's a good argument, though as much of a political one as a technical one. It's more practical from a technical standpoint than you might think though. It's possible at the compiler level to use program transforms. i.e. lisp style macros (what Nim and lisp do) or compiler passes (what Zig and Go do) to automate a lot of that, at least from the point of the standard library. Just make the standard library I\/O calls async, and automatically transform the callers into delimited continuation closures. Admittedly that is fairly invasive and not foolproof (depending on how the caller code was written).",
        "user": "U01661S9F34",
        "ts": "1648508148.832639",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648508331.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wuHH8",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "here is a difference between what is possible and what is practical. For example, if I try to use some open source JS code, will everything be written in async\/await? Or will I have to rewrite it and potentially maintain the async\/await version will future updates of the module? What about all of its dependencies? Do I update and maintain all of those too?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThat's a good argument, though as much of a political one as a technical one. It's more practical from a technical standpoint than you might think though. It's possible at the compiler level to use program transforms. i.e. lisp style macros (what Nim and lisp do) or compiler passes (what Zig and Go do) to automate a lot of that, at least from the point of the standard library. Just make the standard library I\/O calls async, and automatically transform the callers into delimited continuation closures. Admittedly that is fairly invasive and not foolproof (depending on how the caller code was written)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "b3ee0bc3-75fc-4963-b7ce-9765de4ccdd5",
        "type": "message",
        "text": "\"It's more practical from a technical standpoint than you might think though...\" If you write and maintain it, I would love to use (and advocate for) it - assuming it worked well with debuggers and didn't wreck performance. IMO this is the greatest weakness of JS at the moment.",
        "user": "ULM3U6275",
        "ts": "1648510600.001469",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "ULM3U6275",
            "ts": "1648510633.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4GO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"It's more practical from a technical standpoint than you might think though...\" If you write and maintain it, I would love to use (and advocate for) it - assuming it worked well with debuggers and didn't wreck performance. IMO this is the greatest weakness of JS at the moment."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "d5722e5d-2733-41e9-969f-93ba0fd46f6f",
        "type": "message",
        "text": "You are right about JS. There would have to be a lot of changes there. It's most practical at the language level, where you can uniformly enforce the transforms. In terms of performance, reification of closures is something that can be heavily optimized. (I think V8 does a lot for this already, but I don't remember all the details). Debugging is another story. I have yet to see good debugger support for concurrent code in any language. That's the main reason I think concurrent code is not a silver bullet. If you had a solution for that, I would love to use and advocate for it!",
        "user": "U01661S9F34",
        "ts": "1648514113.147109",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648514719.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jnGPk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You are right about JS. There would have to be a lot of changes there. It's most practical at the language level, where you can uniformly enforce the transforms. In terms of performance, reification of closures is something that can be heavily optimized. (I think V8 does a lot for this already, but I don't remember all the details). Debugging is another story. I have yet to see good debugger support for concurrent code in any language. That's the main reason I think concurrent code is not a silver bullet. If you had a solution for that, I would love to use and advocate for it!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "6aa66a75-19b5-4928-aeb5-57103576484a",
        "type": "message",
        "text": "You could run some \"macro expander\" program on top of your JS code and all dependencies. I guess during the \"bundler\" build step in the javascript world. I think something like this is what Vue.js does for their component language?\nBut at that point it's not JS anymore is it? You are basically building a new language that compiles to JS... Are DSLs that get macro expanded in lisp still lisp? :stuck_out_tongue:",
        "user": "U01661S9F34",
        "ts": "1648514427.622619",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1648514455.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NzcDb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You could run some \"macro expander\" program on top of your JS code and all dependencies. I guess during the \"bundler\" build step in the javascript world. I think something like this is what Vue.js does for their component language?\nBut at that point it's not JS anymore is it? You are basically building a new language that compiles to JS... Are DSLs that get macro expanded in lisp still lisp? "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    },
    {
        "client_msg_id": "b07e85e2-352f-42d3-ab8e-6a6cfc2b9c32",
        "type": "message",
        "text": "I've been out of the JS world a long time, looks like React already added coroutines (specialized for react components): <https:\/\/blog.logrocket.com\/deep-dive-react-fiber\/>",
        "user": "U01661S9F34",
        "ts": "1648516857.963519",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gKhj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been out of the JS world a long time, looks like React already added coroutines (specialized for react components): "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/blog.logrocket.com\/deep-dive-react-fiber\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T"
    }
]