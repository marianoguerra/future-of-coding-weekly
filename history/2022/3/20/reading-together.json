[
    {
        "client_msg_id": "76a7ad5d-265d-4a8c-91eb-617d0c68d447",
        "type": "message",
        "text": "One thing I particularly appreciate about this paper (thank you for pointing me at it!) is the resuscitation (in Section 3) of the old notion of _change-proneness_. I'd somehow missed this rationale for our modern software engineering mileu, obsessed with libraries, commandline flags and configuration languages. Even though I've been reading the literature for decades, I came to it decades after the reasons had gotten enshrined and taken for granted:\n• Changes to software are costly\n• Therefore make software less change-prone\n• Hence SOLID, encapsulation, etc., etc.\nIt's worth revisiting this argument, though. We've now had decades demonstrating that software never stops changing. Avoiding changes feels increasingly like a fool's errand. Also, once you _have_ to make _some_ change, we have lots of practices for reducing the cost of changes: tests, version control, CI. Is it really worth putting change-proneness on the pedestal we do, to the extent that _all_ our best practice is focused on a risk we already have decent ways to mitigate? Perhaps it's time to just change the code (<https:\/\/catern.com\/change_code.html>)",
        "user": "UCUSW7WVD",
        "ts": "1647801861.568669",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1647801944.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a1Ld",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing I particularly appreciate about this paper (thank you for pointing me at it!) is the resuscitation (in Section 3) of the old notion of "
                            },
                            {
                                "type": "text",
                                "text": "change-proneness",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I'd somehow missed this rationale for our modern software engineering mileu, obsessed with libraries, commandline flags and configuration languages. Even though I've been reading the literature for decades, I came to it decades after the reasons had gotten enshrined and taken for granted:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Changes to software are costly"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Therefore make software less change-prone"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Hence SOLID, encapsulation, etc., etc."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt's worth revisiting this argument, though. We've now had decades demonstrating that software never stops changing. Avoiding changes feels increasingly like a fool's errand. Also, once you "
                            },
                            {
                                "type": "text",
                                "text": "have",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to make "
                            },
                            {
                                "type": "text",
                                "text": "some",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " change, we have lots of practices for reducing the cost of changes: tests, version control, CI. Is it really worth putting change-proneness on the pedestal we do, to the extent that "
                            },
                            {
                                "type": "text",
                                "text": "all",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " our best practice is focused on a risk we already have decent ways to mitigate? Perhaps it's time to just change the code ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/catern.com\/change_code.html"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647706765.310949",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "FD3FABE0-3DAD-4304-B8C2-E46AEDC790F2",
        "type": "message",
        "text": "Yeah I really quite enjoyed the article in a way I didn’t expect to. I like the distinction between the various kinds of types and enjoy the de-emphasis on the static vs dynamic nature.\n\nI did like the discussion about abstraction, but found it a bit disjointed. Maybe I wanted too much out the discussion, because abstraction is a big interest of mine. What I did like was his calling out that a failure to “protect” and abstraction doesn't mean there is none. But I think this should lead us to the bigger conclusion, abstraction is not about data\/information hiding. A linked list in C is an abstraction, but nothing need be hidden, there can just be direct pointers. \n\nI could go on about abstraction, but I will leave it to just one more thing. I think his Parma's quote about “levels of abstraction” being an “abuse of language” isn’t quite correct either. To my thinking there is a clear hierarchy to abstractness (really I’d say a partial order). I think to deny that is to change subjects. But that hierarchy isn’t a universal one, it is relative to a base. Functions in the lambda calculus are not an abstraction. Functions in java are an abstraction. \n\nRegardless, really interesting paper very happy to have read it.\n\n<@UCUSW7WVD> I completely agree with your “just change the code” view. You are right to point out that software is always changing. I’d actually take an even stronger stance. \n\n1. Software is always changing and trying to completely predict in which ways it will change is a fools errand. \n2. SOLID, encaspulation, etc require you to predict which ways software will change\n3. Making the wrong predictions makes your code harder to change on certain axes\n4. Therefore these practices are net negatives\nThis is an argument that I think is very hard to make, because like many of the arguments I want to make, it sounds like I’m just advocating for anarchy. But I think there is a real difference. I am not suggestion code have no structure, no design. I just think the designs we can easily give names to and easily tell others to copy are generally not the good ones. Design in contextual to the tasks, goals, environment, etc. There is no playbook, only taste.",
        "user": "UK3LH8CF5",
        "ts": "1647815389.825929",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UK3LH8CF5",
            "ts": "1647816963.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O0JvT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I really quite enjoyed the article in a way I didn’t expect to. I like the distinction between the various kinds of types and enjoy the de-emphasis on the static vs dynamic nature.\n\nI did like the discussion about abstraction, but found it a bit disjointed. Maybe I wanted too much out the discussion, because abstraction is a big interest of mine. What I did like was his calling out that a failure to “protect” and abstraction doesn't mean there is none. But I think this should lead us to the bigger conclusion, abstraction is not about data\/information hiding. A linked list in C is an abstraction, but nothing need be hidden, there can just be direct pointers. \n\nI could go on about abstraction, but I will leave it to just one more thing. I think his Parma's quote about “levels of abstraction” being an “abuse of language” isn’t quite correct either. To my thinking there is a clear hierarchy to abstractness (really I’d say a partial order). I think to deny that is to change subjects. But that hierarchy isn’t a universal one, it is relative to a base. Functions in the lambda calculus are not an abstraction. Functions in java are an abstraction. \n\nRegardless, really interesting paper very happy to have read it.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I completely agree with your “just change the code” view. You are right to point out that software is always changing. I’d actually take an even stronger stance. \n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Software is always changing and trying to completely predict in which ways it will change is a fools errand. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "SOLID, encaspulation, etc require you to predict which ways software will change"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Making the wrong predictions makes your code harder to change on certain ax"
                                    },
                                    {
                                        "type": "text",
                                        "text": "es"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Therefore these practices are net negatives"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis is an argument that I think is very hard to make, because like many of the arguments I want to make, it sounds like I’m just advocating for anarchy. But I think there is a real difference. I am not suggestion code have no structure, no design. I just think the designs we can easily give names to and easily tell others to copy are generally not the good ones. Design in contextual to the tasks, goals, environment, etc. There is no playbook, only taste."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1647706765.310949",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD",
                    "U014WA16VNJ"
                ],
                "count": 2
            },
            {
                "name": "heartpulse",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "text": "My first entry here is “How do Committees Invent” by Melvin Conway. If you are familiar with Conway’s Law, this is the paper that introduced it to the world. If you aren’t, Conway’s law is the following\n\n&gt; Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.\n\nBefore reading the paper, I had never considered the way in which Conway’s law impacts not only software, but any system designed at a company. \n\nThe paper is short and incredibly convincing. The hierarchical workplace organization is almost always a structural mismatch for how we want our software to be. Further, it is rigid in a way we almost never desire for our software. Given Conway’s Law, if we want better software, should we be coming up with better organizational theories? Honestly, I think so.\n\nHe ends by asking how we can avoid this problem and says this \n\n&gt; Ways must be found to reward design managers for keeping their organizations lean and flexible.\n\nIt is so sad to me that today people would think this meant agile, when in fact, agile is one of the very things holding us back from addressing this issue head on. &lt;\/controversial-opinion&gt;\n\nHighly recommend reading even if you feel you already know Conway’s law.",
        "files": [
            {
                "id": "F0387MV0NTT",
                "created": 1647816165,
                "timestamp": 1647816165,
                "name": "committees.pdf",
                "title": "File from iOS",
                "mimetype": "application\/pdf",
                "filetype": "pdf",
                "pretty_type": "PDF",
                "user": "UK3LH8CF5",
                "editable": false,
                "size": 3081567,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https:\/\/files.slack.com\/files-pri\/T5TCAFTA9-F0387MV0NTT\/committees.pdf?t=xoxe-197418537349-3334460411954-3327810370486-8408fa93380fad4df07aa2b554429b02",
                "url_private_download": "https:\/\/files.slack.com\/files-pri\/T5TCAFTA9-F0387MV0NTT\/download\/committees.pdf?t=xoxe-197418537349-3334460411954-3327810370486-8408fa93380fad4df07aa2b554429b02",
                "media_display_type": "unknown",
                "thumb_pdf": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F0387MV0NTT-3c030bf3d4\/committees_thumb_pdf.png?t=xoxe-197418537349-3334460411954-3327810370486-8408fa93380fad4df07aa2b554429b02",
                "thumb_pdf_w": 843,
                "thumb_pdf_h": 1210,
                "permalink": "https:\/\/futureofcoding.slack.com\/files\/UK3LH8CF5\/F0387MV0NTT\/committees.pdf",
                "permalink_public": "https:\/\/slack-files.com\/T5TCAFTA9-F0387MV0NTT-07404292a8",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "user": "UK3LH8CF5",
        "display_as_bot": false,
        "ts": "1647816901.930409",
        "reactions": [
            {
                "name": "dart",
                "users": [
                    "U014WA16VNJ"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "UQ2P2BYJU"
                ],
                "count": 1
            }
        ]
    }
]