[
    {
        "type": "message",
        "text": "This is a great episode, with touches on many topics. One of them was so much in collision with my own ideas for the future of coding that I am tempted to launch a discussion on it. It's the notion of an \"escape hatch\" from a programming environment.\n\nOverall, there's too much of a \"let's build a universe\" attitude in computing, and the idea of a programming environment ideally being complete and mostly closed is a reflection of it. I don't want  an escape hatch for going elsewhere if I absolutely have to. I want bridges to other programming environments, for my own use and for connecting with other people's work.\n\nMy idea of the future of coding is more like living in physical space. I live in a house, which has multiple rooms. In some rooms, I do things alone, in others with family members. The house is part of a neighborhood, where I do things with neighbours. The neighborhood is part of a town, and so on. Each compartment provides just the right environment for some activity, but none locks me in, wishing for an escape hatch.",
        "user": "UJBAJNFLK",
        "ts": "1622882372.038900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "fallback": "[June 4th, 2021 3:26 AM] ivanreese: <https:\/\/futureofcoding.org\/episodes\/050|Episode 50> (:birthday:) of the Future of Coding podcast is out now.\n\nToday, the guest is <https:\/\/maryrosecook.com|Mary Rose Cook>, among whose thousand-and-one side projects you'll find <http:\/\/islalanguage.org|Isla> and <http:\/\/codelauren.com|Code Lauren>. Both are experimental programming environments with their own bespoke languages, focussed on learnability and visualization. In the case of Code Lauren, we also see another theme of Mary's work — taking the largely invisible processing done by compilers \/ interpreters and making it visible and interactive. Mary also made a totally awful game that I hate so much, but to find out what that is you'll just have to listen to the show (or read the largely unedited transcript — again, sorry Jack).",
                "ts": "1622769994.043600",
                "author_id": "UC2A2ARPT",
                "author_subname": "Ivan Reese",
                "channel_id": "CCL5VVBAN",
                "channel_name": "share-your-work",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "text": "<https:\/\/futureofcoding.org\/episodes\/050|Episode 50> (:birthday:) of the Future of Coding podcast is out now.\n\nToday, the guest is <https:\/\/maryrosecook.com|Mary Rose Cook>, among whose thousand-and-one side projects you'll find <http:\/\/islalanguage.org|Isla> and <http:\/\/codelauren.com|Code Lauren>. Both are experimental programming environments with their own bespoke languages, focussed on learnability and visualization. In the case of Code Lauren, we also see another theme of Mary's work — taking the largely invisible processing done by compilers \/ interpreters and making it visible and interactive. Mary also made a totally awful game that I hate so much, but to find out what that is you'll just have to listen to the show (or read the largely unedited transcript — again, sorry Jack).",
                "author_name": "Ivan Reese",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UC2A2ARPT",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1622769994043600?thread_ts=1622769994043600&cid=CCL5VVBAN",
                "is_share": true,
                "footer": "Thread in #share-your-work"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EGd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a great episode, with touches on many topics. One of them was so much in collision with my own ideas for the future of coding that I am tempted to launch a discussion on it. It's the notion of an \"escape hatch\" from a programming environment.\n\nOverall, there's too much of a \"let's build a universe\" attitude in computing, and the idea of a programming environment ideally being complete and mostly closed is a reflection of it. I don't want  an escape hatch for going elsewhere if I absolutely have to. I want bridges to other programming environments, for my own use and for connecting with other people's work.\n\nMy idea of the future of coding is more like living in physical space. I live in a house, which has multiple rooms. In some rooms, I do things alone, in others with family members. The house is part of a neighborhood, where I do things with neighbours. The neighborhood is part of a town, and so on. Each compartment provides just the right environment for some activity, but none locks me in, wishing for an escape hatch."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "reply_count": 13,
        "reply_users_count": 6,
        "latest_reply": "1623107771.092500",
        "reply_users": [
            "UCUSW7WVD",
            "UJBAJNFLK",
            "UDQBTJ211",
            "UML4ZEKDK",
            "UA14TGLTC",
            "U01U19ECZTJ"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1622903548.039100"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1622904867.039300"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1622908556.039700"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1622918641.040600"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1622926274.041100"
            },
            {
                "user": "UML4ZEKDK",
                "ts": "1622932397.041700"
            },
            {
                "user": "UML4ZEKDK",
                "ts": "1622933005.042200"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1622968614.044100"
            },
            {
                "user": "U01U19ECZTJ",
                "ts": "1623079262.078000"
            },
            {
                "user": "UML4ZEKDK",
                "ts": "1623082792.078700"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1623083577.079100"
            },
            {
                "user": "U01U19ECZTJ",
                "ts": "1623083964.079500"
            },
            {
                "user": "UML4ZEKDK",
                "ts": "1623107771.092500"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UE1JQM9HQ",
                    "UML4ZEKDK",
                    "UP00ZLX6G",
                    "U01TEJCSQ3Y",
                    "U019PRL1BNU"
                ],
                "count": 5
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7",
                    "UJ6LDMMN0",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "fda6ba1c-e250-4782-98f5-fec69c97d12c",
        "type": "message",
        "text": "Do you want existing software to have this room property? Or do you want some set of independent universes to choose \"standards for interoperability\"? I think we have the second already, and to the extent it fails it's because of the first problem. So let's talk about the first problem.\n\nBuilding a passage\/wormhole between two rooms\/universes is hard. Even for the programmers who built this one room you're in now. Nobody wants to make it easier, because that's even harder. Nobody wants it enough to put in the work, because everybody grew up living in a single room just like you. So it won't happen until somebody somewhere starts building it into software they didn't write, without asking for permission. We have to make it scalable to hack on unfamiliar codebases in incompatible ways.",
        "user": "UCUSW7WVD",
        "ts": "1622903548.039100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6lf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Do you want existing software to have this room property? Or do you want some set of independent universes to choose \"standards for interoperability\"? I think we have the second already, and to the extent it fails it's because of the first problem. So let's talk about the first problem.\n\nBuilding a passage\/wormhole between two rooms\/universes is hard. Even for the programmers who built this one room you're in now. Nobody wants to make it easier, because that's even harder. Nobody wants it enough to put in the work, because everybody grew up living in a single room just like you. So it won't happen until somebody somewhere starts building it into software they didn't write, without asking for permission. We have to make it scalable to hack on unfamiliar codebases in incompatible ways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "129111ed-191f-42ed-9e18-3f95585ad7e4",
        "type": "message",
        "text": "What I am hoping for as a first step is a change of attitude. Stop talking about escape hatches, start talking about bridges.\n\nYes, interoperability is hard, even more so if you want to retrofit it. So let's start with new environments, which is what many us in this space are working on or dreaming of.\n\nIt's actually happening. A nice example: <https:\/\/github.com\/JuliaInterop>. What I want is more of that. More effort for making systems interoperable.",
        "user": "UJBAJNFLK",
        "ts": "1622904867.039300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "Julia Interop",
                "title_link": "https:\/\/github.com\/JuliaInterop",
                "text": "Easy interoperability between Julia and not Julia. Julia Interop has 16 repositories available. Follow their code on GitHub.",
                "fallback": "GitHub: Julia Interop",
                "from_url": "https:\/\/github.com\/JuliaInterop",
                "thumb_url": "https:\/\/avatars.githubusercontent.com\/u\/20260648?s=280&v=4",
                "thumb_width": 159,
                "thumb_height": 159,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/JuliaInterop"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Y2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I am hoping for as a first step is a change of attitude. Stop talking about escape hatches, start talking about bridges.\n\nYes, interoperability is hard, even more so if you want to retrofit it. So let's start with new environments, which is what many us in this space are working on or dreaming of.\n\nIt's actually happening. A nice example: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/JuliaInterop"
                            },
                            {
                                "type": "text",
                                "text": ". What I want is more of that. More effort for making systems interoperable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "cf57db71-c249-4e25-ab23-6b2e9bbbd056",
        "type": "message",
        "text": "That library looks like an example of my second option. That can certainly work! It becomes a problem more of social organization, learning about n black boxes, getting them to interoperate, opening issues. Submitting patches to n black boxes has some scaling issues for most people.\n\n&gt; let's start with new environments\n\nDid you mean new environments interoperating with existing ones? That still has scaling issues if you care about multiple existing ones.\n\nNew environments interoperating with other new ones = hard yes! If anyone cares.",
        "user": "UCUSW7WVD",
        "ts": "1622908556.039700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LtrgH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That library looks like an example of my second option. That can certainly work! It becomes a problem more of social organization, learning about n black boxes, getting them to interoperate, opening issues. Submitting patches to n black boxes has some scaling issues for most people.\n\n> let's start with new environments\n\nDid you mean new environments interoperating with existing ones? That still has scaling issues if you care about multiple existing ones.\n\nNew environments interoperating with other new ones = hard yes! If anyone cares."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "0a01d17b-99f2-400b-ab8b-d83457e305fd",
        "type": "message",
        "text": "I think \"new interoperating with existing ones\" is the most reasonable starting point, because the new players have the highest motivation to connect to the \"old world\". As in the case of Julia. And yes, this has scaling issues. But if it leads to competitive advantages (\"I picked Julia because it has all those nice bridges to other languages\"), it can lead to the change of attitude that is needed.\n\nAll-to-all bridging without scaling issues requires infrastructure support, and then adoption of that infrastructure. The only attempt I am aware of is Oracle's GraalVM\/Truffle combo. Which requires re-implementing all languages, but apparently makes this relatively straightforward for JVM languages.",
        "user": "UJBAJNFLK",
        "ts": "1622918641.040600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gLfcB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think \"new interoperating with existing ones\" is the most reasonable starting point, because the new players have the highest motivation to connect to the \"old world\". As in the case of Julia. And yes, this has scaling issues. But if it leads to competitive advantages (\"I picked Julia because it has all those nice bridges to other languages\"), it can lead to the change of attitude that is needed.\n\nAll-to-all bridging without scaling issues requires infrastructure support, and then adoption of that infrastructure. The only attempt I am aware of is Oracle's GraalVM\/Truffle combo. Which requires re-implementing all languages, but apparently makes this relatively straightforward for JVM languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UML4ZEKDK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b34e6115-2e77-4c6f-8827-6f164cfe42c4",
        "type": "message",
        "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like. He was a language Cake which I haven't looked at but at first glance looks a bit like Cambria",
        "user": "UDQBTJ211",
        "ts": "1622926274.041100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3sy+X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like. He was a language Cake which I haven't looked at but at first glance looks a bit like Cambria"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "04112113-4ee1-4e2a-b314-0988ac6150a7",
        "type": "message",
        "text": "Although I mostly agree with your conclusions, I disagree with the premise:\n&gt; Clearly shared mutable state is not even negotiable in programming, otherwise we'd have no disks, no databases, no GUIs, no 3D worlds, no social media.. basically nothing apart from addition and the like.\nI would say that \"state\" is what's required to model dynamical systems. Physical systems have state. That's what's non-negotiable.\n\nThe term \"shared mutable state\" describes a particular way of modelling state in a programming language. It's the style of imperative\/object-oriented programming where you represent state using mutable global variables or shared mutable objects. In these languages, functions are not pure mathematical values, because they can contain internal references to mutable objects or mutable global variables, and calling a function can have the side effect of reading or writing shared mutable state. In these languages, data structures can contain references to shared mutable objects.  (The alternative is data structures whose elements are pure, immutable values.) This is what the word \"shared\" means in \"shared mutable state\".\n\nYou mention fallacies. The fallacies I've seen in internet discussions (not specifically in this thread) are:\n• That pure functional programming is impossible, if you want to write programs that manipulate external state. The best you can do is create a language with a large functional subset, but you still need shared mutable state to model external state, so you need a hybrid language to do anything practical.\n• That Haskell is a lie. It's impossible to write a pure functional program that does I\/O, you need side effects for that, and you need shared mutable state to interact with external state. Therefore Haskell has these features, even if the Haskell community denies it. Some weird type theoretic mumbo jumbo is being used to obscure what is really going on.\n• That there is no alternative to Haskell, and monads, and the IO monad, and tons of category theory, if you want to write pure functional programs that do I\/O or that process external state. \n• That imperative style programming is incompatible with pure functional programming. The FP police want to take away your mutable variables and while loops, and force you to learn tail recursion. Well yes, they do want to do that, but that's a cultural preference, it's not logically necessary. There is no conflict between imperative programming with mutable _local_ variables and while loops, vs pure functions. The caller of the function doesn't care how the loops are implemented internally. It is only mutable _global_ variables that cause observable side effects during a function call, and shared mutable state. You see, at one extreme, you have the FP police, who want to stamp out the sin of imperative programming. And at the other extreme, you have the imperative defenders, who point out that Haskell monadic programs (do expressions) look suspiciously like imperative programs, thereby \"proving\" that Haskell is a lie. I don't accept any of that.\nSomething that I think sustains these fallacies is that there is a serious shortage of good, practical, easy to use, easy to understand, general purpose languages for programming without shared mutable state. If such languages don't exist now, it's easy to imagine that they never will exist in the future. Haskell is frankly so overly complex, terrifying, dogmatic, and impractical that it casts a negative light on the field. Elm is pretty good: easy to learn and use, no shared mutable state and no monads, but it's a domain specific language that is only used for GUIs. So there is a lot of work to do, and new languages to design, before these ideas can become truly mainstream, before people stop claiming these ideas are impossible.\n\nWhat I would like to see, or what I would like to build if no one beats me to it, is an easy to learn and use, dynamically typed, image based, live programming environment similar to Smalltalk or Lisp, except with no shared mutable state. What makes this interesting is that Lisp was the original language where everything is an object reference, and Smalltalk took this idea even further with object oriented programming, where everything is a reference to a *mutable* object. So let's build the same kind of environment except without shared mutable state: just pure values and pure functions.\n\nMy goal in exploring these ideas is, I think, a bit different from the FP community. I want to make programming easier, and programs easier to understand. To accomplish that, I want to eliminate \"spooky action at a distance\", and eliminate the need for non-local reasoning when reading and writing programs and understanding their behaviour. Shared mutable state, as I have defined it, entails spooky action at a distance, it is very nonlocal, so I want to eliminate it for that reason. I'm not interested in \"mathematical purity\" as an end in itself.",
        "user": "UJN1TAYEQ",
        "ts": "1622930374.041300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n+AI8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Although I mostly agree with your conclusions, I disagree with the premise:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Clearly shared mutable state is not even negotiable in programming, otherwise we'd have no disks, no databases, no GUIs, no 3D worlds, no social media.. basically nothing apart from addition and the like."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would say that \"state\" is what's required to model dynamical systems. Physical systems have state. That's what's non-negotiable.\n\nThe term \"shared mutable state\" describes a particular way of modelling state in a programming language. It's the style of imperative\/object-oriented programming where you represent state using mutable global variables or shared mutable objects. In these languages, functions are not pure mathematical values, because they can contain internal references to mutable objects or mutable global variables, and calling a function can have the side effect of reading or writing shared mutable state. In these languages, data structures can contain references to shared mutable objects.  (The alternative is data structures whose elements are pure, immutable values.) This is what the word \"shared\" means in \"shared mutable state\".\n\nYou mention fallacies. The fallacies I've seen in internet discussions (not specifically in this thread) are:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "That pure functional programming is impossible, if you want to write programs that manipulate external state. The best you can do is create a language with a large functional subset, but you still need shared mutable state to model external state, so you need a hybrid language to do anything practical."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "That Haskell is a lie. It's impossible to write a pure functional program that does I\/O, you need side effects for that, and you need shared mutable state to interact with external state. Therefore Haskell has these features, even if the Haskell community denies it. Some weird type theoretic mumbo jumbo is being used to obscure what is really going on."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "That there is no alternative to Haskell, and monads, and the IO monad, and tons of category theory, if you want to write pure functional programs that do I\/O or that process external state. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "That imperative style programming is incompatible with pure functional programming. The FP police want to take away your mutable variables and while loops, and force you to learn tail recursion. Well yes, they do want to do that, but that's a cultural preference, it's not logically necessary. There is no conflict between imperative programming with mutable "
                                    },
                                    {
                                        "type": "text",
                                        "text": "local",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " variables and while loops, vs pure functions. The caller of the function doesn't care how the loops are implemented internally. It is only mutable "
                                    },
                                    {
                                        "type": "text",
                                        "text": "global",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " variables that cause observable side effects during a function call, and shared mutable state. You see, at one extreme, you have the FP police, who want to stamp out the sin of imperative programming. And at the other extreme, you have the imperative defenders, who point out that Haskell monadic programs (do expressions) look suspiciously like imperative programs, thereby \"proving\" that Haskell is a lie. I don't accept any of that."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSomething that I think sustains these fallacies is that there is a serious shortage of good, practical, easy to use, easy to understand, general purpose languages for programming without shared mutable state. If such languages don't exist now, it's easy to imagine that they never will exist in the future. Haskell is frankly so overly complex, terrifying, dogmatic, and impractical that it casts a negative light on the field. Elm is pretty good: easy to learn and use, no shared mutable state and no monads, but it's a domain specific language that is only used for GUIs. So there is a lot of work to do, and new languages to design, before these ideas can become truly mainstream, before people stop claiming these ideas are impossible.\n\nWhat I would like to see, or what I would like to build if no one beats me to it, is an easy to learn and use, dynamically typed, image based, live programming environment similar to Smalltalk or Lisp, except with no shared mutable state. What makes this interesting is that Lisp was the original language where everything is an object reference, and Smalltalk took this idea even further with object oriented programming, where everything is a reference to a "
                            },
                            {
                                "type": "text",
                                "text": "mutable",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " object. So let's build the same kind of environment except without shared mutable state: just pure values and pure functions.\n\nMy goal in exploring these ideas is, I think, a bit different from the FP community. I want to make programming easier, and programs easier to understand. To accomplish that, I want to eliminate \"spooky action at a distance\", and eliminate the need for non-local reasoning when reading and writing programs and understanding their behaviour. Shared mutable state, as I have defined it, entails spooky action at a distance, it is very nonlocal, so I want to eliminate it for that reason. I'm not interested in \"mathematical purity\" as an end in itself."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622048775.021900",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UML4ZEKDK",
                    "UJBAJNFLK",
                    "UC2A2ARPT",
                    "UHWC9PXBL",
                    "UD3AK9JRF"
                ],
                "count": 6
            }
        ]
    },
    {
        "client_msg_id": "0ae4552c-7bdd-4864-b8ba-ca227e003081",
        "type": "message",
        "text": "&gt; I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like.\nWhen I first read Stephen's paper, it was quite an eye-opening moment for me... :smile: It pushed me to start a community to share and discuss ideas like this around user control and interoperability. Perhaps some other resources in the catalog there (<https:\/\/malleable.systems\/catalog\/>) will be of interest as well.",
        "user": "UML4ZEKDK",
        "ts": "1622932397.041700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gda74cfd81f8",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/da74cfd81f892e34f7e3926f2c56f908.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "J.",
            "real_name": "J. Ryan Stinnett",
            "display_name": "J. Ryan Stinnett",
            "team": "T5TCAFTA9",
            "name": "jryans",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UML4ZEKDK",
            "ts": "1622932422.000000"
        },
        "attachments": [
            {
                "title": "Catalog | Malleable Systems Collective",
                "title_link": "https:\/\/malleable.systems\/catalog\/",
                "text": "The Malleable Systems Collective catalogs and experiments with malleable software and systems that reset the balance of power in computing",
                "fallback": "Catalog | Malleable Systems Collective",
                "thumb_url": "https:\/\/malleable.systems\/meta\/android-chrome-512x512.png",
                "from_url": "https:\/\/malleable.systems\/catalog\/",
                "thumb_width": 512,
                "thumb_height": 512,
                "service_icon": "https:\/\/malleable.systems\/meta\/apple-touch-icon.png",
                "service_name": "malleable.systems",
                "id": 1,
                "original_url": "https:\/\/malleable.systems\/catalog\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U44o\/",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I first read Stephen's paper, it was quite an eye-opening moment for me... "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " It pushed me to start a community to share and discuss ideas like this around user control and interoperability. Perhaps some other resources in the catalog there ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/malleable.systems\/catalog\/"
                            },
                            {
                                "type": "text",
                                "text": ") will be of interest as well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "5318bbff-568e-407f-aa71-b8b3d3d77852",
        "type": "message",
        "text": "There's a painful absence of tooling for the \"integration domain\" (as Stephen calls it) in software today. Such tools would connect and unify existing languages, ecosystems, and modules, just like the wires in circuit design: they unify parts from many different sources into something new without requiring coordination or agreement between the parts themselves.\n\nIf it were (on the order of) adding wires from module \/ language A to B, we'd see an explosion of software reuse. It should not matter what language some useful bit of code is written in, but unfortunately today, language boundaries create high walls.",
        "user": "UML4ZEKDK",
        "ts": "1622933005.042200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gda74cfd81f8",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/da74cfd81f892e34f7e3926f2c56f908.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "J.",
            "real_name": "J. Ryan Stinnett",
            "display_name": "J. Ryan Stinnett",
            "team": "T5TCAFTA9",
            "name": "jryans",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qJG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's a painful absence of tooling for the \"integration domain\" (as Stephen calls it) in software today. Such tools would connect and unify existing languages, ecosystems, and modules, just like the wires in circuit design: they unify parts from many different sources into something new without requiring coordination or agreement between the parts themselves.\n\nIf it were (on the order of) adding wires from module \/ language A to B, we'd see an explosion of software reuse. It should not matter what language some useful bit of code is written in, but unfortunately today, language boundaries create high walls."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK",
                    "UA14TGLTC",
                    "U0112C10V4Y",
                    "U014WA16VNJ"
                ],
                "count": 4
            }
        ]
    }
]