[
    {
        "client_msg_id": "878cb8eb-90af-4a26-a68d-f73e85f5d001",
        "type": "message",
        "text": "What would a language that \"always compiles\" and \"never crashes\" look like? Where there is no such thing as a syntax error, type error, or runtime error? Where every text string (or AST) is executable? I'm thinking this can be done with a compositional approach to errors: instead of crashing when a result is undefined (due to syntactic or semantic errors), return an \"undefined\" value, which in turn poisons all of the expressions it is used within, similar to how NaN works. Would such a semantics have merit? It would let you run incomplete programs (like <https:\/\/hazel.org\/|Hazel>), and also let you _recover_ from errors (with the equivalent of an isNaN() function). But perhaps most importantly, it would be a good foundation for a _live &amp; persistent programming environment:_ if there is no need for code to be checked prior to execution, then there doesn't need to be a \"compile time\". This doesn't make programs harder to reason about: a programmer can still use static analysis tools (incl. \"type inference\") to understand and _enforce_ runtime behaviour (e.g. verifying\/requiring the absence of \"undefined\").",
        "user": "UCGAK10LS",
        "ts": "1612656314.123000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1612656866.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9Ebg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What would a language that \"always compiles\" and \"never crashes\" look like? Where there is no such thing as a syntax error, type error, or runtime error? Where every text string (or AST) is executable? I'm thinking this can be done with a compositional approach to errors: instead of crashing when a result is undefined (due to syntactic or semantic errors), return an \"undefined\" value, which in turn poisons all of the expressions it is used within, similar to how NaN works. Would such a semantics have merit? It would let you run incomplete programs (like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/hazel.org\/",
                                "text": "Hazel"
                            },
                            {
                                "type": "text",
                                "text": "), and also let you "
                            },
                            {
                                "type": "text",
                                "text": "recover",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " from errors (with the equivalent of an isNaN() function). But perhaps most importantly, it would be a good foundation for a "
                            },
                            {
                                "type": "text",
                                "text": "live & persistent programming environment:",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " if there is no need for code to be checked prior to execution, then there doesn't need to be a \"compile time\". This doesn't make programs harder to reason about: a programmer can still use static analysis tools (incl. \"type inference\") to understand and "
                            },
                            {
                                "type": "text",
                                "text": "enforce",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " runtime behaviour (e.g. verifying\/requiring the absence of \"undefined\")."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "reply_count": 28,
        "reply_users_count": 10,
        "latest_reply": "1612941084.145400",
        "reply_users": [
            "UMVFWPZ36",
            "UCGAK10LS",
            "U01L1TTFP62",
            "U016VUZGUUQ",
            "UAVCC2X70",
            "UDQBTJ211",
            "UF71PR58X",
            "UHWC9PXBL",
            "U016LEA3J1H",
            "UDQKHNP51"
        ],
        "replies": [
            {
                "user": "UMVFWPZ36",
                "ts": "1612657435.123500"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1612657439.123700"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1612657481.123900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612657647.124200"
            },
            {
                "user": "U01L1TTFP62",
                "ts": "1612657726.124400"
            },
            {
                "user": "U01L1TTFP62",
                "ts": "1612657826.124600"
            },
            {
                "user": "U01L1TTFP62",
                "ts": "1612657989.124900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612659051.125300"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612663797.125800"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1612664009.126000"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1612664472.126300"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612664556.126500"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612664675.126700"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1612676446.127600"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1612677439.128100"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1612689178.130800"
            },
            {
                "user": "UF71PR58X",
                "ts": "1612717793.131300"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1612722075.132700"
            },
            {
                "user": "U016LEA3J1H",
                "ts": "1612734749.133000"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1612735490.133200"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612747339.133800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612747414.134200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1612772658.135200"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1612802542.135800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1612838391.136300"
            },
            {
                "user": "UDQKHNP51",
                "ts": "1612865794.136600"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1612939912.145200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1612941084.145400"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01L1TTFP62",
                    "UAVCC2X70"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "9a20d468-4351-4132-838c-5ce70fc9aa98",
        "type": "message",
        "text": "This pattern is common in dataflow languages",
        "user": "UMVFWPZ36",
        "ts": "1612657435.123500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "macR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This pattern is common in dataflow languages"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0b5686b4-33ed-4efb-a12a-d3ac90e20df2",
        "type": "message",
        "text": "I also think they do it in go",
        "user": "UMVFWPZ36",
        "ts": "1612657439.123700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "43F0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also think they do it in go"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "32b9e0f6-e8de-41c0-a956-228501f7d3f9",
        "type": "message",
        "text": "see <https:\/\/blog.golang.org\/errors-are-values>",
        "user": "UMVFWPZ36",
        "ts": "1612657481.123900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Errors are values - The Go Blog",
                "title_link": "https:\/\/blog.golang.org\/errors-are-values",
                "text": "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.",
                "fallback": "Errors are values - The Go Blog",
                "from_url": "https:\/\/blog.golang.org\/errors-are-values",
                "service_icon": "https:\/\/blog.golang.org\/favicon.ico",
                "service_name": "blog.golang.org",
                "id": 1,
                "original_url": "https:\/\/blog.golang.org\/errors-are-values"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "owZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "see "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/blog.golang.org\/errors-are-values"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "fbfb8688-8c91-450e-a0b7-8aee4631a581",
        "type": "message",
        "text": "The title of that Go post is perhaps deceiving, since their approach to errors is just the same old approach that C code uses: an error is a separate return value that must be checked in order to be noticed. It is not compositional, and Go programs still crash in a myriad of ways.",
        "user": "UCGAK10LS",
        "ts": "1612657647.124200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1612657850.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O6XTh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The title of that Go post is perhaps deceiving, since their approach to errors is just the same old approach that C code uses: an error is a separate return value that must be checked in order to be noticed. It is not compositional, and Go programs still crash in a myriad of ways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0658feac-1a49-40a4-96d7-d88c5ee70632",
        "type": "message",
        "text": "LabVIEW (a dataflow language) has errors that are just another value returned, although it does not always compile because it runs a type propagation algorithm that will break your code if the types don't match up. But it is always compiling in the background, ready to run if it can. If an error is returned, the program doesn't crash and they aren't exceptions. You can ignore the error, process it, generate a more specific one, etc. However, it still has the problem of the developer not knowing what errors could be generated, which is a problem in every language I have ever used, and a tough problem.\n\nI'd love a language that specifically separated functions between those that can and cannot return errors. Functions that can return errors should return them as values and the documentation should list exactly why and when an error is returned. Additionally, the errors should be pattern matchable.",
        "user": "U01L1TTFP62",
        "ts": "1612657726.124400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "dc9ee60375b5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-29\/1687447231174_dc9ee60375b5ce940578_72.png",
            "first_name": "",
            "real_name": "bmitc",
            "display_name": "bmitc",
            "team": "T5TCAFTA9",
            "name": "bmitchell33",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/V2I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "LabVIEW (a dataflow language) has errors that are just another value returned, although it does not always compile because it runs a type propagation algorithm that will break your code if the types don't match up. But it is always compiling in the background, ready to run if it can. If an error is returned, the program doesn't crash and they aren't exceptions. You can ignore the error, process it, generate a more specific one, etc. However, it still has the problem of the developer not knowing what errors could be generated, which is a problem in every language I have ever used, and a tough problem.\n\nI'd love a language that specifically separated functions between those that can and cannot return errors. Functions that can return errors should return them as values and the documentation should list exactly why and when an error is returned. Additionally, the errors should be pattern matchable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5ae2c4d9-6d57-4015-bb3a-64523c808b98",
        "type": "message",
        "text": "I need to go through The Common Lisp Condition System book: <https:\/\/www.amazon.com\/Common-Lisp-Condition-System-Mechanisms\/dp\/148426133X>",
        "user": "U01L1TTFP62",
        "ts": "1612657826.124600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "dc9ee60375b5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-29\/1687447231174_dc9ee60375b5ce940578_72.png",
            "first_name": "",
            "real_name": "bmitc",
            "display_name": "bmitc",
            "team": "T5TCAFTA9",
            "name": "bmitchell33",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pFZi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I need to go through The Common Lisp Condition System book: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.amazon.com\/Common-Lisp-Condition-System-Mechanisms\/dp\/148426133X"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6c996b87-e893-4fa6-966f-e10e70ad6597",
        "type": "message",
        "text": "Thanks for the link to Hazel <@UCGAK10LS>. That seems interesting.\n\nThere's also the approach of Elixir and Erlang that take the stance that errors are unavoidable, so they provide mechanisms to recover when they do happen, including live inspection. (Which is what I understand the Common Lisp condition system to address.)",
        "user": "U01L1TTFP62",
        "ts": "1612657989.124900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "dc9ee60375b5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-29\/1687447231174_dc9ee60375b5ce940578_72.png",
            "first_name": "",
            "real_name": "bmitc",
            "display_name": "bmitc",
            "team": "T5TCAFTA9",
            "name": "bmitchell33",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2KD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the link to Hazel "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": ". That seems interesting.\n\nThere's also the approach of Elixir and Erlang that take the stance that errors are unavoidable, so they provide mechanisms to recover when they do happen, including live inspection. (Which is what I understand the Common Lisp condition system to address.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "20cf7efd-1208-470c-b4fc-d55916404854",
        "type": "message",
        "text": "&gt; I'd love a language that specifically separated functions between those that can and cannot return errors.\nMost functions beyond the identity function and constants can return errors: you simply have to pass them a value that is not part of their domain :slightly_smiling_face:. Sometimes the domain is tricky: for example the *div* instruction takes all numeric divisors apart from zero, and it's often hard to statically verify that zero won't be given. That's perhaps the simplest use-case for an \"undefined\" return value.\n\nBut if a value is explicitly considered part of the domain, yet can still induce some \"error-like\" result (for example, failure to pass a JSON string), then I agree they should probably return a _specific_ error value that distinguishes this class of error from the more general \"I passed a string to a function expecting an integer\" undefined result.",
        "user": "UCGAK10LS",
        "ts": "1612659051.125300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1612663253.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WSuiN",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd love a language that specifically separated functions between those that can and cannot return errors."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most functions beyond the identity function and constants can return errors: you simply have to pass them a value that is not part of their domain "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". Sometimes the domain is tricky: for example the "
                            },
                            {
                                "type": "text",
                                "text": "div",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instruction takes all numeric divisors apart from zero, and it's often hard to statically verify that zero won't be given. That's perhaps the simplest use-case for an \"undefined\" return value.\n\nBut if a value is explicitly considered part of the domain, yet can still induce some \"error-like\" result (for example, failure to pass a JSON string), then I agree they should probably return a "
                            },
                            {
                                "type": "text",
                                "text": "specific",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " error value that distinguishes this class of error from the more general \"I passed a string to a function expecting an integer\" undefined result."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "131ae1ca-ab29-4a4a-b622-4dd70a9e69f7",
        "type": "message",
        "text": "Of course, \"specific error values\" are implemented in modern languages as *sum types*, enabling pattern matching etc. But they unfortunately aren't compositional: what happens if you try and sum a \"parsing error\" and an \"I\/O error\" together? That's where having a single NaN-like \"undefined\" value might come in handy: it just declares that an expression was given inputs outside its domain.\n\"parsing error\" + \"I\/O error\" = \"undefined\"",
        "user": "UCGAK10LS",
        "ts": "1612663797.125800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R3Eot",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Of course, \"specific error values\" are implemented in modern languages as "
                            },
                            {
                                "type": "text",
                                "text": "sum types",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", enabling pattern matching etc. But they unfortunately aren't compositional: what happens if you try and sum a \"parsing error\" and an \"I\/O error\" together? That's where having a single NaN-like \"undefined\" value might come in handy: it just declares that an expression was given inputs outside its domain.\n\"parsing error\" + \"I\/O error\" = \"undefined\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7685c294-093e-49d7-be25-45488dab4fdf",
        "type": "message",
        "text": "Runtime errors are a fundamentally optional concept. There's not necessarily a concept of an error in a Turing machine: the closest thing is if you hit a gap in your transition table, but you can fill those in with any default that strikes your fancy. In a more conventionally shaped language, that probably means ignoring or no-opping any state or operation you don't understand.... so yeah, it looks like JavaScript, but more so.\n\nI haven't tried it, but <http:\/\/om-language.org|om-language.org> claims to have the property that all UTF-8 strings are valid OM programs. Unclear how it handles errors, but the words \"error\", \"fail\", \"halt\", and \"stop\" are absent from its front page.",
        "user": "U016VUZGUUQ",
        "ts": "1612664009.126000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kcs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Runtime errors are a fundamentally optional concept. There's not necessarily a concept of an error in a Turing machine: the closest thing is if you hit a gap in your transition table, but you can fill those in with any default that strikes your fancy. In a more conventionally shaped language, that probably means ignoring or no-opping any state or operation you don't understand.... so yeah, it looks like JavaScript, but more so.\n\nI haven't tried it, but "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/om-language.org",
                                "text": "om-language.org"
                            },
                            {
                                "type": "text",
                                "text": " claims to have the property that all UTF-8 strings are valid OM programs. Unclear how it handles errors, but the words \"error\", \"fail\", \"halt\", and \"stop\" are absent from its front page."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS",
                    "U01AD80KMLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "737a6647-7f27-4d16-80c1-e9251b6b3edb",
        "type": "message",
        "text": "For a live programming environment, rather than propagating poison values, the behavior I would rather see is this: at the first sign of trouble, save the continuation (and maybe a bit before that?) and pop up an interactive prompt to get a valid value from the user, and call the continuation with that value. (With the right UI, I think this is approximately the right model for mixing automatic and human-driven work in general)",
        "user": "U016VUZGUUQ",
        "ts": "1612664472.126300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dejT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For a live programming environment, rather than propagating poison values, the behavior I would rather see is this: at the first sign of trouble, save the continuation (and maybe a bit before that?) and pop up an interactive prompt to get a valid value from the user, and call the continuation with that value. (With the right UI, I think this is approximately the right model for mixing automatic and human-driven work in general)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d94e9376-a778-48be-8323-e07c0fc49685",
        "type": "message",
        "text": "I think an absent transition in a Turing machine should be considered the same as crashing: the machine cannot proceed from that point. Looking more broadly at imperative languages, it's probably only those with _structured_ control flow can \"back out\" and continue after an error: just jump past\/out of the current structure (block, function, etc). Turing machines don't really have a good option.\n\nI should point out though, that I was specifically thinking about *declarative languages* (those based on composable expressions) as I wrote my original post.\n\nI'll check out Om :slightly_smiling_face:",
        "user": "UCGAK10LS",
        "ts": "1612664556.126500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1612665078.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kGATo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think an absent transition in a Turing machine should be considered the same as crashing: the machine cannot proceed from that point. Looking more broadly at imperative languages, it's probably only those with "
                            },
                            {
                                "type": "text",
                                "text": "structured",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " control flow can \"back out\" and continue after an error: just jump past\/out of the current structure (block, function, etc). Turing machines don't really have a good option.\n\nI should point out though, that I was specifically thinking about "
                            },
                            {
                                "type": "text",
                                "text": "declarative languages",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (those based on composable expressions) as I wrote my original post.\n\nI'll check out Om "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "fff69b06-3b89-4ade-b514-752c598f4fc0",
        "type": "message",
        "text": "<@U016VUZGUUQ> When I say \"live programming\" I don't mean that the user is always sitting at the computer while execution occurs, I just mean that code is immediately evaluated as it is written (and as new inputs come in), and the code doesn't \"restart\" unless specifically asked. I'd still want someone to be able to write a cloud service using such an environment, so interactive error resolution wouldn't be practical.",
        "user": "UCGAK10LS",
        "ts": "1612664675.126700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1612664744.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T3co",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " When I say \"live programming\" I don't mean that the user is always sitting at the computer while execution occurs, I just mean that code is immediately evaluated as it is written (and as new inputs come in), and the code doesn't \"restart\" unless specifically asked. I'd still want someone to be able to write a cloud service using such an environment, so interactive error resolution wouldn't be practical."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "93b26055-d509-4f18-92c4-8eb5e2d06da9",
        "type": "message",
        "text": "A language consisting only of \"print\" statements. And since that is the only operation, the syntax for a print statement is just the text to be printed. Each statement is on its own line. Each statement prints a new line of text. The statement to print an empty line of text, is an empty line of text.\n\nThis language has well defined syntax and semantics, and every input program is valid.",
        "user": "UAVCC2X70",
        "ts": "1612676446.127600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1612676710.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R+nl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A language consisting only of \"print\" statements. And since that is the only operation, the syntax for a print statement is just the text to be printed. Each statement is on its own line. Each statement prints a new line of text. The statement to print an empty line of text, is an empty line of text.\n\nThis language has well defined syntax and semantics, and every input program is valid."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01AD80KMLK"
                ],
                "count": 1
            },
            {
                "name": "zany_face",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9209ffb9-46dd-4a30-a3b5-7a51bea13158",
        "type": "message",
        "text": "On a more serious note, how about one that stubbornly continues to parse the current \"token\" or construct until it hits a well-defined delimiter? Things with special syntax take a default meaning if they don't match.\n\nFor example:\n\n\" starts a string, and includes anything until the next \". Invalid escaped characters fall back to their literal representation.\n\nA block starts with BEGIN and indescriminantly includes everything until an END is correctly matched.\n\nUnrecognized or unexpected tokens are simply skipped over. So assuming the closing-parenthesis is expected, A(B,C) is the same as A(B,C,+$4:\"\/:upside_down_face:¶\nEND\n{¢=]X)\n\nUnrecognized variables become NULL (what could possibly go wrong there? :wink:)",
        "user": "UAVCC2X70",
        "ts": "1612677439.128100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1612677885.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8L1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On a more serious note, how about one that stubbornly continues to parse the current \"token\" or construct until it hits a well-defined delimiter? Things with special syntax take a default meaning if they don't match.\n\nFor example:\n\n\" starts a string, and includes anything until the next \". Invalid escaped characters fall back to their literal representation.\n\nA block starts with BEGIN and indescriminantly includes everything until an END is correctly matched.\n\nUnrecognized or unexpected tokens are simply skipped over. So assuming the closing-parenthesis is expected, A(B,C) is the same as A(B,C,+$4:\"\/"
                            },
                            {
                                "type": "emoji",
                                "name": "upside_down_face"
                            },
                            {
                                "type": "text",
                                "text": "¶\nEND\n{¢=]X)\n\nUnrecognized variables become NULL (what could possibly go wrong there? "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9246d616-5584-40a1-a3d0-f3ec90339e4f",
        "type": "message",
        "text": "At the start of my career, I committed to muscle memory the sequence of keyboard keys to navigate from windows-start through the submenus, and select the right command. Until one day a coworker finally picked up on this and said, \"You know you can just press [Windows key]+L?\" ... Good to know!",
        "user": "UAVCC2X70",
        "ts": "1612678609.129800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1612678672.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MtO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At the start of my career, I committed to muscle memory the sequence of keyboard keys to navigate from windows-start through the submenus, and select the right command. Until one day a coworker finally picked up on this and said, \"You know you can just press [Windows key]+L?\" ... Good to know!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612400942.093500",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "f7552890-007f-4e8e-b5a0-44d9b3f715e3",
        "type": "message",
        "text": "This seems relevant:\n<https:\/\/m.xkcd.com\/378\/|https:\/\/m.xkcd.com\/378\/>",
        "user": "UAVCC2X70",
        "ts": "1612678783.130200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Real Programmers",
                "title_link": "https:\/\/xkcd.com\/378\/",
                "author_name": "xkcd",
                "author_link": "https:\/\/xkcd.com\/",
                "image_url": "https:\/\/imgs.xkcd.com\/comics\/real_programmers.png",
                "image_width": 740,
                "image_height": 406,
                "image_bytes": 84499,
                "text": "[Title text] \"Real programmers set the universal constants at the start such that the universe evolves to contain the disk with the data they want.\"",
                "fallback": "xkcd: Real Programmers",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/xkcd.png",
                "id": 1,
                "original_url": "https:\/\/m.xkcd.com\/378\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OGV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This seems relevant:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/m.xkcd.com\/378\/",
                                "text": "https:\/\/m.xkcd.com\/378\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612400942.093500",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5bb3313f-8ced-4a0e-aa82-a1b69c530bd1",
        "type": "message",
        "text": "Most form-like interfaces. I'm serious!",
        "user": "UAVCC2X70",
        "ts": "1612678909.130500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "r7PD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most form-like interfaces. I'm serious!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612462643.103300",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    }
]