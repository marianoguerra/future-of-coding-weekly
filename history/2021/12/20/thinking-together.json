[
    {
        "client_msg_id": "614cc869-bacf-4a17-b878-e1ef472fd841",
        "type": "message",
        "text": "looks like this could be interesting for you, but I'm not on the topic so cant say for sure\n<https:\/\/futureofcoding.slack.com\/archives\/C0120A3L30R\/p1639986127090700>",
        "user": "U02PUDETGRW",
        "ts": "1640008135.296400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "62d5c0083caf",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-01\/2799368556017_62d5c0083caff61eeaaa_72.jpg",
            "first_name": "Alex",
            "real_name": "Alex Bender",
            "display_name": "Alex Bender",
            "team": "T5TCAFTA9",
            "name": "axbndr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C0120A3L30R\/p1639986127090700",
                "ts": "1639986127.090700",
                "author_id": "UPX3PH28N",
                "channel_team": "T5TCAFTA9",
                "channel_id": "C0120A3L30R",
                "channel_name": "two-minute-week",
                "is_msg_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "C0120A3L30R",
                        "ts": "1639986127.090700",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "+Pd",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "emoji",
                                                    "name": "tada"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": " I finally "
                                                },
                                                {
                                                    "type": "text",
                                                    "text": "finished the IR refactoring",
                                                    "style": {
                                                        "bold": true
                                                    }
                                                },
                                                {
                                                    "type": "text",
                                                    "text": " after struggling with it for the last three weeks. I have decided to go without CPS as I understood that CPS is better suited for later stages of compilation.\n\nI have also discovered "
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https:\/\/www.youtube.com\/watch?v=Ntj8ab-5cvE",
                                                    "text": "Swift Intermediate Language (SIL)"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": ", which inspired my IR design quite a bit. And I found "
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https:\/\/github.com\/bytecodealliance\/wasmtime\/tree\/main\/cranelift",
                                                    "text": "Cranelift"
                                                },
                                                {
                                                    "type": "text",
                                                    "text": ", a compiler framework (like LLVM) that focuses on JIT compilation—it might be a good target to support in the future.\n\n"
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https:\/\/www.alexeyshmalko.com\/alpha-7\/"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C0120A3L30R\/p1639986127090700",
                "fallback": "[December 19th, 2021 11:42 PM] rasen.dubi: :tada: I finally *finished the IR refactoring* after struggling with it for the last three weeks. I have decided to go without CPS as I understood that CPS is better suited for later stages of compilation.\n\nI have also discovered <https:\/\/www.youtube.com\/watch?v=Ntj8ab-5cvE|Swift Intermediate Language (SIL)>, which inspired my IR design quite a bit. And I found <https:\/\/github.com\/bytecodealliance\/wasmtime\/tree\/main\/cranelift|Cranelift>, a compiler framework (like LLVM) that focuses on JIT compilation—it might be a good target to support in the future.\n\n<https:\/\/www.alexeyshmalko.com\/alpha-7\/>",
                "text": ":tada: I finally *finished the IR refactoring* after struggling with it for the last three weeks. I have decided to go without CPS as I understood that CPS is better suited for later stages of compilation.\n\nI have also discovered <https:\/\/www.youtube.com\/watch?v=Ntj8ab-5cvE|Swift Intermediate Language (SIL)>, which inspired my IR design quite a bit. And I found <https:\/\/github.com\/bytecodealliance\/wasmtime\/tree\/main\/cranelift|Cranelift>, a compiler framework (like LLVM) that focuses on JIT compilation—it might be a good target to support in the future.\n\n<https:\/\/www.alexeyshmalko.com\/alpha-7\/>",
                "author_name": "Alexey Shmalko",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UPX3PH28N",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/58ad4af42f7cff8698951a7befb26f0f.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-48.png",
                "author_subname": "Alexey Shmalko",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Posted in #two-minute-week"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J1ApJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "looks like this could be interesting for you, but I'm not on the topic so cant say for sure\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C0120A3L30R\/p1639986127090700"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1639974030.295800",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "5f1d1a05-35c3-40ae-b65e-f1867bf76f45",
        "type": "message",
        "text": "In Unix <https:\/\/en.wikipedia.org\/wiki\/Everything_is_a_file|everything is a file> which makes allows simple, reusable tools like `ls`, `cd`, `cat`, etc to be used across the whole system. However, files have their drawbacks as well: primarily that they're difficult to merge or detect changes which is useful for syncing, collaborating,  and\/or subscribing to data.\n\nHas anyone seen any alternatives to this paradigm? My startup is currently exploring the idea of append-only logs as our core primitive instead of files. We're not building a new kernel but we're attempting to create a new programming environment with collaboration and reactivity as core tenants. Would love to hear other perspectives on the subject!",
        "user": "U02C3SH9L2J",
        "ts": "1640016053.303100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1de4791b2cc3",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-20\/2888348949616_1de4791b2cc3996ef56c_72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Linkous",
            "display_name": "Matthew Linkous",
            "team": "T5TCAFTA9",
            "name": "matt386",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hejlj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Unix "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Everything_is_a_file",
                                "text": "everything is a file"
                            },
                            {
                                "type": "text",
                                "text": " which makes allows simple, reusable tools like "
                            },
                            {
                                "type": "text",
                                "text": "ls",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "cd",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "cat",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", etc to be used across the whole system. However, files have their drawbacks as well: primarily that they're difficult to merge or detect changes which is useful for syncing, collaborating,  and\/or subscribing to data.\n\nHas anyone seen any alternatives to this paradigm? My startup is currently exploring the idea of append-only logs as our core primitive instead of files. We're not building a new kernel but we're attempting to create a new programming environment with collaboration and reactivity as core tenants. Would love to hear other perspectives on the subject!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "reply_count": 10,
        "reply_users_count": 4,
        "latest_reply": "1640644479.331300",
        "reply_users": [
            "U02JDAYKW7J",
            "U02C3SH9L2J",
            "U85HCL7JP",
            "U02E4DAQGSZ"
        ],
        "replies": [
            {
                "user": "U02JDAYKW7J",
                "ts": "1640018516.303300"
            },
            {
                "user": "U02JDAYKW7J",
                "ts": "1640018841.303600"
            },
            {
                "user": "U02C3SH9L2J",
                "ts": "1640019139.303800"
            },
            {
                "user": "U02C3SH9L2J",
                "ts": "1640019631.304000"
            },
            {
                "user": "U02JDAYKW7J",
                "ts": "1640020041.304600"
            },
            {
                "user": "U02C3SH9L2J",
                "ts": "1640021340.304800"
            },
            {
                "user": "U02C3SH9L2J",
                "ts": "1640021679.305000"
            },
            {
                "user": "U85HCL7JP",
                "ts": "1640044836.305300"
            },
            {
                "user": "U02C3SH9L2J",
                "ts": "1640091716.305700"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1640644479.331300"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "05065851-609c-4418-aec7-ccc30b41fcc2",
        "type": "message",
        "text": "<@U02C3SH9L2J> some of this thread is likely relevant to you: <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1636714161079200>",
        "user": "U02JDAYKW7J",
        "ts": "1640018516.303300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1ab8763ceb21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-14\/2826386958343_1ab8763ceb219317febf_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Krasner",
            "display_name": "Daniel Krasner",
            "team": "T5TCAFTA9",
            "name": "krasnerdaniel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1636714161079200",
                "ts": "1636714161.079200",
                "author_id": "UJBAJNFLK",
                "channel_team": "T5TCAFTA9",
                "channel_id": "C5T9GPWFL",
                "channel_name": "thinking-together",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "C5T9GPWFL",
                        "ts": "1636714161.079200",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "=Yo",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "A recurrent topic in this community is \"Why do today's programming system so strongly rely on text files, and can we do better?\" This tweet made me think of a possible answer: epistemic transparence (of text) vs. epistemic opacity (of data formats requiring more specialized tools for inspection). We have so many tools for inspecting text files that it's hard to imagine that someone could sneak in a tool that deliberately misrepresents the information in a file. Human-readable data encodings in text files thus provide acces to a shared ground truth. The tools intermediating between bits in memory and UIs (screens etc.) are so simple that they are easy to understand and easy to verify and validate. Even for relatively simple structured binary formats such as tar, this is no longer true.\n"
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https:\/\/twitter.com\/slpnix\/status\/1457642326956855296"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1636714161079200",
                "fallback": "[November 12th, 2021 2:49 AM] konrad.hinsen: A recurrent topic in this community is \"Why do today's programming system so strongly rely on text files, and can we do better?\" This tweet made me think of a possible answer: epistemic transparence (of text) vs. epistemic opacity (of data formats requiring more specialized tools for inspection). We have so many tools for inspecting text files that it's hard to imagine that someone could sneak in a tool that deliberately misrepresents the information in a file. Human-readable data encodings in text files thus provide acces to a shared ground truth. The tools intermediating between bits in memory and UIs (screens etc.) are so simple that they are easy to understand and easy to verify and validate. Even for relatively simple structured binary formats such as tar, this is no longer true.\n<https:\/\/twitter.com\/slpnix\/status\/1457642326956855296>",
                "text": "A recurrent topic in this community is \"Why do today's programming system so strongly rely on text files, and can we do better?\" This tweet made me think of a possible answer: epistemic transparence (of text) vs. epistemic opacity (of data formats requiring more specialized tools for inspection). We have so many tools for inspecting text files that it's hard to imagine that someone could sneak in a tool that deliberately misrepresents the information in a file. Human-readable data encodings in text files thus provide acces to a shared ground truth. The tools intermediating between bits in memory and UIs (screens etc.) are so simple that they are easy to understand and easy to verify and validate. Even for relatively simple structured binary formats such as tar, this is no longer true.\n<https:\/\/twitter.com\/slpnix\/status\/1457642326956855296>",
                "author_name": "Konrad Hinsen",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UJBAJNFLK",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_48.png",
                "author_subname": "Konrad Hinsen",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in #thinking-together"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tzO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02C3SH9L2J"
                            },
                            {
                                "type": "text",
                                "text": " some of this thread is likely relevant to you: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1636714161079200"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U02C3SH9L2J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "504dd1f4-e881-45b3-9023-76a26136e933",
        "type": "message",
        "text": "but in general there are many great systems out there which have gone past the teletype\/terminal and punch card stack\/file model of programming and dealing with information. Smalltalk is one example or NLS for a more historical one.",
        "user": "U02JDAYKW7J",
        "ts": "1640018841.303600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1ab8763ceb21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-14\/2826386958343_1ab8763ceb219317febf_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Krasner",
            "display_name": "Daniel Krasner",
            "team": "T5TCAFTA9",
            "name": "krasnerdaniel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cscD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but in general there are many great systems out there which have gone past the teletype\/terminal and punch card stack\/file model of programming and dealing with information. Smalltalk is one example or NLS for a more historical one."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "98632cba-d59f-47b5-a5d3-a657b2c4413d",
        "type": "message",
        "text": "Ah yes Smalltalk is a great example. Having the file not be the single source of truth but instead an optional artifact of your program is an interesting concept.",
        "user": "U02C3SH9L2J",
        "ts": "1640019139.303800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1de4791b2cc3",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-20\/2888348949616_1de4791b2cc3996ef56c_72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Linkous",
            "display_name": "Matthew Linkous",
            "team": "T5TCAFTA9",
            "name": "matt386",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Aoo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah yes Smalltalk is a great example. Having the file not be the single source of truth but instead an optional artifact of your program is an interesting concept."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "b2474d59-1f3c-4c88-9594-073d1058dbf5",
        "type": "message",
        "text": "I think my focus is less on the representation of a program but more towards the representation of data or system state.\nFor example:\n If you wanted to create a global source of a user's mouse position in a Unixy system, you might designate a file that is continuously overwritten by the kernel that other processes could stream in. However, if you had multiple mice (somewhat contrived I know) then you either must deal with locks, create multiple files, or make the file append-only. The same is true for a lot of multi-writer applications--especially collaborative text editing.\n\nSo it makes me wonder: can\/should files be _completely_ replaced with append-only logs.",
        "user": "U02C3SH9L2J",
        "ts": "1640019631.304000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1de4791b2cc3",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-20\/2888348949616_1de4791b2cc3996ef56c_72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Linkous",
            "display_name": "Matthew Linkous",
            "team": "T5TCAFTA9",
            "name": "matt386",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U02C3SH9L2J",
            "ts": "1640019696.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yZ2nq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think my focus is less on the representation of a program but more towards the representation of data or system state.\nFor example:\n If you wanted to create a global source of a user's mouse position in a Unixy system, you might designate a file that is continuously overwritten by the kernel that other processes could stream in. However, if you had multiple mice (somewhat contrived I know) then you either must deal with locks, create multiple files, or make the file append-only. The same is true for a lot of multi-writer applications--especially collaborative text editing.\n\nSo it makes me wonder: can\/should files be "
                            },
                            {
                                "type": "text",
                                "text": "completely ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "replaced with append-only logs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "e672785a-7496-4408-9145-696ed976fdef",
        "type": "message",
        "text": "Unclear to me what you mean by &lt;&lt;log&gt;&gt; here. If you are thinking of building interactive, interpreted environment then the static flat file model\/metaphor is only going to make it an upstream battle. You can image an message based system like Smalltalk, or an actor one as in the Carl Hewitt sense (in your mouse example, you can have each mouse be an actor sending a message to some hardware manager actor, no need to files or logs of any kind) or you can come up with another like model or better yet metaphor.",
        "user": "U02JDAYKW7J",
        "ts": "1640020041.304600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1ab8763ceb21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-14\/2826386958343_1ab8763ceb219317febf_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Krasner",
            "display_name": "Daniel Krasner",
            "team": "T5TCAFTA9",
            "name": "krasnerdaniel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3hJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unclear to me what you mean by <<log>> here. If you are thinking of building interactive, interpreted environment then the static flat file model\/metaphor is only going to make it an upstream battle. You can image an message based system like Smalltalk, or an actor one as in the Carl Hewitt sense (in your mouse example, you can have each mouse be an actor sending a message to some hardware manager actor, no need to files or logs of any kind) or you can come up with another like model or better yet metaphor."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "1b8c042a-c468-4b69-9da9-3cffa5d613fe",
        "type": "message",
        "text": "Yeah I see what you mean. I think my concern is around persistence and syncing. So I guess if we think in terms of an actor that is in charge of receiving messages\/updates from each mouse actor and then can respond to messages that request the mouse state then the internals whether it's in memory, stored in a SQL DB, file, etc doesn't matter because it's a black box which for the most part is a good thing. However, I'm thinking more in terms of composable data structures. So if you instead think of each mouse as a stream, then to have multiple mice you would just interleave your streams. I.e. I think what I'm getting at is more of building on top of an event-bus rather than addressable messages. Like it decouples the source and the recipient.",
        "user": "U02C3SH9L2J",
        "ts": "1640021340.304800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1de4791b2cc3",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-20\/2888348949616_1de4791b2cc3996ef56c_72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Linkous",
            "display_name": "Matthew Linkous",
            "team": "T5TCAFTA9",
            "name": "matt386",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d0fJM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I see what you mean. I think my concern is around persistence and syncing. So I guess if we think in terms of an actor that is in charge of receiving messages\/updates from each mouse actor and then can respond to messages that request the mouse state then the internals whether it's in memory, stored in a SQL DB, file, etc doesn't matter because it's a black box which for the most part is a good thing. However, I'm thinking more in terms of composable data structures. So if you instead think of each mouse as a stream, then to have multiple mice you would just interleave your streams. I.e. I think what I'm getting at is more of building on top of an event-bus rather than addressable messages. Like it decouples the source and the recipient."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "3bb11f69-4a0e-4db7-b027-94d7f66a1964",
        "type": "message",
        "text": "My experience with the actor model is more in the Erlang world than Smalltalk and I have always enjoyed the each process\/actor is completely isolated and could be it's own complete computer. However, I've always found the ideas of publishing to streams or channels more intuitive and ergonomic for shared state than exchanging messages. For example in this mouse example, if I had a drawing app then I would likely need to poll the \"mouse agent\" every 16ms which seems much more awkward than piping mouse changes into the application e.g. `mousePos() |&gt; draw()` then the actual drawing application\/process\/actor is decoupled from the mouse agent. Which you could model with files but it seems like a different data structure would be more suitable",
        "user": "U02C3SH9L2J",
        "ts": "1640021679.305000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1de4791b2cc3",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-20\/2888348949616_1de4791b2cc3996ef56c_72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Linkous",
            "display_name": "Matthew Linkous",
            "team": "T5TCAFTA9",
            "name": "matt386",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u1DjE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My experience with the actor model is more in the Erlang world than Smalltalk and I have always enjoyed the each process\/actor is completely isolated and could be it's own complete computer. However, I've always found the ideas of publishing to streams or channels more intuitive and ergonomic for shared state than exchanging messages. For example in this mouse example, if I had a drawing app then I would likely need to poll the \"mouse agent\" every 16ms which seems much more awkward than piping mouse changes into the application e.g. "
                            },
                            {
                                "type": "text",
                                "text": "mousePos() |> draw()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " then the actual drawing application\/process\/actor is decoupled from the mouse agent. Which you could model with files but it seems like a different data structure would be more suitable"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    },
    {
        "client_msg_id": "8c9ecf06-cebd-4c65-af7d-7052503f98b4",
        "type": "message",
        "text": "I think <https:\/\/github.com\/nushell\/nushell|Nushell> represents everything as a table",
        "user": "U85HCL7JP",
        "ts": "1640044836.305300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l8Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/nushell\/nushell",
                                "text": "Nushell"
                            },
                            {
                                "type": "text",
                                "text": " represents everything as a table"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1640016053.303100",
        "parent_user_id": "U02C3SH9L2J"
    }
]