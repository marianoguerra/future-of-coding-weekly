[
    {
        "client_msg_id": "f834bca6-ebc0-4791-8551-baef49324e71",
        "type": "message",
        "text": "*Immortal programs vs crash-only programs*\n\nImmortal programs: <http:\/\/steve-yegge.blogspot.com\/2007\/01\/pinocchio-problem.html>\nCrash-only programs: <https:\/\/en.wikipedia.org\/wiki\/Crash-only_software>\n\nIn brief, immortal programs try to never, ever reboot. Crash-only programs are designed to always be able to recover gracefully from a reboot. There's a fundamental tension here, and I'm starting to realize I'm very definitely on one side of it. I like a neat desk, and am compulsively closing things (terminals, browser tabs, browser sessions) when I'm done with them. I prefer text editors to IDEs, vim to emacs, unix as my IDE rather than slime. I'd always thought of these as subjective opinions that were just down to my personality and past experience. But, upon reflection, I want to make a stronger case that \"my side\" is superior.\n\n1. Focusing on recovering from reboots makes you better at simulating immortality. Restarts can in principle become instantaneous. Focusing on never rebooting makes you worse at recovering from crashes.\n2. It's easy for immortal programs to end up in situations that are difficult to reproduce. I spent some time recently programming with <@UE1JQM9HQ>'s Glamorous Toolkit. Modern Smalltalk uncomfortably straddles the image and git repo worlds. The way you work is to make changes to your running image until you have something you like, then go back and package up a slice of your image into a git repository to publish. If you make mistakes, others can have trouble reproducing the behavior you created in your image. Testing if you did it right necessarily requires rebooting the image.\nPutting these reasons together, immortal systems are more forbidding to newcomers. Crashing becomes a traumatic event, one newcomers are not used to, something beginner tutorials don't cover. When things don't work, it's more challenging to ask for help. Creating and sharing reproducible test cases requires crash-recovery skills.\n\nRereading the Pinocchio post now, I notice that there's actually no concrete benefits stated for long-lived programs. All there is are (compelling) analogies. A counter-analogy: an immortal program is like a spaceship. Once launched you're in a little bubble, stuck with whoever you happened to start out with. A crash-only program is like a little stone rolling down a hillside, gathering other stones until it turns into an avalanche.\n\nAs I said above, I'm biased because of my experiences. I'm curious to hear from others with more experience of immortal programs. Am I understating the benefits, overstating the drawbacks?",
        "user": "UCUSW7WVD",
        "ts": "1637524372.124600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E6G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Immortal programs vs crash-only programs",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nImmortal programs: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/steve-yegge.blogspot.com\/2007\/01\/pinocchio-problem.html"
                            },
                            {
                                "type": "text",
                                "text": "\nCrash-only programs: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Crash-only_software"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIn brief, immortal programs try to never, ever reboot. Crash-only programs are designed to always be able to recover gracefully from a reboot. There's a fundamental tension here, and I'm starting to realize I'm very definitely on one side of it. I like a neat desk, and am compulsively closing things (terminals, browser tabs, browser sessions) when I'm done with them. I prefer text editors to IDEs, vim to emacs, unix as my IDE rather than slime. I'd always thought of these as subjective opinions that were just down to my personality and past experience. But, upon reflection, I want to make a stronger case that \"my side\" is superior.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Focusing on recovering from reboots makes you better at simulating immortality. Restarts can in principle become instantaneous. Focusing on never rebooting makes you worse at recovering from crashes."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "It's easy for immortal programs to end up in situations that are difficult to reproduce. I spent some time recently programming with "
                                    },
                                    {
                                        "type": "user",
                                        "user_id": "UE1JQM9HQ"
                                    },
                                    {
                                        "type": "text",
                                        "text": "'s Glamorous Toolkit. Modern Smalltalk uncomfortably straddles the image and git repo worlds. The way you work is to make changes to your running image until you have something you like, then go back and package up a slice of your image into a git repository to publish. If you make mistakes, others can have trouble reproducing the behavior you created in your image. Testing if you did it right necessarily requires rebooting the image."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPutting these reasons together, immortal systems are more forbidding to newcomers. Crashing becomes a traumatic event, one newcomers are not used to, something beginner tutorials don't cover. When things don't work, it's more challenging to ask for help. Creating and sharing reproducible test cases requires crash-recovery skills.\n\nRereading the Pinocchio post now, I notice that there's actually no concrete benefits stated for long-lived programs. All there is are (compelling) analogies. A counter-analogy: an immortal program is like a spaceship. Once launched you're in a little bubble, stuck with whoever you happened to start out with. A crash-only program is like a little stone rolling down a hillside, gathering other stones until it turns into an avalanche.\n\nAs I said above, I'm biased because of my experiences. I'm curious to hear from others with more experience of immortal programs. Am I understating the benefits, overstating the drawbacks?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "reply_count": 19,
        "reply_users_count": 13,
        "latest_reply": "1638659521.176900",
        "reply_users": [
            "UFPPABQ7P",
            "UCUSW7WVD",
            "U71PMQ1V0",
            "U016VUZGUUQ",
            "UQ706GB9U",
            "UMVFWPZ36",
            "UDQBTJ211",
            "UA14TGLTC",
            "UJBAJNFLK",
            "UDJ2TKB99",
            "UGWUJUZHT",
            "U02E4DAQGSZ",
            "UKJGU23KP"
        ],
        "replies": [
            {
                "user": "UFPPABQ7P",
                "ts": "1637526233.124700"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1637526990.125100"
            },
            {
                "user": "U71PMQ1V0",
                "ts": "1637527316.125300"
            },
            {
                "user": "U71PMQ1V0",
                "ts": "1637527417.125600"
            },
            {
                "user": "U71PMQ1V0",
                "ts": "1637527599.125900"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1637528380.127200"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1637543138.127600"
            },
            {
                "user": "UQ706GB9U",
                "ts": "1637547400.127900"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1637552878.128100"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1637564482.129300"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1637566095.129500"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1637571654.129800"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1637572018.130000"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1637572306.130200"
            },
            {
                "user": "UDJ2TKB99",
                "ts": "1637585733.133400"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1637588564.135200"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1637613231.136000"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1637825579.138100"
            },
            {
                "user": "UKJGU23KP",
                "ts": "1638659521.176900"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "joy",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "81d8e447-9faf-4e7c-a025-cec556d68b51",
        "type": "message",
        "text": "These two write ups influenced me to take a similar point of view as you seem to be voicing, here\n <https:\/\/ferd.ca\/the-zen-of-erlang.html|https:\/\/ferd.ca\/the-zen-of-erlang.html>\n<https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5|https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5>",
        "user": "UFPPABQ7P",
        "ts": "1637526233.124700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cb9d79e2bebc",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-09\/631538186901_cb9d79e2bebc09100b3f_72.jpg",
            "first_name": "Cole",
            "real_name": "Cole Lawrence",
            "display_name": "Cole",
            "team": "T5TCAFTA9",
            "name": "colelawr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5",
                "service_name": "Medium",
                "title": "Crash early and crash often for more reliable software",
                "title_link": "https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5",
                "text": "I’ve increasingly noticed a disturbing trend in software engineering: the idea that any total program crash (via segmentation fault, panic…",
                "fields": [
                    {
                        "title": "Reading time",
                        "value": "7 min read",
                        "short": true
                    }
                ],
                "ts": 1554688855,
                "fallback": "Medium: Crash early and crash often for more reliable software",
                "service_icon": "https:\/\/miro.medium.com\/fit\/c\/152\/152\/1*sHhtYhaCe2Uc3IU0IgKwIQ.png",
                "id": 1,
                "original_url": "https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nBD3S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "These two write ups influenced me to take a similar point of view as you seem to be voicing, here\n "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ferd.ca\/the-zen-of-erlang.html",
                                "text": "https:\/\/ferd.ca\/the-zen-of-erlang.html"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5",
                                "text": "https:\/\/medium.com\/@mattklein123\/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "20a31965-c6c1-47b5-ae7a-efb0b78c9d76",
        "type": "message",
        "text": "That's a good point. I think Erlang might be the ultimate no-compromises crash-only system, the way Smalltalk is the ultimate no-compromises immortal system.",
        "user": "UCUSW7WVD",
        "ts": "1637526990.125100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MV3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That's a good point. I think Erlang might be the ultimate no-compromises crash-only system, the way Smalltalk is the ultimate no-compromises immortal system."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "dcd27efd-cd29-4a71-813b-fc6471190003",
        "type": "message",
        "text": "I think this is the key to the success of the database \/ application server separation. You put all of your long-lived state into some immortal process with a very controlled data model and put all the scary weird stuff into a crash-only process.",
        "user": "U71PMQ1V0",
        "ts": "1637527316.125300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaac726e8ce2",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/0aac726e8ce27b55809824e7f6de77e7.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Jamie Brandon",
            "display_name": "jamii",
            "team": "T5TCAFTA9",
            "name": "jamie",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZNqFM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think this is the key to the success of the database \/ application server separation. You put all of your long-lived state into some immortal process with a very controlled data model and put all the scary weird stuff into a crash-only process."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "UKJGU23KP"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "271612b0-cd96-412f-9f95-19e4f9f6d273",
        "type": "message",
        "text": "Maybe the real benefit from the immortal systems that yegge described is not that you can avoid restarting them, but that they are forced to have lots of tools for inspection \/ modification. If you have something like <https:\/\/ourmachinery.com\/post\/the-story-behind-the-truth-designing-a-data-model\/> instead you can get the same benefits while also being able to do clean restarts.",
        "user": "U71PMQ1V0",
        "ts": "1637527417.125600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaac726e8ce2",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/0aac726e8ce27b55809824e7f6de77e7.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Jamie Brandon",
            "display_name": "jamii",
            "team": "T5TCAFTA9",
            "name": "jamie",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KHyh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe the real benefit from the immortal systems that yegge described is not that you can avoid restarting them, but that they are forced to have lots of tools for inspection \/ modification. If you have something like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ourmachinery.com\/post\/the-story-behind-the-truth-designing-a-data-model\/"
                            },
                            {
                                "type": "text",
                                "text": " instead you can get the same benefits while also being able to do clean restarts."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "f2fe7f9e-549f-471c-b9aa-b8473aa2c4cc",
        "type": "message",
        "text": "Similarly, the problem I had with smalltalk is not that state lives in the image, but that the state is smeared all over the place and built out of pointers and mutable variables. Having all your state and code in eg sqlite or couchdb is essentially the same idea but is much easier to inspect and understand.",
        "user": "U71PMQ1V0",
        "ts": "1637527599.125900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaac726e8ce2",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/0aac726e8ce27b55809824e7f6de77e7.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Jamie Brandon",
            "display_name": "jamii",
            "team": "T5TCAFTA9",
            "name": "jamie",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1ETyJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Similarly, the problem I had with smalltalk is not that state lives in the image, but that the state is smeared all over the place and built out of pointers and mutable variables. Having all your state and code in eg sqlite or couchdb is essentially the same idea but is much easier to inspect and understand."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFPPABQ7P",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "84e24265-9baf-452b-99f4-da3a76196896",
        "type": "message",
        "text": "Late to this convo, but we’re considering some very similar problems with similar goals. We decided to make a centralized “account” system, so any community can host their own account server. Individual apps can connect to multiple different account servers at a time (like an email client). Then, additional functionality like talking to remote systems go through the account system through to agents on the host machines (e.g. like pulling data from an Oracle DB behind a firewall or ripping a DVD on the external drive in your HTPC). We help enterprise customers onboard through deploying an on-premise account server and we “sell” per seat for the enterprise’s account server (which has tools for data usage auditing, administration, and access permissions).\n\nWhile we’re already able to operate in a single tenant mode on your personal computer, we have deferred on completely decentralized usage until after we’ve captured market. Then, the model just becomes selling the administration and support tooling like maybe mongoDB\/CockroachDB do.",
        "user": "UFPPABQ7P",
        "ts": "1637527661.126100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cb9d79e2bebc",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-09\/631538186901_cb9d79e2bebc09100b3f_72.jpg",
            "first_name": "Cole",
            "real_name": "Cole Lawrence",
            "display_name": "Cole",
            "team": "T5TCAFTA9",
            "name": "colelawr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x3Sq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Late to this convo, but we’re considering some very similar problems with similar goals. We decided to make a centralized “account” system, so any community can host their own account server. Individual apps can connect to multiple different account servers at a time (like an email client). Then, additional functionality like talking to remote systems go through the account system through to agents on the host machines (e.g. like pulling data from an Oracle DB behind a firewall or ripping a DVD on the external drive in your HTPC). We help enterprise customers onboard through deploying an on-premise account server and we “sell” per seat for the enterprise’s account server (which has tools for data usage auditing, administration, and access permissions).\n\nWhile we’re already able to operate in a single tenant mode on your personal computer, we have deferred on completely decentralized usage until after we’ve captured market. Then, the model just becomes selling the administration and support tooling like maybe mongoDB\/CockroachDB do."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1636484864.068700",
        "parent_user_id": "UJFN50C00"
    },
    {
        "client_msg_id": "838174fb-ed68-424f-9343-9ba7e611976b",
        "type": "message",
        "text": "There's definitely value in reducing the blast radius of crashes, but that feels like an orthogonal axis. I love how the DB is separate when I restart my web app, but it doesn't help me when I need to restart my DB. Is there _any_ stateful system today that has a decent story for restarting without downtime?\n\nNow I wonder what a storage system would look like that was designed from the ground up to be crash-only..",
        "user": "UCUSW7WVD",
        "ts": "1637528380.127200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FsL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's definitely value in reducing the blast radius of crashes, but that feels like an orthogonal axis. I love how the DB is separate when I restart my web app, but it doesn't help me when I need to restart my DB. Is there "
                            },
                            {
                                "type": "text",
                                "text": "any",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " stateful system today that has a decent story for restarting without downtime?\n\nNow I wonder what a storage system would look like that was designed from the ground up to be crash-only.."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "a60f2c8f-7f1f-4803-a2e2-37ca51baba97",
        "type": "message",
        "text": "I definitely lean toward crash-only. The only truly immortal program is one that runs on a machine that never has power failures, angry users with hammers, etc.\n\nI also agree that in principle, requiring reboots is a sign of flawed software. I froth at the mouth a little bit every time I have to \"turn it off and on again\". I think the only real tension between those two ideals is the one related to users being unfamiliar with the process of rebooting, and I'm pretty sure that can be surmounted. I can't think of any reason you wouldn't try for both. Maybe think of it as \"immortal unless you pull the plug, which must be allowed\".\n\nI don't have the patience I once did for Stevey Blog Rants, so I skimmed his post, especially the middle. However, I think the parts that he thinks should be immortal (what he calls software as opposed to the rigidly defined software-as-hardware he says static types create), that soft stuff should be thought of as user-created *content* that is interpreted by relatively stateless infrastructure. From that perspective, it's clear that content should be immortal (and portable, inspectable, etc), while the infrastructure can be started up or killed whenever. Obviously there's some<https:\/\/xkcd.com\/908\/| caching involved>, maybe even including JITed user code, but I think this architecture could basically get the nice properties of both immortality and crash-only.",
        "user": "U016VUZGUUQ",
        "ts": "1637543138.127600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U016VUZGUUQ",
            "ts": "1637543200.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zR\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I definitely lean toward crash-only. The only truly immortal program is one that runs on a machine that never has power failures, angry users with hammers, etc.\n\nI also agree that in principle, requiring reboots is a sign of flawed software. I froth at the mouth a little bit every time I have to \"turn it off and on again\". I think the only real tension between those two ideals is the one related to users being unfamiliar with the process of rebooting, and I'm pretty sure that can be surmounted. I can't think of any reason you wouldn't try for both. Maybe think of it as \"immortal unless you pull the plug, which must be allowed\".\n\nI don't have the patience I once did for Stevey Blog Rants, so I skimmed his post, especially the middle. However, I think the parts that he thinks should be immortal (what he calls software as opposed to the rigidly defined software-as-hardware he says static types create), that soft stuff should be thought of as user-created "
                            },
                            {
                                "type": "text",
                                "text": "content",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that is interpreted by relatively stateless infrastructure. From that perspective, it's clear that content should be immortal (and portable, inspectable, etc), while the infrastructure can be started up or killed whenever. Obviously there's some"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/xkcd.com\/908\/",
                                "text": " caching involved"
                            },
                            {
                                "type": "text",
                                "text": ", maybe even including JITed user code, but I think this architecture could basically get the nice properties of both immortality and crash-only."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "cf7c08b0-561a-423c-a4e6-283a3ed04917",
        "type": "message",
        "text": "There are tons of distributed databases that handle partial failure all the time. I work with Cassandra. One of the interesting things we’ve done is to use AWS’s virtual block storage (EBS) to swap versions by reattaching storage to the new instances.",
        "user": "UQ706GB9U",
        "ts": "1637547400.127900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g80bf3c31da6",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/80bf3c31da6a1f3f44e68bfe227fd35d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "",
            "real_name": "George Campbell",
            "display_name": "George Campbell",
            "team": "T5TCAFTA9",
            "name": "abersnaze",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IlJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are tons of distributed databases that handle partial failure all the time. I work with Cassandra. One of the interesting things we’ve done is to use AWS’s virtual block storage (EBS) to swap versions by reattaching storage to the new instances."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "69a66fbf-1cf6-4bb5-bf79-f4f35c3a006b",
        "type": "message",
        "text": "I'm 99.9% biased toward crash-reboot from my empirical dataset. I'd also say that in biology cell-division seems like a crash reboot.",
        "user": "UMVFWPZ36",
        "ts": "1637552878.128100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "waXG8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm 99.9% biased toward crash-reboot from my empirical dataset. I'd also say that in biology cell-division seems like a crash reboot."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "8c7b9d95-6170-4534-9ea3-0aa00c0a6815",
        "type": "message",
        "text": "This is why I like git - it can't really \"crash\" as such because it isn't running 99.9% of the time. Highly stateful system, but all the state is either on disk (or very short lived).\n\nThe equivalent of \"crashing\" in systems like this is getting a bad config, so it won't run at all. This is incredibly annoying to deal with. So I'm not sure there's actually a philosophical difference here, other than \"be mindful of unanticipated states\". Having a crashy system probably just makes you think about state more explicitly.\n\nThe main difference I guess is that a \"crashed\" (i.e. corrupted) git repo is an automatic \"memory dump\" to which your file browser and text editor act like an already attached debugger.",
        "user": "UDQBTJ211",
        "ts": "1637564482.129300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wH8WW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is why I like git - it can't really \"crash\" as such because it isn't running 99.9% of the time. Highly stateful system, but all the state is either on disk (or very short lived).\n\nThe equivalent of \"crashing\" in systems like this is getting a bad config, so it won't run at all. This is incredibly annoying to deal with. So I'm not sure there's actually a philosophical difference here, other than \"be mindful of unanticipated states\". Having a crashy system probably just makes you think about state more explicitly.\n\nThe main difference I guess is that a \"crashed\" (i.e. corrupted) git repo is an automatic \"memory dump\" to which your file browser and text editor act like an already attached debugger."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "fedaf36b-1d7b-48e0-adec-d5aa799b6a08",
        "type": "message",
        "text": "There really are important differences between long-lived and short-lived parts of a system.  To a first approximation it's alls just data and transformations thereof, but how manage the tradeoffs of robustness, performance, mutability, and recovery differ.",
        "user": "UA14TGLTC",
        "ts": "1637566095.129500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0Lzrc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There really are important differences between long-lived and short-lived parts of a system.  To a first approximation it's alls just data and transformations thereof, but how manage the tradeoffs of robustness, performance, mutability, and recovery differ."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1637524372.124600",
        "parent_user_id": "UCUSW7WVD"
    }
]