[
    {
        "type": "message",
        "subtype": "thread_broadcast",
        "text": "this will probably sound overly philosophical but i’m not trying to be.. just what seems to happen when i try to coherently define terms.\n\nfirst off, science &amp; engineering is almost always based on the assumption that we share a common ‘reality,’ which we come to understand through our band-limited, unreliable faculties of sensing and cognition. i will adopt that assumption throughout. studies and experience show our mental models to be wildly inconsistent, both internally (‘verification’), measured against reality (‘validation’) and compared to other people’s (‘coordination’), but they form the basis of pretty much every decision we make.\n\nmy best working def of a model is ‘something that represents a partial world state’\n- ‘something’ = has to exist in some form to be useful, whether encoded in a tangible object, a pencil &amp; paper sketch, computer memory, neural circuitry, etc.\n- ‘represents’ = ultimately in the eye of the beholder; requires some pre-shared bootstrapping model\/implementation to be useful (e.g. among humans we have near-universal experiential primitives like ‘dark\/light’, ‘hot\/cold,’ etc)\n- ‘world’ = all of reality\n- ‘partial world’ = some subset of reality\n- ‘state’ = some configuration of that subset of reality (with implicit or explicit precision\/likelihood)\n\nrepresentation is kind of subtle even beyond coordination (alan kay’s ‘communicating with aliens’)... perhaps the most basic representation is a simple ‘reference’, which still encodes the assumption that there’s a ‘something’ that’s persistent and recognizable on the other end (‘object permanence’). i don’t see a flaw in saying ‘pointers’ are the most basic form of stateful cognition (and subject to the same foibles as c pointers... is the referent still there? can it still do the same things? does it still have the same properties? has it been replaced by an evil twin?)\n\nmodels can serve a bunch of different roles. e.g. a model can communicate an observation of what i claim the current world state to be, an instruction representing the world state i want a system to produce, or an imagined scenario to reason about.\n\n‘simulation’ is a bit slippery; to me the useful primitive to start with is ‘an ordered sequence of models,’ in which case simulation is something like ‘an ordered sequence of models representing the time evolution of a particular model according to some update rule’\n\none could think of science as ‘a process for finding models that best represent the world and finding rules for updating them that predict future world states’, design as ‘a process for defining models of how we want the world to be,’ and engineering as ‘a process for implementing rules (science) in order to achieve desired world states (design) based on current world states (science).’ ‘programming’ tends to muddle all 3 together, whether explicitly or (usually) implicitly.\n\nall that said, yeah, <@UCUSW7WVD> programming email filters is squarely in the realm of what i’m talking about. you start with a model of reality that also includes your computing environment - your machine, its OS, your browser, the mail server, etc etc, which you can always drill down from whatever abstraction your dealing with if needed. you define a model for what unfiltered email is like (‘science’), a model of what you want your filtered email to be like (‘design’), and come up with (science) &amp; implement (engineering) rules you think will achieve that. simulation is a powerful tool to aid in the ‘coming up with and implementing rules’ part (’what happens if i project this rule on this inbox model over time?’). to close the loop you also want some nice tools to see if it’s working how you want it to. netlogo enables some of this in a very ‘science-y’ not ‘user-y’ context. hypercard gives you some nice tools for very ad hoc experimentation.\n\nwavelength check?",
        "user": "U9C92716C",
        "ts": "1636039327.057300",
        "thread_ts": "1635811447.034700",
        "root": {
            "client_msg_id": "e500e9a7-f32a-40c3-be6b-40199115d2c5",
            "type": "message",
            "text": "A thought that’s been crystallizing for me is that the essence of ‘coding’ is *modeling &amp; simulation* (not e.g. data and functions). These themes show up all the time in FoC contexts, but as far as I can tell they’re rarely the ROOT metaphors of a system.\n\nOf course there are plenty of examples in “real engineering,” what Alan Kay refers to as CAD&lt;-&gt;SIM-&gt;FAB system. Do you know of examples of ‘convivial computing’ projects where modeling and simulation are the main event, or readings on the topic? What do you think of this premise?\n\nHere’s a recent <https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing|Quora answer> for more context: *Does Alan Kay see any new ideas in computing?*\n&gt; “New” is not what I look for. “Ideas that make a qualitative difference over past techniques” are what I’d like to see.\n&gt; \n&gt; Years ago, I’m fairly sure I was aware of pretty much everything regarding computing that was going on in the world. Today, I’m definitely not aware of everything, so it’s reasonably likely that if there was something really great being done somewhere that I wouldn’t know about it.\n&gt; \n&gt; I would be most interested in learning about “qualitatively more expressive” programming that is more in line with top-level engineering practices of the CAD&lt;-&gt;SIM-&gt;FAB systems found in serious engineering of large complex systems in the physical worlds of civil, electrical, automotive, aeronautical, biological, etc. engineering.\n&gt; \n&gt; In the CAD&lt;-&gt;SIM part I’d like to see the designs understandable at the level of visualizable semantic requirements and specifications that can be automatically simulated (on supercomputers if necessary) in real-time, and then safely optimized in various ways for many targets.\n&gt; \n&gt; Isolating semantics in the CAD&lt;-&gt;SIM part implies that what is represented here is a felicitous combination of “compact and understandable”.\n&gt; \n&gt; The FAB-part pragmatics are very interesting in their own right, and besides efficiencies, should be able to deal with enormous scaling and various kinds of latencies and errors, etc.\n&gt; \n&gt; The above would be the minimal visions and goals that I think systems designers within computing and software engineering should be aiming for.\n&gt; \n&gt; I’m not aware of something like this being worked on at present, but these days this could be just because I haven’t come across it.",
            "user": "U9C92716C",
            "ts": "1635811447.034700",
            "team": "T5TCAFTA9",
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "wxvj2",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "A thought that’s been crystallizing for me is that the essence of ‘coding’ is "
                                },
                                {
                                    "type": "text",
                                    "text": "modeling & simulation ",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": "(not e.g. data and functions). These themes show up all the time in FoC contexts, but as far as I can tell they’re rarely the ROOT metaphors of a system.\n\nOf course there are plenty of examples in “real engineering,” what Alan Kay refers to as CAD<->SIM->FAB system. Do you know of examples of ‘convivial computing’ projects where modeling and simulation are the main event, or readings on the topic? What do you think of this premise?\n\nHere’s a recent "
                                },
                                {
                                    "type": "link",
                                    "url": "https:\/\/www.quora.com\/Does-Alan-Kay-see-any-new-ideas-in-computing",
                                    "text": "Quora answer"
                                },
                                {
                                    "type": "text",
                                    "text": " for more context: "
                                },
                                {
                                    "type": "text",
                                    "text": "Does Alan Kay see any new ideas in computing?",
                                    "style": {
                                        "bold": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": "\n"
                                }
                            ]
                        },
                        {
                            "type": "rich_text_quote",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "“New” is not what I look for. “Ideas that make a qualitative difference over past techniques” are what I’d like to see.\n\nYears ago, I’m fairly sure I was aware of pretty much everything regarding computing that was going on in the world. Today, I’m definitely not aware of everything, so it’s reasonably likely that if there was something really great being done somewhere that I wouldn’t know about it.\n\nI would be most interested in learning about “qualitatively more expressive” programming that is more in line with top-level engineering practices of the CAD<->SIM->FAB systems found in serious engineering of large complex systems in the physical worlds of civil, electrical, automotive, aeronautical, biological, etc. engineering.\n\nIn the CAD<->SIM part I’d like to see the designs understandable at the level of visualizable semantic requirements and specifications that can be automatically simulated (on supercomputers if necessary) in real-time, and then safely optimized in various ways for many targets.\n\nIsolating semantics in the CAD<->SIM part implies that what is represented here is a felicitous combination of “compact and understandable”.\n\nThe FAB-part pragmatics are very interesting in their own right, and besides efficiencies, should be able to deal with enormous scaling and various kinds of latencies and errors, etc.\n\nThe above would be the minimal visions and goals that I think systems designers within computing and software engineering should be aiming for.\n\nI’m not aware of something like this being worked on at present, but these days this could be just because I haven’t come across it."
                                }
                            ]
                        }
                    ]
                }
            ],
            "thread_ts": "1635811447.034700",
            "reply_count": 20,
            "reply_users_count": 8,
            "latest_reply": "1636619273.073400",
            "reply_users": [
                "UEBG0NPDK",
                "U9C92716C",
                "UCUSW7WVD",
                "UE6EFEPTQ",
                "U8A5MS6R1",
                "U02JDAYKW7J",
                "UMVFWPZ36",
                "UJBAJNFLK"
            ],
            "replies": [
                {
                    "user": "UEBG0NPDK",
                    "ts": "1635816561.036500"
                },
                {
                    "user": "UEBG0NPDK",
                    "ts": "1635816605.036900"
                },
                {
                    "user": "UEBG0NPDK",
                    "ts": "1635816623.037500"
                },
                {
                    "user": "U9C92716C",
                    "ts": "1635818438.043000"
                },
                {
                    "user": "U9C92716C",
                    "ts": "1635818575.044100"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1635862299.044600"
                },
                {
                    "user": "U9C92716C",
                    "ts": "1636039327.057300"
                },
                {
                    "user": "UE6EFEPTQ",
                    "ts": "1636044056.057600"
                },
                {
                    "user": "U9C92716C",
                    "ts": "1636048731.057800"
                },
                {
                    "user": "UE6EFEPTQ",
                    "ts": "1636062690.058000"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1636485831.069100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1636486020.069400"
                },
                {
                    "user": "U02JDAYKW7J",
                    "ts": "1636494512.070200"
                },
                {
                    "user": "U9C92716C",
                    "ts": "1636573785.071200"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1636575262.071400"
                },
                {
                    "user": "U02JDAYKW7J",
                    "ts": "1636581585.071900"
                },
                {
                    "user": "UMVFWPZ36",
                    "ts": "1636592084.072400"
                },
                {
                    "user": "U02JDAYKW7J",
                    "ts": "1636592468.072600"
                },
                {
                    "user": "UJBAJNFLK",
                    "ts": "1636618765.073200"
                },
                {
                    "user": "UJBAJNFLK",
                    "ts": "1636619273.073400"
                }
            ],
            "is_locked": false,
            "subscribed": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wXgse",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this will probably sound overly philosophical but i’m not trying to be.. just what seems to happen when i try to coherently define terms.\n\nfirst off, science & engineering is almost always based on the assumption that we share a common ‘reality,’ which we come to understand through our band-limited, unreliable faculties of sensing and cognition. i will adopt that assumption throughout. studies and experience show our mental models to be wildly inconsistent, both internally (‘verification’), measured against reality (‘validation’) and compared to other people’s (‘coordination’), but they form the basis of pretty much every decision we make.\n\nmy best working def of a model is ‘something that represents a partial world state’\n- ‘something’ = has to exist in some form to be useful, whether encoded in a tangible object, a pencil & paper sketch, computer memory, neural circuitry, etc.\n- ‘represents’ = ultimately in the eye of the beholder; requires some pre-shared bootstrapping model\/implementation to be useful (e.g. among humans we have near-universal experiential primitives like ‘dark\/light’, ‘hot\/cold,’ etc)\n- ‘world’ = all of reality\n- ‘partial world’ = some subset of reality\n- ‘state’ = some configuration of that subset of reality (with implicit or explicit precision\/likelihood)\n\nrepresentation is kind of subtle even beyond coordination (alan kay’s ‘communicating with aliens’)... perhaps the most basic representation is a simple ‘reference’, which still encodes the assumption that there’s a ‘something’ that’s persistent and recognizable on the other end (‘object permanence’). i don’t see a flaw in saying ‘pointers’ are the most basic form of stateful cognition (and subject to the same foibles as c pointers... is the referent still there? can it still do the same things? does it still have the same properties? has it been replaced by an evil twin?)\n\nmodels can serve a bunch of different roles. e.g. a model can communicate an observation of what i claim the current world state to be, an instruction representing the world state i want a system to produce, or an imagined scenario to reason about.\n\n‘simulation’ is a bit slippery; to me the useful primitive to start with is ‘an ordered sequence of models,’ in which case simulation is something like ‘an ordered sequence of models representing the time evolution of a particular model according to some update rule’\n\none could think of science as ‘a process for finding models that best represent the world and finding rules for updating them that predict future world states’, design as ‘a process for defining models of how we want the world to be,’ and engineering as ‘a process for implementing rules (science) in order to achieve desired world states (design) based on current world states (science).’ ‘programming’ tends to muddle all 3 together, whether explicitly or (usually) implicitly.\n\nall that said, yeah, "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " programming email filters is squarely in the realm of what i’m talking about. you start with a model of reality that also includes your computing environment - your machine, its OS, your browser, the mail server, etc etc, which you can always drill down from whatever abstraction your dealing with if needed. you define a model for what unfiltered email is like (‘science’), a model of what you want your filtered email to be like (‘design’), and come up with (science) & implement (engineering) rules you think will achieve that. simulation is a powerful tool to aid in the ‘coming up with and implementing rules’ part (’what happens if i project this rule on this inbox model over time?’). to close the loop you also want some nice tools to see if it’s working how you want it to. netlogo enables some of this in a very ‘science-y’ not ‘user-y’ context. hypercard gives you some nice tools for very ad hoc experimentation.\n\nwavelength check?"
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "99bd8e47-3159-4d4c-9b7d-343ff8f898bc"
    },
    {
        "client_msg_id": "21d89922-9831-4d0e-b6b4-ed5fd0922303",
        "type": "message",
        "text": "_written before I saw the above_\n\nAbsolutely! For me personally, \"the essence of ‘coding’ is modeling &amp; simulation\" is exactly where I've come from in everything I've done in this space.\n\nI wouldn't just cross out \"e.g. data and functions\" as a result though - you can't exactly throw those out! Even when in the most modelly and simulatey world, you'll need to present data to the user to hold current states. And behaviours of those states is basically going to boil down to something like functions, even if presented more abstractly in pretty graphics. I mean, even Excel - the financial modeller\/simulator - has those!\n\nFor me, programming is creating new realities or simulating existing ones. I often refer back to the early Macs which introduced to the world a wordprocessor program that made the page actually look like the printed page you'd end up with, instead of glowing text floating on a black background that bore no relation to it. This is modelling or simulation of printed paper.\n\nIn social media or chat you're modelling or simulating the relationships between people: their social graph. You're simulating them talking (or perhaps passing little paper notes to each other!)\n\nOf course, 3D virtual worlds and Augmented Reality are the extreme of this position, as is the programming of IoT devices.",
        "user": "UE6EFEPTQ",
        "ts": "1636044056.057600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xL8F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "written before I saw the above",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nAbsolutely! For me personally, \"the essence of ‘coding’ is modeling & simulation\" is exactly where I've come from in everything I've done in this space.\n\nI wouldn't just cross out \"e.g. data and functions\" as a result though - you can't exactly throw those out! Even when in the most modelly and simulatey world, you'll need to present data to the user to hold current states. And behaviours of those states is basically going to boil down to something like functions, even if presented more abstractly in pretty graphics. I mean, even Excel - the financial modeller\/simulator - has those!\n\nFor me, programming is creating new realities or simulating existing ones. I often refer back to the early Macs which introduced to the world a wordprocessor program that made the page actually look like the printed page you'd end up with, instead of glowing text floating on a black background that bore no relation to it. This is modelling or simulation of printed paper.\n\nIn social media or chat you're modelling or simulating the relationships between people: their social graph. You're simulating them talking (or perhaps passing little paper notes to each other!)\n\nOf course, 3D virtual worlds and Augmented Reality are the extreme of this position, as is the programming of IoT devices."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1635811447.034700",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "900c98ae-e05c-47cb-95b1-d8b45459fc82",
        "type": "message",
        "text": "i’m tracking. to try out my terminology (i know you wrote this before reading), i’m def not throwing out data and functions but kind of putting them in their place. ‘data’ is the encoding of models in some reconstructable form. ‘functions’ are rules for transforming models (very useful in simulation or representation). representation is a separate issue.. can be whatever makes the most sense in context: text, diagrams, interactive widgets, spatial audio. a missing concept here is ‘linking models together.’\n\nall good examples of modeling and simulation, though i wouldn’t say 3D VR is necessarily the extreme.. e.g. you can have rich representation capabilities but very poor modeling &amp; simulation capabilities. this is partly why a lot of MMOs despite flashy graphics struggled to achieve the immersive quality of text-based MUDs.\n\nIMO it’s getting easier &amp; easier to hop around these these layers while programming and it can be hard to keep track of where the lines are drawn, to the detriment of comprehension.",
        "user": "U9C92716C",
        "ts": "1636048731.057800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6bd6fe3fcf91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-20\/1137095139906_6bd6fe3fcf91b6f41781_72.jpg",
            "first_name": "",
            "real_name": "Dalton Banks",
            "display_name": "daltonb",
            "team": "T5TCAFTA9",
            "name": "dalton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gx58",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i’m tracking. to try out my terminology (i know you wrote this before reading), i’m def not throwing out data and functions but kind of putting them in their place. ‘data’ is the encoding of models in some reconstructable form. ‘functions’ are rules for transforming models (very useful in simulation or representation). representation is a separate issue.. can be whatever makes the most sense in context: text, diagrams, interactive widgets, spatial audio. a missing concept here is ‘linking models together.’\n\nall good examples of modeling and simulation, though i wouldn’t say 3D VR is necessarily the extreme.. e.g. you can have rich representation capabilities but very poor modeling & simulation capabilities. this is partly why a lot of MMOs despite flashy graphics struggled to achieve the immersive quality of text-based MUDs.\n\nIMO it’s getting easier & easier to hop around these these layers while programming and it can be hard to keep track of where the lines are drawn, to the detriment of comprehension."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1635811447.034700",
        "parent_user_id": "U9C92716C"
    },
    {
        "client_msg_id": "a1a9701a-f34d-4cb2-ad5f-6adc774ee5a0",
        "type": "message",
        "text": "On the new post, I agree with everything up to the email filter bit, which I'm still digesting but it's not resonating as yet!",
        "user": "UE6EFEPTQ",
        "ts": "1636062690.058000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3cjkI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the new post, I agree with everything up to the email filter bit, which I'm still digesting but it's not resonating as yet!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1635811447.034700",
        "parent_user_id": "U9C92716C"
    }
]