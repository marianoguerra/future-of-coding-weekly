[
    {
        "client_msg_id": "d92c947b-3154-4375-86fd-7c9674632f1d",
        "type": "message",
        "text": "Whereas reality has a lot of detail[1]; and\nWhereas anything that can go wrong will; and\nWhereas exception handling policies streamline program business logic; and\nWhereas code written by others becomes more difficult to debug in the presence of exceptions; therefore be it\nResolved that the flow of exceptions will never span ownership boundaries; and further\nResolved that libraries will never throw exceptions visible to their callers.\n\nSo decided by the society of mind of Kartik Agaram on this ninth day of September in the year two thousand and twenty one.\n\n[1] <http:\/\/johnsalvatier.org\/blog\/2017\/reality-has-a-surprising-amount-of-detail>",
        "user": "UCUSW7WVD",
        "ts": "1631170879.161200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Dz=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Whereas reality has a lot of detail[1]; and\nWhereas anything that can go wrong will; and\nWhereas exception handling policies streamline program business logic; and\nWhereas code written by others becomes more difficult to debug in the presence of exceptions; therefore be it\nResolved that the flow of exceptions will never span ownership boundaries; and further\nResolved that libraries will never throw exceptions visible to their callers.\n\nSo decided by the society of mind of Kartik Agaram on this ninth day of September in the year two thousand and twenty one.\n\n[1] "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/johnsalvatier.org\/blog\/2017\/reality-has-a-surprising-amount-of-detail"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK",
                    "UE6EFEPTQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e3521e28-f1f5-45f3-a3b6-48de884dc41a",
        "type": "message",
        "text": "A bit of a personal opinion on the infamous Monads (as that translates to _other_ effect systems too). Yeah monads just for error handling is an overkill (in the terms of code boilerplate though do-notation does clean syntax quite a bit compared to Go-style manual error code checks). But. When you add _other effects_ to the mix -- async, IO, transactions, business-rules _DSLs_ and what have you -- monads become rather economic and handy unifying framework. Obviously through _compositionality and abstraction_: you can make any particular piece of code only dependent on effects it needs and completely oblivious to any other effects including ones that get added _later in development_. And I'd like to point out that many of the mentioned effects in Haskell are implemented in _libraries_ and not built into the language. :slightly_smiling_face:",
        "user": "U027P92A0N5",
        "ts": "1631175666.161700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d6900487d910",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-07-07\/2254853369060_d6900487d9109f495c79_72.jpg",
            "first_name": "Alexander",
            "real_name": "Alexander Chichigin",
            "display_name": "Alex Chichigin",
            "team": "T5TCAFTA9",
            "name": "sad.ronin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w\/Sr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A bit of a personal opinion on the infamous Monads (as that translates to "
                            },
                            {
                                "type": "text",
                                "text": "other",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " effect systems too). Yeah monads just for error handling is an overkill (in the terms of code boilerplate though do-notation does clean syntax quite a bit compared to Go-style manual error code checks). But. When you add "
                            },
                            {
                                "type": "text",
                                "text": "other effects",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to the mix -- async, IO, transactions, business-rules "
                            },
                            {
                                "type": "text",
                                "text": "DSLs",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and what have you -- monads become rather economic and handy unifying framework. Obviously through "
                            },
                            {
                                "type": "text",
                                "text": "compositionality and abstraction",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": you can make any particular piece of code only dependent on effects it needs and completely oblivious to any other effects including ones that get added "
                            },
                            {
                                "type": "text",
                                "text": "later in development",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". And I'd like to point out that many of the mentioned effects in Haskell are implemented in "
                            },
                            {
                                "type": "text",
                                "text": "libraries",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and not built into the language. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "d9dab780-f43f-4da0-a8fa-3ac29623a8a9",
        "type": "message",
        "text": "<@UCUSW7WVD> May I ask for an exception for the specific case of interactive coding tools (IDE or otherwise)? They should be allowed to access exceptions in the code they manage at any level down the stack, for testing and debugging purposes.",
        "user": "UJBAJNFLK",
        "ts": "1631175900.162000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "r2gOp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " May I ask for an exception for the specific case of interactive coding tools (IDE or otherwise)? They should be allowed to access exceptions in the code they manage at any level down the stack, for testing and debugging purposes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "3ddcbc07-a514-4989-a2bd-2fcfea584c35",
        "type": "message",
        "text": "<@U027P92A0N5> What's the story about compositionality of effects today? When I looked at Haskell and its monads around 2007, monads were not composable. You had to switch to monad transformers which were a lot more complicated to use and understand.",
        "user": "UJBAJNFLK",
        "ts": "1631175999.162200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OQawQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U027P92A0N5"
                            },
                            {
                                "type": "text",
                                "text": " What's the story about compositionality of effects today? When I looked at Haskell and its monads around 2007, monads were not composable. You had to switch to monad transformers which were a lot more complicated to use and understand."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "e6ef0f98-f456-409a-af3a-9f2328e02204",
        "type": "message",
        "text": "<@UJBAJNFLK> No objection! Though it seems difficult to reconcile. Exceptions won't be caught by the environment if they're caught by an intervening stack frame, right?\n\nIt seems a difficult decision whether any given interface should return a value or throw an exception, and IDE features complicate this picture.",
        "user": "UCUSW7WVD",
        "ts": "1631176626.162500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LqgL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " No objection! Though it seems difficult to reconcile. Exceptions won't be caught by the environment if they're caught by an intervening stack frame, right?\n\nIt seems a difficult decision whether any given interface should return a value or throw an exception, and IDE features complicate this picture."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "88a1794f-d04b-4cec-b7d1-4425cd6a2551",
        "type": "message",
        "text": "<@UCUSW7WVD> With given languages and environments, yes, it's hard to implement. It should be doable with the Common Lisp condition system, if all code respects some conventions. And future languages could implement exception handling per component, rather than globally, and add a \"supervisor\" mode.",
        "user": "UJBAJNFLK",
        "ts": "1631180678.162800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ltg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " With given languages and environments, yes, it's hard to implement. It should be doable with the Common Lisp condition system, if all code respects some conventions. And future languages could implement exception handling per component, rather than globally, and add a \"supervisor\" mode."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "11082801-4f60-4198-b967-394d0c5ff597",
        "type": "message",
        "text": "<@UJBAJNFLK> yeah, monads are not composable in the sense they don't commute -- that's just their mathematical property and arguably the nature of effects we model (there are well-known exceptions and the laws governing those exceptions). So when I say \"monads\" I mean \"monad transformers\" too because to me they become inseparable (and quite natural) part of the picture. I even put the free(r) monadic DSLs into the conceptual mix.\n\nSo I guess for you the \"Haskell effects story\" became only more complicated. As long as this stuff is NOT built into the language but provided in libraries, there quite a number of such libraries implementing different approaches to effects composition including Monad Transformers-based (good 'ol MTL but also Capabilities and some others), Algebraic Effects-based, Free(r) Monads-based and maybe some other too.",
        "user": "U027P92A0N5",
        "ts": "1631181714.163000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d6900487d910",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-07-07\/2254853369060_d6900487d9109f495c79_72.jpg",
            "first_name": "Alexander",
            "real_name": "Alexander Chichigin",
            "display_name": "Alex Chichigin",
            "team": "T5TCAFTA9",
            "name": "sad.ronin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hfCm7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " yeah, monads are not composable in the sense they don't commute -- that's just their mathematical property and arguably the nature of effects we model (there are well-known exceptions and the laws governing those exceptions). So when I say \"monads\" I mean \"monad transformers\" too because to me they become inseparable (and quite natural) part of the picture. I even put the free(r) monadic DSLs into the conceptual mix.\n\nSo I guess for you the \"Haskell effects story\" became only more complicated. As long as this stuff is NOT built into the language but provided in libraries, there quite a number of such libraries implementing different approaches to effects composition including Monad Transformers-based (good 'ol MTL but also Capabilities and some others), Algebraic Effects-based, Free(r) Monads-based and maybe some other too."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "5c6294d9-dad7-424b-8ba9-7ab3d4b45ab3",
        "type": "message",
        "text": "Potentially in this direction could be something like <http:\/\/temporal.io|temporal.io> , which is a workflow language that makes keeping value in the stack for weeks at a time, a comfortable endeavor. (The contrast is usually we put values into a database so they can survive an upgrade over the course of the weeks)",
        "user": "UFPPABQ7P",
        "ts": "1631186340.163300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cb9d79e2bebc",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-09\/631538186901_cb9d79e2bebc09100b3f_72.jpg",
            "first_name": "Cole",
            "real_name": "Cole Lawrence",
            "display_name": "Cole",
            "team": "T5TCAFTA9",
            "name": "colelawr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UFPPABQ7P",
            "ts": "1631186360.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l243",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Potentially in this direction could be something like "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/temporal.io",
                                "text": "temporal.io"
                            },
                            {
                                "type": "text",
                                "text": " , which is a workflow language that makes keeping value in the stack for weeks at a time, a comfortable endeavor. (The contrast is usually we put values into a database so they can survive an upgrade over the course of the weeks)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6a360540-4fa3-4a03-81c2-53e31c76a1c5",
        "type": "message",
        "text": "Also, on another side of this that may or may not bear any fruit, is <https:\/\/www.liquidsoap.info\/|https:\/\/www.liquidsoap.info\/> , a language for programming media streams.",
        "user": "UFPPABQ7P",
        "ts": "1631186537.163600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cb9d79e2bebc",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-09\/631538186901_cb9d79e2bebc09100b3f_72.jpg",
            "first_name": "Cole",
            "real_name": "Cole Lawrence",
            "display_name": "Cole",
            "team": "T5TCAFTA9",
            "name": "colelawr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BIb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, on another side of this that may or may not bear any fruit, is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.liquidsoap.info\/",
                                "text": "https:\/\/www.liquidsoap.info\/"
                            },
                            {
                                "type": "text",
                                "text": " , a language for programming media streams."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "721db07f-c345-4948-8964-8f782e30b7e4",
        "type": "message",
        "text": "I don't really know enough about the Haskell end of this spectrum but my sense is that the units for it are probably something like \"percent of the code that has some kind of invariance guarantee\".\n\nIf you take something multi paradigm like Java or C++ it is possible to write very mathsy code by leaning in heavily on const, interfaces, classes etc. and earn yourself very strong guarantees about invariance over time. Different languages force or encourage you to bake more guarantees into your code but it's something that is possible in any language. Even something like Python, in the real world, will probably come with a stack of Organisational Practices and socially enforced norms that allow to _in practice_ make similar assumptions, even though you could in theory overwrite the + operator at runtime.\n\nAccepting these kinds of restrictions limits your expressivity but can superpower your understanding of a codebase because it lets you make massively compressing abstractions and draw very clean line_s (\"Ok... this can't *possibly* affect this... It must have come from A, B or C..._\").\n\nTime invariance is an affordance that lets you better \"play computer in your head\", as Bret Victor would say.\n\nSo basically I think the reason that Haskell programmers play down the actual execution of their code is they are backing themselves to have already run it accurately in their head beforehand.",
        "user": "UDQBTJ211",
        "ts": "1631193162.164400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NmnvA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't really know enough about the Haskell end of this spectrum but my sense is that the units for it are probably something like \"percent of the code that has some kind of invariance guarantee\".\n\nIf you take something multi paradigm like Java or C++ it is possible to write very mathsy code by leaning in heavily on const, interfaces, classes etc. and earn yourself very strong guarantees about invariance over time. Different languages force or encourage you to bake more guarantees into your code but it's something that is possible in any language. Even something like Python, in the real world, will probably come with a stack of Organisational Practices and socially enforced norms that allow to "
                            },
                            {
                                "type": "text",
                                "text": "in practice",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " make similar assumptions, even though you could in theory overwrite the + operator at runtime.\n\nAccepting these kinds of restrictions limits your expressivity but can superpower your understanding of a codebase because it lets you make massively compressing abstractions and draw very clean line"
                            },
                            {
                                "type": "text",
                                "text": "s (\"Ok... this can't ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "possibly",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " affect this... It must have come from A, B or C...",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\").\n\nTime invariance is an affordance that lets you better \"play computer in your head\", as Bret Victor would say.\n\nSo basically I think the reason that Haskell programmers play down the actual execution of their code is they are backing themselves to have already run it accurately in their head beforehand."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "37bd374a-db77-43f3-a290-c8f63bbf3865",
        "type": "message",
        "text": "I basically believe you should start from the opposite end.\n\nComputers are physical machines that literally, actually, move and change with the forward arrow of time as part of the physical universe. Because they change in very small ways and very quickly, they kind of fly below our intuition radar. They are also highly deterministic compared to naturally occurring phenomena.\n\nStill, they actually do perform an irreversible action just like a computer built out of metal ball bearings falling through chutes (<https:\/\/www.turingtumble.com\/>).\n\nIf you want to understand what happened, you should just record what happened and then interrogate that recording with a powerful suite of thinking tools.",
        "user": "UDQBTJ211",
        "ts": "1631193526.164600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H897",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I basically believe you should start from the opposite end.\n\nComputers are physical machines that literally, actually, move and change with the forward arrow of time as part of the physical universe. Because they change in very small ways and very quickly, they kind of fly below our intuition radar. They are also highly deterministic compared to naturally occurring phenomena.\n\nStill, they actually do perform an irreversible action just like a computer built out of metal ball bearings falling through chutes ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.turingtumble.com\/"
                            },
                            {
                                "type": "text",
                                "text": ").\n\nIf you want to understand what happened, you should just record what happened and then interrogate that recording with a powerful suite of thinking tools."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "151f51ed-e718-4265-95ea-5500d460eaa7",
        "type": "message",
        "text": "Temporal Logic of Actions sounds like an in between in your spectrum:\n\n&gt; This paper introduces TLA, which I now believe is the best general formalism for describing and reasoning about concurrent systems. The new idea in TLA is that one can use actions–formulas with primed and unprimed variables–in temporal formulas. An action describes a state-transition relation. For example, the action x’=x+1 means approximately the same thing as the programming-language statement x := x+1.\n<https:\/\/www.microsoft.com\/en-us\/research\/publication\/the-temporal-logic-of-actions\/>",
        "user": "UBN9AFS0N",
        "ts": "1631193660.164800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A\/Vr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Temporal Logic of Actions sounds like an in between in your spectrum:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This paper introduces TLA, which I now believe is the best general formalism for describing and reasoning about concurrent systems. The new idea in TLA is that one can use actions–formulas with primed and unprimed variables–in temporal formulas. An action describes a state-transition relation. For example, the action x’=x+1 means approximately the same thing as the programming-language statement x := x+1."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.microsoft.com\/en-us\/research\/publication\/the-temporal-logic-of-actions\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "6424ed83-992e-4d07-ae75-42317a6df55e",
        "type": "message",
        "text": "Dahl has a good talk about how monads in haskell could be a lot better.  (again, I'm not a haskell programmer)\n\n<@UCUSW7WVD> my point with the monads\/haskell (again, i'm not a haskell programmer) and the map analogy is that knowing only what the program does and not the options for doing that or the intent make debugging other people's code difficult.  if i only know what it is doing (arriving at a destination) and not the options for getting there (eg if i only have a line on a piece of paper with the turns and destination but no landmarks, roads, etc) then suddenly i need to do a lot of reading\/research instead of just taking another road when the freeway i need has construction.",
        "user": "U0264CJ5W83",
        "ts": "1631203692.165300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3142da7de3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-06-24\/2193499626679_e3142da7de3f64211bb6_72.jpg",
            "first_name": "",
            "real_name": "Tony O'Dell",
            "display_name": "Tony O'Dell",
            "team": "T5TCAFTA9",
            "name": "tony.odell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X4J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Dahl has a good talk about how monads in haskell could be a lot better.  (again, I'm not a haskell programmer)\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " my point with the monads\/haskell (again, i'm not a haskell programmer) and the map analogy is that knowing only what the program does and not the options for doing that or the intent make debugging other people's code difficult.  if i only know what it is doing (arriving at a destination) and not the options for getting there (eg if i only have a line on a piece of paper with the turns and destination but no landmarks, roads, etc) then suddenly i need to do a lot of reading\/research instead of just taking another road when the freeway i need has construction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "739d84c3-70ba-4f0c-ae80-cdfbf7f08828",
        "type": "message",
        "text": "<@U0264CJ5W83> do you have a link to that Dahl talk about monads at hand? Sounds pretty interesting. :slightly_smiling_face:",
        "user": "U027P92A0N5",
        "ts": "1631204516.165500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d6900487d910",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-07-07\/2254853369060_d6900487d9109f495c79_72.jpg",
            "first_name": "Alexander",
            "real_name": "Alexander Chichigin",
            "display_name": "Alex Chichigin",
            "team": "T5TCAFTA9",
            "name": "sad.ronin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kbon",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0264CJ5W83"
                            },
                            {
                                "type": "text",
                                "text": " do you have a link to that Dahl talk about monads at hand? Sounds pretty interesting. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "93F35BA6-AB4D-4C97-9C71-6D4A5A9E4EAE",
        "type": "message",
        "text": "This virtual time approach? <https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20|https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20>",
        "user": "UJFN50C00",
        "ts": "1631211675.166600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e35958b94f07",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-06\/616300651267_e35958b94f07da17cf17_72.png",
            "first_name": "Andreas",
            "real_name": "Andreas S.",
            "display_name": "curious_reader",
            "team": "T5TCAFTA9",
            "name": "andreas.scheinert",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "fallback": "<https:\/\/twitter.com\/codefrau|@codefrau>: What is <https:\/\/twitter.com\/croquetio|@croquetio> anyways?\n\nA thread :thread: <https:\/\/pbs.twimg.com\/tweet_video_thumb\/E9rrhZjVEAAplos.jpg>",
                "ts": 1629944207,
                "author_name": "Vanessa wrote a thing",
                "author_link": "https:\/\/twitter.com\/codefrau\/status\/1430715818115883008",
                "author_icon": "https:\/\/pbs.twimg.com\/profile_images\/1400712341600178176\/LNtov3Jt_normal.jpg",
                "author_subname": "@codefrau",
                "text": "What is <https:\/\/twitter.com\/croquetio|@croquetio> anyways?\n\nA thread :thread:",
                "service_name": "twitter",
                "service_url": "https:\/\/twitter.com\/",
                "from_url": "https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20",
                "thumb_url": "https:\/\/pbs.twimg.com\/tweet_video_thumb\/E9rrhZjVEAAplos.jpg",
                "thumb_width": 1200,
                "thumb_height": 675,
                "video_html_width": 1200,
                "video_html_height": 675,
                "video_html": "<video autoplay loop muted poster=\"https:\/\/pbs.twimg.com\/tweet_video_thumb\/E9rrhZjVEAAplos.jpg\" width=\"1200\" height=\"675\"><source type=\"video\/mp4\" src=\"https:\/\/video.twimg.com\/tweet_video\/E9rrhZjVEAAplos.mp4\"><\/video>",
                "id": 1,
                "original_url": "https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20",
                "footer": "Twitter",
                "footer_icon": "https:\/\/a.slack-edge.com\/80588\/img\/services\/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ODo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This virtual time approach? "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20",
                                "text": "https:\/\/twitter.com\/codefrau\/status\/1430715818115883008?s=20"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "28292229-29ac-4f3e-84a7-96fc5e48f27d",
        "type": "message",
        "text": "<@U0264CJ5W83> I'm again left with the sense this analogy would make a fantastic top-level thread (\"How can we illuminate a map of the neighborhood of a program in the  space of possible programs?\") but struggling to see how it connects up with exceptions. A map with a list of turns and destination but no landmarks, just alternative routes to the police station from each turn -- this wouldn't be a map either.",
        "user": "UCUSW7WVD",
        "ts": "1631218684.167300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AOt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0264CJ5W83"
                            },
                            {
                                "type": "text",
                                "text": " I'm again left with the sense this analogy would make a fantastic top-level thread (\"How can we illuminate a map of the neighborhood of a program in the  space of possible programs?\") but struggling to see how it connects up with exceptions. A map with a list of turns and destination but no landmarks, just alternative routes to the police station from each turn -- this wouldn't be a map either."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "63ad7d45-9693-4abc-9ac6-52c10bd814fc",
        "type": "message",
        "text": "<@UC2A2ARPT>\n&gt; Functional Programming is orthogonal to this spectrum\nI don’t get this. While I would normally think of functional programming as being on the timeless end of the spectrum, you make a good point that it can also be on other end. But isn’t it the case that programming styles that _contrast_ with FP often _do_ have to be structured in time? To pick from your examples, how would you have mutable values without modeling time? Or with `forEach`  don’t you need to have time to have side effects work?",
        "user": "UJZS8UUJV",
        "ts": "1631233109.167700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g62b260c347a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/962b260c347a11e19b0fdce4a97a5d49.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0001-72.png",
            "first_name": "Luke",
            "real_name": "Luke Persola",
            "display_name": "Luke Persola",
            "team": "T5TCAFTA9",
            "name": "lukepersola",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UJZS8UUJV",
            "ts": "1631233840.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EmDaM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Functional Programming is orthogonal to this spectrum"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don’t get this. While I would normally think of functional programming as being on the timeless end of the spectrum, you make a good point that it can also be on other end. But isn’t it the case that programming styles that "
                            },
                            {
                                "type": "text",
                                "text": "contrast",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with FP often "
                            },
                            {
                                "type": "text",
                                "text": "do",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have to be structured in time? To pick from your examples, how would you have mutable values without modeling time? Or with "
                            },
                            {
                                "type": "text",
                                "text": "forEach",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  don’t you need to have time to have side effects work?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "aea42a8b-cb4b-4045-ac15-4198eecd8658",
        "type": "message",
        "text": "<@UDQBTJ211>\nAre you taking an anti-abstraction stance that programmers should be be aware of time as it exists in the internals of the language\/environment they’re using (because they’ll have to deal with it eventually anyway)? Or are you just saying it’s good for them to think about\/deal with time in their code, but it’s OK if it’s abstracted into a different (likely more limited) form?",
        "user": "UJZS8UUJV",
        "ts": "1631237662.168000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g62b260c347a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/962b260c347a11e19b0fdce4a97a5d49.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0001-72.png",
            "first_name": "Luke",
            "real_name": "Luke Persola",
            "display_name": "Luke Persola",
            "team": "T5TCAFTA9",
            "name": "lukepersola",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iUsD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": "\nAre you taking an anti-abstraction stance that programmers should be be aware of time as it exists in the internals of the language\/environment they’re using (because they’ll have to deal with it eventually anyway)? Or are you just saying it’s good for them to think about\/deal with time in their code, but it’s OK if it’s abstracted into a different (likely more limited) form?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    }
]