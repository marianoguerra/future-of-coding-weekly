[
    {
        "client_msg_id": "14f94461-04cd-47d5-9333-85bd5d7d2bd3",
        "type": "message",
        "text": "Hi there! Here's part two of my \"Data Storage for Humans\" series:\n<https:\/\/fkohlgrueber.github.io\/blog\/data-storage-part-2\/>",
        "user": "UAL7940NM",
        "ts": "1610799148.017200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "Felix’s Blog",
                "title": "Data Storage for Humans - Part 2: Requirement implications",
                "title_link": "https:\/\/fkohlgrueber.github.io\/blog\/data-storage-part-2\/",
                "text": "This is the second part of my series “Data Storage for Humans”. In the first part, I analyzed different options regular users have for storing their data and the problems these options have. I then concluded by providing the following requirements for a “really good solution”. In this second part, I want to take a look at how these requirements affect possible solutions.",
                "fallback": "Felix’s Blog: Data Storage for Humans - Part 2: Requirement implications",
                "ts": 1610793956,
                "from_url": "https:\/\/fkohlgrueber.github.io\/blog\/data-storage-part-2\/",
                "id": 1,
                "original_url": "https:\/\/fkohlgrueber.github.io\/blog\/data-storage-part-2\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Awn6b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi there! Here's part two of my \"Data Storage for Humans\" series:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/fkohlgrueber.github.io\/blog\/data-storage-part-2\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610799148.017200",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1610799235.017400",
        "reply_users": [
            "UAL7940NM"
        ],
        "replies": [
            {
                "user": "UAL7940NM",
                "ts": "1610799235.017400"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "216dff8e-d137-4229-88f5-884d7bced7b3",
        "type": "message",
        "text": "As always, I'm looking forward to feedback and great discussions :+1:",
        "user": "UAL7940NM",
        "ts": "1610799235.017400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4AC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As always, I'm looking forward to feedback and great discussions "
                            },
                            {
                                "type": "emoji",
                                "name": "+1"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610799148.017200",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "fa8e19a6-3896-4362-bd25-4c72591eb12d",
        "type": "message",
        "text": "There are all the little systems inside our computers that are somewhat hidden from us, because we usually — even as developers — don't get to access them directly. The system takes care of that for us, and we get to benefit from faster image (de)compression or video de-\/encoding or disk encryption etc. with API calls that look just like any other API call, but hook into these other processing units offloading some work from the CPU.\n\nBut that's just half the picture. We also more and more program different processors explicitly, with completely different paradigms: CPUs, GPUs, TPUs, … If your OS lights up pixels on a screen, but doesn't utilize the dedicated graphics processing capabilities of your hardware, you are not using your system \"correctly\". Or at least as effectively and likely also efficiently as you could (should?).\n\nAnd it's only going to get worse, because this complexity is not going to go away. Now with Intel under extreme pressure the times of standardization are over. Sure, everybody will have SoCs soon, and it looks like a form of simplification. But market forces push everyone to differentiate, which will only lead to more complexity on that level. There might be a swing back to the opposite in the far future, when the landscape is much more fragmented than it is today and the commercial benefits of diversification have been used up so that consolidation can kick in again. Until then, it's going to be messy for a while.\n\nI wonder if projects with the goal of simplifying the stack are better off building against a virtualization layer instead of trying to keep up with the further diversifying landscape of hardware architectures. Basically, bring your own (virtual) machine (and perhaps even instruction set), and let the virtualization\/emulation figure out translation to actual hardware instructions. You'll likely do exactly that for testing already anyway.",
        "user": "U5STGTB3J",
        "ts": "1610800535.017600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=Pu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are all the little systems inside our computers that are somewhat hidden from us, because we usually — even as developers — don't get to access them directly. The system takes care of that for us, and we get to benefit from faster image (de)compression or video de-\/encoding or disk encryption etc. with API calls that look just like any other API call, but hook into these other processing units offloading some work from the CPU.\n\nBut that's just half the picture. We also more and more program different processors explicitly, with completely different paradigms: CPUs, GPUs, TPUs, … If your OS lights up pixels on a screen, but doesn't utilize the dedicated graphics processing capabilities of your hardware, you are not using your system \"correctly\". Or at least as effectively and likely also efficiently as you could (should?).\n\nAnd it's only going to get worse, because this complexity is not going to go away. Now with Intel under extreme pressure the times of standardization are over. Sure, everybody will have SoCs soon, and it looks like a form of simplification. But market forces push everyone to differentiate, which will only lead to more complexity on that level. There might be a swing back to the opposite in the far future, when the landscape is much more fragmented than it is today and the commercial benefits of diversification have been used up so that consolidation can kick in again. Until then, it's going to be messy for a while.\n\nI wonder if projects with the goal of simplifying the stack are better off building against a virtualization layer instead of trying to keep up with the further diversifying landscape of hardware architectures. Basically, bring your own (virtual) machine (and perhaps even instruction set), and let the virtualization\/emulation figure out translation to actual hardware instructions. You'll likely do exactly that for testing already anyway."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "097598f1-07b8-4409-9e09-21c52c6e7f07",
        "type": "message",
        "text": "&gt; What does the UX for programming look like if you also have to specify where computations happen?\nI love this question. I think this was one of <https:\/\/youtu.be\/gCWtkvDQ2ZI?t=2158|the fundamental questions> that drove the creation of the <https:\/\/www.unisonweb.org|Unison Language> iirc.",
        "user": "U01661S9F34",
        "ts": "1610829657.017900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1610830529.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yf+=7",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What does the UX for programming look like if you also have to specify where computations happen?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I love this question. I think this was one of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/gCWtkvDQ2ZI?t=2158",
                                "text": "the fundamental questions"
                            },
                            {
                                "type": "text",
                                "text": " that drove the creation of the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.unisonweb.org",
                                "text": "Unison Language"
                            },
                            {
                                "type": "text",
                                "text": " iirc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9875ba9a-daec-4146-a240-61a77386d292",
        "type": "message",
        "text": "In another life, when the first generation of Nvidia GPU's that supported CUDA were released, I was working under a National Science Foundation grant to port some algorithms related to GIS (among other things) to run on GPUs. The biggest problem was getting data from the CPU to the GPU and back. GPU's had relatively small onboard memory at the time, and it was very easy to saturate the PCI bus when trying to move the data back and forth. It proved to be a huge bottleneck, and really broke any illusions of \"a single machine.\"",
        "user": "U01661S9F34",
        "ts": "1610830386.018300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1610830401.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uXaT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In another life, when the first generation of Nvidia GPU's that supported CUDA were released, I was working under a National Science Foundation grant to port some algorithms related to GIS (among other things) to run on GPUs. The biggest problem was getting data from the CPU to the GPU and back. GPU's had relatively small onboard memory at the time, and it was very easy to saturate the PCI bus when trying to move the data back and forth. It proved to be a huge bottleneck, and really broke any illusions of \"a single machine.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d897fa52-66e7-41ca-91d7-c76891599564",
        "type": "message",
        "text": "Well, its not as if you get full programmability at different layers of the stack. Most of the time you have to confirm to specific protocols and data formats, with most of the programmability in a few layers (CPU, GPU, etc..).",
        "user": "U01JNTE35QS",
        "ts": "1610831250.020300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "97155db555c2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-13\/1631845309525_97155db555c2091ecd20_72.jpg",
            "first_name": "",
            "real_name": "Vijay Chakravarthy",
            "display_name": "Vijay Chakravarthy",
            "team": "T5TCAFTA9",
            "name": "vchakrav",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vlv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well, its not as if you get full programmability at different layers of the stack. Most of the time you have to confirm to specific protocols and data formats, with most of the programmability in a few layers (CPU, GPU, etc..)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610831250.020300",
        "reply_count": 5,
        "reply_users_count": 4,
        "latest_reply": "1611031860.036500",
        "reply_users": [
            "UCUSW7WVD",
            "UAVCC2X70",
            "U01JNTE35QS",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1610833038.020600"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1610997288.033500"
            },
            {
                "user": "U01JNTE35QS",
                "ts": "1611014750.036000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1611015905.036200"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1611031860.036500"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "8dce2c45-bd06-4a41-8319-bafe84ca0726",
        "type": "message",
        "text": "It's not clear to me who you're responding to. Could you move your note to under a thread please? Thank you!",
        "user": "UCUSW7WVD",
        "ts": "1610833038.020600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nP3FJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's not clear to me who you're responding to. Could you move your note to under a thread please? Thank you!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610831250.020300",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "61a044fc-9473-41e8-9595-c4cd6abfed77",
        "type": "message",
        "text": "&gt; *Perhaps all programming is distributed programming?*\nYes, yes, yes!\n\nIts just that we have established models and tools to create a \"single computer\" abstraction out of _certain kinds_ of smaller computers, e.g. the \"PC\" bundle.\n\nOne way I look at this is to see a bundle as having observable, consistent states and \"inner bundles\". Consider this statement in a C like language:\n`i = j + 1`\nThis \"C-system\" (language + runtime) executes the above statement - you have values for i and j, then after the step, you have a new value for i. To simplify you have the \"state before\" and \"state after\". But if we look at the same system as a collection of \"inner-systems\", the transition consists of various nested states such as moving bits from memory to a register, an operation on the register, then moving it back to anther place in memory. Now the question is: if the first MOV has happened, but addition has not, what is the state _in terms of the C-computer?_ It's not inconsistent, maybe it's in transition? Certainly it is on its way to being consistent and visible in outer system. We can go deeper than MOV - a register isn't a single physical array of memory in the CPU (neither is a \"location in memory\") - theres caches and other kinds of _inner-systems_ all the way. One observable transition in the outer system contains many transitions in the inner systems.\n\n&gt; What does the UX for programming look like if you also have to specify where computations happen?\nThis has been on my mind too and I think for certain parts of programs, we specifically don't want to specify where the computation happens. This is what I sometimes call _topology_ _independent_ programs. Note that location presumes a addressing space. Above, in the C-system, there is no location (the C-system is whole world) and when we zoom into it, we see locations such as cpu, ram, AX, BX or whatever. The compiler made that mapping for us - it organized the inner systems to appear as if its one outer system. (But we could have too, and there are many alternative locations and ways to map that would have all worked out just fine). However if we zoom out from the C-system to a distributed database (or whatever it is part of), the single C-system is now one location in a larger address space, but the database-system will have location independent concepts like a _table_. I think to specify _where_ computation happens, we need to build this idea of mapping the outer-system meaning to the inner-system meaning and distinct address spaces. To do this in a general way would mean we can always scale out to the next level using the same mapping ideas as we did at the previous step out.",
        "user": "U8A5MS6R1",
        "ts": "1610851829.020900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jfn",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps all programming is distributed programming?",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, yes, yes!\n\nIts just that we have established models and tools to create a \"single computer\" abstraction out of "
                            },
                            {
                                "type": "text",
                                "text": "certain kinds",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of smaller computers, e.g. the \"PC\" bundle.\n\nOne way I look at this is to see a bundle as having observable, consistent states and \"inner bundles\". Consider this statement in a C like language:\n"
                            },
                            {
                                "type": "text",
                                "text": "i = j + 1",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nThis \"C-system\" (language + runtime) executes the above statement - you have values for i and j, then after the step, you have a new value for i. To simplify you have the \"state before\" and \"state after\". But if we look at the same system as a collection of \"inner-systems\", the transition consists of various nested states such as moving bits from memory to a register, an operation on the register, then moving it back to anther place in memory. Now the question is: if the first MOV has happened, but addition has not, what is the state "
                            },
                            {
                                "type": "text",
                                "text": "in terms of the C-computer? ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "It's not inconsistent, maybe it's in transition? Certainly it is on its way to being consistent and visible in outer system. We can go deeper than MOV - a register isn't a single physical array of memory in the CPU (neither is a \"location in memory\") - theres caches and other kinds of "
                            },
                            {
                                "type": "text",
                                "text": "inner-systems",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " all the way. One observable transition in the outer system contains many transitions in the inner systems.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What does the UX for programming look like if you also have to specify where computations happen?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This has been on my mind too and I think for certain parts of programs, we specifically don't want to specify where the computation happens. This is what I sometimes call "
                            },
                            {
                                "type": "text",
                                "text": "topology",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "independent",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " programs. Note that location presumes a addressing space. Above, in the C-system, there is no location (the C-system is whole world) and when we zoom into it, we see locations such as cpu, ram, AX, BX or whatever. The compiler made that mapping for us - it organized the inner systems to appear as if its one outer system. (But we could have too, and there are many alternative locations and ways to map that would have all worked out just fine). However if we zoom out from the C-system to a distributed database (or whatever it is part of), the single C-system is now one location in a larger address space, but the database-system will have location independent concepts like a "
                            },
                            {
                                "type": "text",
                                "text": "table",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I think to specify "
                            },
                            {
                                "type": "text",
                                "text": "where",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " computation happens, we need to build this idea of mapping the outer-system meaning to the inner-system meaning and distinct address spaces. To do this in a general way would mean we can always scale out to the next level using the same mapping ideas as we did at the previous step out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UKDM3GLAJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6F63C5D8-CD60-436B-B79E-1B1CEC7919B1",
        "type": "message",
        "text": "my favorite part of the mother of all demos is when the shopping list becomes the map of your commute home via all the stores for the shopping list",
        "user": "UHWC9PXBL",
        "ts": "1610854140.022000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "StM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "my favorite part of the mother of all demos is when the shopping list becomes the map of your commute home via all the stores for the shopping list"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610742663.002400"
    },
    {
        "client_msg_id": "2A0DCD3C-0992-40FE-80D0-E559BCAD91D7",
        "type": "message",
        "text": "this is a great thread and i’m mostly commenting to get notified, but the one thing i’d like to point out is that for whatever reason, it’s pretty _easy_ to forget (or never learn) that all these chips are working together. it’s pretty rare that just the microcontroller for your ram stick needs to be restarted, and it’s even rarer that a failing stick corrupts your word documents. are there any system design lessons we can learn from that? why is it easier to make these smaller and cheaper components reliable than it is to make servers reliable?",
        "user": "UHWC9PXBL",
        "ts": "1610854517.027100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GXeet",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is a great thread and i’m mostly commenting to get notified, but the one thing i’d like to point out is that for whatever reason, it’s pretty "
                            },
                            {
                                "type": "text",
                                "text": "easy",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to forget (or never learn) that all these chips are working together. it’s pretty rare that just the microcontroller for your ram stick needs to be restarted, and it’s even rarer that a failing stick corrupts your word documents. are there any system design lessons we can learn from that? why is it easier to make these smaller and cheaper components reliable than it is to make servers reliable?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]