[
    {
        "client_msg_id": "3cad400f-6d15-4dc0-a9b0-df69ece94084",
        "type": "message",
        "text": "\"zero does not need traditional version control systems, as every program contains its own history\" it sounds like the language somehow requires people to keep historical baggage around, including bugs?",
        "user": "UD6EXQVM0",
        "ts": "1610073148.432200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9PA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"zero does not need traditional version control systems, as every program contains its own history\" it sounds like the language somehow requires people to keep historical baggage around, including bugs?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0e537b25-dc15-4958-9a4f-b329aa29accf",
        "type": "message",
        "text": "I've had this idea that modules (not mere types) should be optionally parameterized, like, you could say \"this module uses 'strings' and two kinds of 'number' which by default are UTF-8 strings, 32-bit fixed-point and 64-bit float, but the user of this module can override the default with their own choices\". I wonder if Abstract Types are like that.",
        "user": "UD6EXQVM0",
        "ts": "1610074221.432500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JBqA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've had this idea that modules (not mere types) should be optionally parameterized, like, you could say \"this module uses 'strings' and two kinds of 'number' which by default are UTF-8 strings, 32-bit fixed-point and 64-bit float, but the user of this module can override the default with their own choices\". I wonder if Abstract Types are like that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "410bb959-3bfe-4b65-9453-f4f4458e7d95",
        "type": "message",
        "text": "When you say \"when we run main(), we get a friendly little beep at the same time\" do you literally mean that `out$ &lt;&lt; \"hello world !\"` and `audio$ &lt;&lt; sample(\"beep.wav\")` run concurrently?",
        "user": "UD6EXQVM0",
        "ts": "1610074600.432700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9LOPX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you say \"when we run main(), we get a friendly little beep at the same time\" do you literally mean that "
                            },
                            {
                                "type": "text",
                                "text": "out$ << \"hello world !\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "audio$ << sample(\"beep.wav\")",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " run concurrently?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "fbbad711-42a6-4fdb-96ad-6eba5d2cf3e0",
        "type": "message",
        "text": "What is the meaning of all those dollar signs?\n\n\"results are named, and assignment of the result terminates the function\" it sounds like you're breaking tradition in a confusing unhelpful way. There is an established tradition called `return` for terminating a function, whereas assigning to named results (a la Visual Basic) should not terminate the function. Personally I would like both mechanisms to be available.\n\nThat one can define an \"inner\" function that isn't inner (is directly accessible outside the outer function - are you saying that it is accessible _unqualified_?) - this doesn't seem like a bad feature to me per se, but this behavior should be something the programmer asks for, not implicit.\n\nOrdinary functions cannot accept arrays? How is this not a crippling restriction? Is this a limitation of GPUs (I haven't programmed any before)? If so how do GPU programmers work around it? I can't imagine how to write a compiler that processes arbitrary syntax/semantic trees on a GPU. Do you know how to write the zero language in itself?\n\n\"a task is a pair of values; one is being read from (the 'current' value) and the other is being written to\" Why isn't it a queue, or an LMAX disruptor or something?\n\nHave you studied Halide for inspiration?",
        "user": "UD6EXQVM0",
        "ts": "1610076015.432900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z=K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What is the meaning of all those dollar signs?\n\n\"results are named, and assignment of the result terminates the function\" it sounds like you're breaking tradition in a confusing unhelpful way. There is an established tradition called "
                            },
                            {
                                "type": "text",
                                "text": "return",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for terminating a function, whereas assigning to named results (a la Visual Basic) should not terminate the function. Personally I would like both mechanisms to be available.\n\nThat one can define an \"inner\" function that isn't inner (is directly accessible outside the outer function - are you saying that it is accessible "
                            },
                            {
                                "type": "text",
                                "text": "unqualified",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "?) - this doesn't seem like a bad feature to me per se, but this behavior should be something the programmer asks for, not implicit.\n\nOrdinary functions cannot accept arrays? How is this not a crippling restriction? Is this a limitation of GPUs (I haven't programmed any before)? If so how do GPU programmers work around it? I can't imagine how to write a compiler that processes arbitrary syntax/semantic trees on a GPU. Do you know how to write the zero language in itself?\n\n\"a task is a pair of values; one is being read from (the 'current' value) and the other is being written to\" Why isn't it a queue, or an LMAX disruptor or something?\n\nHave you studied Halide for inspiration?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "1cbe4205-e5d7-4825-97c5-57b0fddd1936",
        "type": "message",
        "text": "<@UD6EXQVM0> thanks for reading ! I'll take them from the top ...",
        "user": "U01JTCA3KS4",
        "ts": "1610097292.433200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qR7Si",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " thanks for reading ! I'll take them from the top ..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "55151bba-9094-48a0-afed-8c891ecfeed0",
        "type": "message",
        "text": "\"baggage\" : yes, the idea is that effectively the version control history of the software and the software are one and the same, i.e. a program is a gigantic sphere composed entirely of sticky plasters. I honestly don't know if this scheme is workable at all for real projects - that's kind of why I'm building it, to find out. My thoughts are that it can be made to work, because : 1) usually when I want to modify a program, I'll be able to narrow my focus down to the feature that causes the behaviour I want to change, and its ancestors/descendants, leaving all other code out of consideration; in my metaphor above, that means zeroing in on the one sticky plaster that matters, understanding how it works, and adding another sticky plaster 2) I can imagine optimisations where we detect 'dead code' (that can no longer run) and get rid of it / archive it / something like that; 3) something clever that we'll invent when we run into the need for it ?",
        "user": "U01JTCA3KS4",
        "ts": "1610097867.433400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4xJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"baggage\" : yes, the idea is that effectively the version control history of the software and the software are one and the same, i.e. a program is a gigantic sphere composed entirely of sticky plasters. I honestly don't know if this scheme is workable at all for real projects - that's kind of why I'm building it, to find out. My thoughts are that it can be made to work, because : 1) usually when I want to modify a program, I'll be able to narrow my focus down to the feature that causes the behaviour I want to change, and its ancestors/descendants, leaving all other code out of consideration; in my metaphor above, that means zeroing in on the one sticky plaster that matters, understanding how it works, and adding another sticky plaster 2) I can imagine optimisations where we detect 'dead code' (that can no longer run) and get rid of it / archive it / something like that; 3) something clever that we'll invent when we run into the need for it ?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "0b0511fd-011d-4ec1-8255-be7f36a4394d",
        "type": "message",
        "text": "Abstract types are my response to a historical event in our own code base, when we moved from 32-bit to 64-bit. I realised there were lots of uses of \"int\" where the author genuinely did not care how many bits were used (\"just use enough bits !\"), but lots of other cases where they did genuinely care, because reasons. So I wanted to be able to distinguish between these - therefore in zero when I say \"i32\" I mean \"signed integer with 32 bits\" but when I say \"int\" I mean \"integer\" which means \"signed or unsigned, and I don't care how many bits you use, *figure it out*\"",
        "user": "U01JTCA3KS4",
        "ts": "1610098098.433600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MoeW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Abstract types are my response to a historical event in our own code base, when we moved from 32-bit to 64-bit. I realised there were lots of uses of \"int\" where the author genuinely did not care how many bits were used (\"just use enough bits !\"), but lots of other cases where they did genuinely care, because reasons. So I wanted to be able to distinguish between these - therefore in zero when I say \"i32\" I mean \"signed integer with 32 bits\" but when I say \"int\" I mean \"integer\" which means \"signed or unsigned, and I don't care how many bits you use, *figure it out*\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "bbc2cb2d-4fe2-4c5c-ae03-74faea71c72a",
        "type": "message",
        "text": "They're also a throwback to my compsci dissertation which was on something called Order Sorted Algebras, which proposed a different meaning for \"subtyping\"; saying \"A is a subtype of B\" means \"every A is a B, but not every B is an A\", i.e. \"Square is a subtype of Rect\", even though Square has one property and Rect has two.",
        "user": "U01JTCA3KS4",
        "ts": "1610098167.433800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ydr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "They're also a throwback to my compsci dissertation which was on something called Order Sorted Algebras, which proposed a different meaning for \"subtyping\"; saying \"A is a subtype of B\" means \"every A is a B, but not every B is an A\", i.e. \"Square is a subtype of Rect\", even though Square has one property and Rect has two."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "2eca67c4-b08f-47d4-a7b4-b356f24be46b",
        "type": "message",
        "text": "So I can write a bunch of code using the 'number' abstract type, and if it gets compiled for a TPU that's great at 16-bit floats, it will use those, but if it gets compiled for an FPGA that can only do 8-bit integers, it will use those instead. That's the general idea.",
        "user": "U01JTCA3KS4",
        "ts": "1610098257.434000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610100786.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4ji",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So I can write a bunch of code using the 'number' abstract type, and if it gets compiled for a TPU that's great at 16-bit floats, it will use those, but if it gets compiled for an FPGA that can only do 8-bit integers, it will use those instead. That's the general idea."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "47272232-9471-4e14-8ac2-1542bbeb17f7",
        "type": "message",
        "text": "\"when we run main(), we get a friendly little beep at the same time\" : yes, the two tasks run concurrently. There's a bunch of work to do on how to manage conflicts between features that don't know about each other (eg. what if two separate tasks both play audio or write text at the same time - how do we resolve that ?) but I'm assuming they can be resolved",
        "user": "U01JTCA3KS4",
        "ts": "1610098554.434200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pZp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"when we run main(), we get a friendly little beep at the same time\" : yes, the two tasks run concurrently. There's a bunch of work to do on how to manage conflicts between features that don't know about each other (eg. what if two separate tasks both play audio or write text at the same time - how do we resolve that ?) but I'm assuming they can be resolved"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "3c0a35ce-30fc-46ef-844a-89443bc6315b",
        "type": "message",
        "text": "\"What is the meaning of all those dollar signs?\" Actually those are borrowed from the first language I ever programmed in, BBC BASIC - they're pronounced \"string\", so i$ would be \"i-string\". I hit on that as the character to use because it felt like the right thing, but I'm not especially wedded to that specific character. \"int i$\" means \"a task that generates a stream of int over multiple frames\" ('frames' =&gt; clock ticks or whatever - that's not fully elucidated in the document yet). For the moment you can think of them as generators. I'm also not crazy about the \"&lt;&lt;\" but I've yet to think of something better. Open to suggestions.",
        "user": "U01JTCA3KS4",
        "ts": "1610098683.434400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610098729.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OfGT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"What is the meaning of all those dollar signs?\" Actually those are borrowed from the first language I ever programmed in, BBC BASIC - they're pronounced \"string\", so i$ would be \"i-string\". I hit on that as the character to use because it felt like the right thing, but I'm not especially wedded to that specific character. \"int i$\" means \"a task that generates a stream of int over multiple frames\" ('frames' => clock ticks or whatever - that's not fully elucidated in the document yet). For the moment you can think of them as generators. I'm also not crazy about the \"<<\" but I've yet to think of something better. Open to suggestions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "5cd577d6-ff93-45bf-a814-c215c987902a",
        "type": "message",
        "text": "\"\"results are named, and assignment of the result terminates the function\" it sounds like you're breaking tradition in a confusing unhelpful way\" - I did agonise over this for a while. It's actually a response to the huge mess in C++ over their recent move semantics - I wanted to break from the idea that there is an implicit stack and we're copying things around, and make it feel more like \"writing results to a variable that already exists\", the way we do in assembly language, or \"term rewriting\", where the intent is more like \"when you see this pattern, replace it with this pattern\". Also, in most C++ code I write, I invariably end up declaring a named variable eg \"result\" and then going \"return result\" at the end. So this just makes that cleaner. I also like that it lets me use very similar notation for functions and tasks, with just the operator (= or &lt;&lt;) changing.  I definitely take your point that it is different, but for the moment I'm giving myself permission to break tradition wherever it feels right !",
        "user": "U01JTCA3KS4",
        "ts": "1610099279.434700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S2hz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"\"results are named, and assignment of the result terminates the function\" it sounds like you're breaking tradition in a confusing unhelpful way\" - I did agonise over this for a while. It's actually a response to the huge mess in C++ over their recent move semantics - I wanted to break from the idea that there is an implicit stack and we're copying things around, and make it feel more like \"writing results to a variable that already exists\", the way we do in assembly language, or \"term rewriting\", where the intent is more like \"when you see this pattern, replace it with this pattern\". Also, in most C++ code I write, I invariably end up declaring a named variable eg \"result\" and then going \"return result\" at the end. So this just makes that cleaner. I also like that it lets me use very similar notation for functions and tasks, with just the operator (= or <<) changing.  I definitely take your point that it is different, but for the moment I'm giving myself permission to break tradition wherever it feels right !"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "16db9631-c071-48e4-a82d-eaf131b0d743",
        "type": "message",
        "text": "\"inner\" function that isn't inner - yeah, I think you're right there; or maybe the other way round, that they're outer by default, but you can make them inner somehow. Where this comes from is that I noticed that when I'm writing C++ code in a straight line, I invariably end up with blocks of code that look like\n```// now I'm going to do something with (x)\nstatement1(x);\nstatement2(x);\nstatement3(x);```\nand then later on I think \"wow, I should really make that into a function\", but I'm too busy and lazy and whatever, and it's a pain in the arse, so I don't do it. Or, worse, I do it, and now the code (statement1-3) is somewhere else, and to understand what's happening I have to jump to another bit of code, and it's just ... klunky. Hence the idea of combined call-and-define; instead of the above, I just do\n```doSomething(x)\n    statement1(x)\n    statement2(x)\n    statement3(x)```\nIt's *definitely* a weird / quirky / controversial thing to do, but actually once you start writing code like that, it feels natural - you're not breaking flow all the time to create functions, you just create them and use them in the same breath.",
        "user": "U01JTCA3KS4",
        "ts": "1610099666.434900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610101389.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cDi5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"inner\" function that isn't inner - yeah, I think you're right there; or maybe the other way round, that they're outer by default, but you can make them inner somehow. Where this comes from is that I noticed that when I'm writing C++ code in a straight line, I invariably end up with blocks of code that look like\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "// now I'm going to do something with (x)\nstatement1(x);\nstatement2(x);\nstatement3(x);"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and then later on I think \"wow, I should really make that into a function\", but I'm too busy and lazy and whatever, and it's a pain in the arse, so I don't do it. Or, worse, I do it, and now the code (statement1-3) is somewhere else, and to understand what's happening I have to jump to another bit of code, and it's just ... klunky. Hence the idea of combined call-and-define; instead of the above, I just do\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "doSomething(x)\n    statement1(x)\n    statement2(x)\n    statement3(x)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's "
                            },
                            {
                                "type": "text",
                                "text": "definitely",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a weird / quirky / controversial thing to do, but actually once you start writing code like that, it feels natural - you're not breaking flow all the time to create functions, you just create them and use them in the same breath."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "a29814de-f8fa-4f02-8a9a-c550187f41c2",
        "type": "message",
        "text": "\"Ordinary functions cannot accept arrays? How is this not a crippling restriction?\" - yes, definitely, this one is an eyebrow-raiser. Functions are defined as \"operations on values of rank 0 only\".\nThe motivation is that (combined with array variable names having to end with square brackets) it gives us a very clean syntax for map and reduce operations; so I can look at\n```c = a + b```\nand know immediately that this is a singular operation, because c, a and b are singular values; I don't have to go back and see where they were declared to figure out what their array-rank is (which is a constant source of confusion for me in numpy, C++, etc). Conversely, when I see\n```c[] = a[] + b[]```\nI know immediately that it's a mapping operation, because I know \"+\" only takes singular values.\nThe reason this isn't crippling is that structure properties can be arrays, so I can \"smuggle\" an array into a function by wrapping it in a structure; but crucially, this manoeuvre forces me to specify semantics. So, for instance, if I have an array of vertices and I want to perform some operation on them, I have to wrap them into another structure (eg. Mesh) and now they are properly typed, so I know what's going on.\nWhat's not good about this (apart from it being super weird compared to all existing languages, which as you may have guessed by now isn't my major concern :wink:) is that I'm still unsure how to specify actual array-modifying operations like concatenation, slicing, and so on. I've got a few ideas, of course.",
        "user": "U01JTCA3KS4",
        "ts": "1610100102.435100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610101462.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2pvm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Ordinary functions cannot accept arrays? How is this not a crippling restriction?\" - yes, definitely, this one is an eyebrow-raiser. Functions are defined as \"operations on values of rank 0 only\".\nThe motivation is that (combined with array variable names having to end with square brackets) it gives us a very clean syntax for map and reduce operations; so I can look at\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "c = a + b"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and know immediately that this is a singular operation, because c, a and b are singular values; I don't have to go back and see where they were declared to figure out what their array-rank is (which is a constant source of confusion for me in numpy, C++, etc). Conversely, when I see\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "c[] = a[] + b[]"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know immediately that it's a mapping operation, because I know \"+\" only takes singular values.\nThe reason this isn't crippling is that structure properties can be arrays, so I can \"smuggle\" an array into a function by wrapping it in a structure; but crucially, this manoeuvre forces me to specify semantics. So, for instance, if I have an array of vertices and I want to perform some operation on them, I have to wrap them into another structure (eg. Mesh) and now they are properly typed, so I know what's going on.\nWhat's not good about this (apart from it being super weird compared to all existing languages, which as you may have guessed by now isn't my major concern "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": ") is that I'm still unsure how to specify actual array-modifying operations like concatenation, slicing, and so on. I've got a few ideas, of course."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "74ce0b8e-8a73-4496-a7f2-141fa5d3a34a",
        "type": "message",
        "text": "\"a task is a pair of values; one is being read from (the 'current' value) and the other is being written to\" - sure, it could be a queue, and probably will end up going that way. This came from the graphics thing of \"front buffer and back buffer\", the idea that one value is being read while the other is being written, and they swap over at a specific and precise time, even if the computation of the new value is slow, or happens earlier, or both. In fact, under the hood, most of the time we can optimise that away, if there are no concurrent reads happening; and then for things like lexers we can imagine wanting to look forward or backwards in time, so yeah, a queue or another structure under the hood is a great idea. I just haven't got to that part yet !",
        "user": "U01JTCA3KS4",
        "ts": "1610100470.435400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610101002.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "G1J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"a task is a pair of values; one is being read from (the 'current' value) and the other is being written to\" - sure, it could be a queue, and probably will end up going that way. This came from the graphics thing of \"front buffer and back buffer\", the idea that one value is being read while the other is being written, and they swap over at a specific and precise time, even if the computation of the new value is slow, or happens earlier, or both. In fact, under the hood, most of the time we can optimise that away, if there are no concurrent reads happening; and then for things like lexers we can imagine wanting to look forward or backwards in time, so yeah, a queue or another structure under the hood is a great idea. I just haven't got to that part yet !"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "089f9d5d-54dd-46b9-9acb-f957e7419760",
        "type": "message",
        "text": "re. Halide, I haven't looked at it in depth, but it's awesome. Thanks for the tip, will study that a bit more.",
        "user": "U01JTCA3KS4",
        "ts": "1610100556.435600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9O7id",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "re. Halide, I haven't looked at it in depth, but it's awesome. Thanks for the tip, will study that a bit more."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "3437bd81-9487-44e6-851f-359d0d8b9715",
        "type": "message",
        "text": "Ooh I'll have to check this out soon! <@U01GPM3BY4R> do you think something like this would translate well to a VR environment? I've been exploring some VR apps, but haven't found many that use mechanical metaphors for programming",
        "user": "U013866H7LY",
        "ts": "1610134960.436500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pkiI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ooh I'll have to check this out soon! "
                            },
                            {
                                "type": "user",
                                "user_id": "U01GPM3BY4R"
                            },
                            {
                                "type": "text",
                                "text": " do you think something like this would translate well to a VR environment? I've been exploring some VR apps, but haven't found many that use mechanical metaphors for programming"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609951702.421800",
        "parent_user_id": "U01GPM3BY4R"
    },
    {
        "client_msg_id": "d020b209-0f3b-4fe0-9115-b619676ddc93",
        "type": "message",
        "text": "<@U013866H7LY> I think VR could be really cool, to create the (in progress) printer in the video I didn't have to enter a single line of code, all the design, the motion and logic are entirely visual so it's quite a good fit for VR I think. There are a few things that I want to implement first, because I promised people (like avatar mode from my first video on youtube) but I'll definitely give VR a shot at some point.",
        "user": "U01GPM3BY4R",
        "ts": "1610135960.436700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01GPM3BY4R",
            "ts": "1610136285.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WqE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013866H7LY"
                            },
                            {
                                "type": "text",
                                "text": " I think VR could be really cool, to create the (in progress) printer in the video I didn't have to enter a single line of code, all the design, the motion and logic are entirely visual so it's quite a good fit for VR I think. There are a few things that I want to implement first, because I promised people (like avatar mode from my first video on youtube) but I'll definitely give VR a shot at some point."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609951702.421800",
        "parent_user_id": "U01GPM3BY4R",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013866H7LY",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a40743ea-567a-4e40-8c93-581126fcc1c0",
        "type": "message",
        "text": ":smile: will keep an eye on things either way",
        "user": "U013866H7LY",
        "ts": "1610138774.437100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zkCm2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " will keep an eye on things either way"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609951702.421800",
        "parent_user_id": "U01GPM3BY4R",
        "reactions": [
            {
                "name": "grin",
                "users": [
                    "U01GPM3BY4R"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U01GPM3BY4R"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "27c73477-e245-47cb-910c-31e7897a2626",
        "type": "message",
        "text": "Yeah, stay tuned, the second part of the printer, reading cartridges to print different things that you can swap out will look cool I think, I'll make a full build video once it's done, including how I built the 7 segment displays from scratch. And thanks for bringing up the VR stuff, people keep mentioning it so just now I sent an email to my university's VR lab, maybe they want to collaborate or something.",
        "user": "U01GPM3BY4R",
        "ts": "1610139292.437500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01GPM3BY4R",
            "ts": "1610139341.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D+ee",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, stay tuned, the second part of the printer, reading cartridges to print different things that you can swap out will look cool I think, I'll make a full build video once it's done, including how I built the 7 segment displays from scratch. And thanks for bringing up the VR stuff, people keep mentioning it so just now I sent an email to my university's VR lab, maybe they want to collaborate or something."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609951702.421800",
        "parent_user_id": "U01GPM3BY4R"
    }
]