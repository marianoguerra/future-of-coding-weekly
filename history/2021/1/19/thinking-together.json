[
    {
        "client_msg_id": "93bf6ac1-f548-4e9d-8fc4-d35845236c45",
        "type": "message",
        "text": "That video is depressing, considering that what we have today in terms of \"personal dynamic media\" is at the same time more complicated and more limited. As far as I can see, even today's Smalltalks (Squeak, Pharo) don't support this.",
        "user": "UJBAJNFLK",
        "ts": "1611050680.037000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x4Mb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That video is depressing, considering that what we have today in terms of \"personal dynamic media\" is at the same time more complicated and more limited. As far as I can see, even today's Smalltalks (Squeak, Pharo) don't support this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b043e7c0-a0f4-463a-bb7a-7daddbd89796",
        "type": "message",
        "text": "<@UCUSW7WVD> sure, will post here when I get it working. I'm using <https:\/\/github.com\/michaelengel\/crosstalk> as a base, with modifications to support the smalltalk version used above",
        "user": "U0112C10V4Y",
        "ts": "1611079635.037300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf521cc065bb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Naveen Michaud-Agrawal",
            "display_name": "Naveen Michaud-Agrawal",
            "team": "T5TCAFTA9",
            "name": "naveen.michaudagrawal",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U0112C10V4Y",
            "ts": "1611079678.000000"
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "michaelengel\/crosstalk",
                "title_link": "https:\/\/github.com\/michaelengel\/crosstalk",
                "text": "Smalltalk-80 bare metal implementation for the Raspberry Pi - michaelengel\/crosstalk",
                "fallback": "GitHub: michaelengel\/crosstalk",
                "thumb_url": "https:\/\/avatars1.githubusercontent.com\/u\/21115737?s=400&v=4",
                "from_url": "https:\/\/github.com\/michaelengel\/crosstalk",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/michaelengel\/crosstalk"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V7il",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " sure, will post here when I get it working. I'm using "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/michaelengel\/crosstalk"
                            },
                            {
                                "type": "text",
                                "text": " as a base, with modifications to support the smalltalk version used above"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "08128cd8-e262-4695-8d76-b667f7b3961b",
        "type": "message",
        "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions (especially something as high level as an actor model) because the constraints and failure cases tend to be wildly different",
        "user": "UBSMEUXAA",
        "ts": "1611081030.037700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Oi7Pf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions (especially something as high level as an actor model) because the constraints and failure cases tend to be wildly different"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3ba188d4-a687-49e9-93b5-d65703557c89",
        "type": "message",
        "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies",
        "user": "UBSMEUXAA",
        "ts": "1611081432.037900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JT2L",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "242e9f16-05a1-43db-8e10-da27218f10b1",
        "type": "message",
        "text": "but in a true distributed system (you usually) care about robustness for potentially many machines that have much different uptime requirements than a consumer device",
        "user": "UBSMEUXAA",
        "ts": "1611081494.038100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lVNuG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but in a true distributed system (you usually) care about robustness for potentially many machines that have much different uptime requirements than a consumer device"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "617f0be9-0e7f-46d8-b113-3c2a1ecc5d33",
        "type": "message",
        "text": "<@UBSMEUXAA> I'm going to play devils advocate here :smiling_imp:\n&gt; I don't know of any consumer hardware that will continue to run if say, its GPU just dies\nI have a direct counter example:\nI have two GPU's in my laptop, the one bundled with my CPU, and an \"external\" Nvidia card. The Nvidia card regularly has driver failures and my laptop falls back to the on die graphics card.\n\nThis is almost seamless, and very much a distributed system. OS kernels handle these kind of driver failures all the time, and they are conceptually very similar to a distributed database that experiences a network partition.\n\nSome more extreme examples are Plan9 \"everything is a file\" and EMACS TRAMP. Both are examples of abstractions that cross both file system and network boundaries with similar semantics and error cases.\n\nreferring back to my earlier story about my National Science Foundation work, there was one group of grad students working on GPU's, and another group working on distributed graph algorithms on AWS. We were part of the same umbrella project, and regularly exchanged ideas about how to solve problems.\n\nThe constraints and failure cases are not wildly different at all imo.",
        "user": "U01661S9F34",
        "ts": "1611094589.038500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PCx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBSMEUXAA"
                            },
                            {
                                "type": "text",
                                "text": " I'm going to play devils advocate here "
                            },
                            {
                                "type": "emoji",
                                "name": "smiling_imp"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have a direct counter example:\nI have two GPU's in my laptop, the one bundled with my CPU, and an \"external\" Nvidia card. The Nvidia card regularly has driver failures and my laptop falls back to the on die graphics card.\n\nThis is almost seamless, and very much a distributed system. OS kernels handle these kind of driver failures all the time, and they are conceptually very similar to a distributed database that experiences a network partition.\n\nSome more extreme examples are Plan9 \"everything is a file\" and EMACS TRAMP. Both are examples of abstractions that cross both file system and network boundaries with similar semantics and error cases.\n\nreferring back to my earlier story about my National Science Foundation work, there was one group of grad students working on GPU's, and another group working on distributed graph algorithms on AWS. We were part of the same umbrella project, and regularly exchanged ideas about how to solve problems.\n\nThe constraints and failure cases are not wildly different at all imo."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8717415b-b8c6-4f2c-8e3d-5d1a450ff38a",
        "type": "message",
        "text": "Sure, and there are ways in modern graphics APIs to explicitly manage that there are multiple GPUs. The thing is it's very rare that they have symmetrical capabilities, so if you have a work load that actually needs that Nvidia hardware and you switch to intel integrated graphics, you'll have a worse experience. A language with an actor model that abstracts heterogeneous hardware and treats it as a homogeneous distributed system won't really solve that",
        "user": "UBSMEUXAA",
        "ts": "1611095229.038800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xgj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure, and there are ways in modern graphics APIs to explicitly manage that there are multiple GPUs. The thing is it's very rare that they have symmetrical capabilities, so if you have a work load that actually needs that Nvidia hardware and you switch to intel integrated graphics, you'll have a worse experience. A language with an actor model that abstracts heterogeneous hardware and treats it as a homogeneous distributed system won't really solve that"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9e93a320-2a09-4a6d-8194-2d0388a319ef",
        "type": "message",
        "text": "And making the cases where it doesn't matter easier doesn't really help anyone I guess? I mean potentially there is an interesting abstraction of a \"command buffer\" (a circular ring buffer that could look a little bit like messages in actor model systems) and an actor could be an explicit piece of defined hardware that has specific capabilities (both fixed function and code) but programming models and capabilities of different hardware are different enough that I'm not sure how useful it would be",
        "user": "UBSMEUXAA",
        "ts": "1611095638.039000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZEIg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And making the cases where it doesn't matter easier doesn't really help anyone I guess? I mean potentially there is an interesting abstraction of a \"command buffer\" (a circular ring buffer that could look a little bit like messages in actor model systems) and an actor could be an explicit piece of defined hardware that has specific capabilities (both fixed function and code) but programming models and capabilities of different hardware are different enough that I'm not sure how useful it would be"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c313c10f-cbf6-440c-8d92-5604ef3be2ec",
        "type": "message",
        "text": "Maybe there is a interesting use case where you can use local or remote compute for the same task and its entirely invisible (don't have a GPU and it automatically uses a cloud GPU)",
        "user": "UBSMEUXAA",
        "ts": "1611095963.039200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R+HU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe there is a interesting use case where you can use local or remote compute for the same task and its entirely invisible (don't have a GPU and it automatically uses a cloud GPU)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c35d6805-0613-4a4a-a325-935a33d679bb",
        "type": "message",
        "text": "Also device hang\\device lost due to a driver crash is not the same as an actual hardware failure.  The OS will recover from that, and as a system wide resource it doesn't practically make sense for applications to handle that.  In some cases  (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.  Laptops switch regularly but desktops will by default have embedded GPUs turned off, and don't have the same switching capabilities.  Consoles and smartphone generally have one GPU as part of an SOC, etc.",
        "user": "UBSMEUXAA",
        "ts": "1611096758.039400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8QFi8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also device hang\\device lost due to a driver crash is not the same as an actual hardware failure.  The OS will recover from that, and as a system wide resource it doesn't practically make sense for applications to handle that.  In some cases  (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.  Laptops switch regularly but desktops will by default have embedded GPUs turned off, and don't have the same switching capabilities.  Consoles and smartphone generally have one GPU as part of an SOC, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c7b460b6-f300-4b6a-8203-150f0dd47a1d",
        "type": "message",
        "text": "The reason I bring up command buffer as an abstraction is because new consoles have custom I\/O hardware that uses a GPU style command buffer model for I\/O requests, with the assumption that modern games will be making I\/O requests at a similar rate they make draw calls.  Game engines also generally use command buffers to send commands to a render thread (running on another core on the CPU) to drive rendering on the GPU.  It works great when you are mostly pushing data\/commands to another device, not so great for frequent two way communication though, because this pattern tends to be used in systems with high-throughput and high latency (relatively speaking, high latency for a GPU is still really low compared to an HTTP request)",
        "user": "UBSMEUXAA",
        "ts": "1611097179.039600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F2Sn9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason I bring up command buffer as an abstraction is because new consoles have custom I\/O hardware that uses a GPU style command buffer model for I\/O requests, with the assumption that modern games will be making I\/O requests at a similar rate they make draw calls.  Game engines also generally use command buffers to send commands to a render thread (running on another core on the CPU) to drive rendering on the GPU.  It works great when you are mostly pushing data\/commands to another device, not so great for frequent two way communication though, because this pattern tends to be used in systems with high-throughput and high latency (relatively speaking, high latency for a GPU is still really low compared to an HTTP request)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7d3ad29d-d034-47ba-a260-20ba2722f790",
        "type": "message",
        "text": "&gt; I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions\nUsing the same abstraction does not mean requiring the same constraints.\nAnd continuing with graphics as an example, things like feature flags for OpenGL are used all the time to provide different feature sets depending on hardware capability.\nSimilarly, Erlang and most actor models have ways to query the available resources for a particular process. Smalltalk has this as well.\n\n&gt; In some cases (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.\nIt is a matter of opinion about what is interesting...\nThe fact that I can still use my laptop if one of the GPU's fails seems pretty damn useful to me personally, even if the experience is degraded.\nIn the network case, variable bitrate video is also extremely interesting. If my network is suddenly over saturated or degraded, I used to not be able to play a video on Youtube at all, or my video call would be disconnected.\nWith variable bitrate streaming, the quality is simply lowered.... Same abstraction, that has built in semantics for heterogenous capabilities (dynamically changing capability btw)",
        "user": "U01661S9F34",
        "ts": "1611097341.039800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oVO",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Using the same abstraction does not mean requiring the same constraints.\nAnd continuing with graphics as an example, things like feature flags for OpenGL are used all the time to provide different feature sets depending on hardware capability.\nSimilarly, Erlang and most actor models have ways to query the available resources for a particular process. Smalltalk has this as well.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In some cases (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is a matter of opinion about what is interesting...\nThe fact that I can still use my laptop if one of the GPU's fails seems pretty damn useful to me personally, even if the experience is degraded.\nIn the network case, variable bitrate video is also extremely interesting. If my network is suddenly over saturated or degraded, I used to not be able to play a video on Youtube at all, or my video call would be disconnected.\nWith variable bitrate streaming, the quality is simply lowered.... Same abstraction, that has built in semantics for heterogenous capabilities (dynamically changing capability btw)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c220ef54-f3f5-4371-be33-7582c2bcf558",
        "type": "message",
        "text": "Not all applications can gracefully downgrade, and a ton of effort goes into supporting that.  For example, Cyberpunk 2077 got delisted because it actually wasn't playable on last generation console hardware.  If your discrete GPU dies and you're playing the game on PC it will be unplayable (either functionally or actually due to lack of capabilities).  You could apply the same logic to machine learning training and other GPU tasks that require high compute.  Also its great that your laptop keeps running, but I'm not sure how a distributed systems approach in a user land application programming language fixes that?  Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?",
        "user": "UBSMEUXAA",
        "ts": "1611098365.040000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yy8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not all applications can gracefully downgrade, and a ton of effort goes into supporting that.  For example, Cyberpunk 2077 got delisted because it actually wasn't playable on last generation console hardware.  If your discrete GPU dies and you're playing the game on PC it will be unplayable (either functionally or actually due to lack of capabilities).  You could apply the same logic to machine learning training and other GPU tasks that require high compute.  Also its great that your laptop keeps running, but I'm not sure how a distributed systems approach in a user land application programming language fixes that?  Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "ab4cdd85-4083-46b3-8c9c-f641fd8a6d20",
        "type": "message",
        "text": "Not all distributed databases are usable if the network failure is bad enough, That doesn't mean the abstraction is wrong.\nThere are always failure cases that cannot be recovered from. It does not mean using an abstraction of heterogenous and distributed computing is a bad model (your original point iiuc).\n\n&gt; Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?\nThis is exactly what things like micro-kernels and Docker do. IPC is a form of distributed abstraction.",
        "user": "U01661S9F34",
        "ts": "1611099503.040200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611099546.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rY88",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not all distributed databases are usable if the network failure is bad enough, That doesn't mean the abstraction is wrong.\nThere are always failure cases that cannot be recovered from. It does not mean using an abstraction of heterogenous and distributed computing is a bad model (your original point iiuc).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is exactly what things like micro-kernels and Docker do. IPC is a form of distributed abstraction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "44b84b21-59d1-4efa-ada4-640286fa2b5b",
        "type": "message",
        "text": "&gt; I'm not sure how a distributed systems approach in a user land application programming language fixes that?\nThe point of exposing these to the user application level is that the application can have a say in how the failure is handled. Cyberpunk 2077 maybe can't run if the GPU fails, but Microsoft Word still can. You want to allow both options.",
        "user": "U01661S9F34",
        "ts": "1611099909.040500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6pt4",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure how a distributed systems approach in a user land application programming language fixes that?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The point of exposing these to the user application level is that the application can have a say in how the failure is handled. Cyberpunk 2077 maybe can't run if the GPU fails, but Microsoft Word still can. You want to allow both options."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7157016a-e883-41ac-83ae-2252a1171f75",
        "type": "message",
        "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?  What features of distributed programming are generally not necessary for local hardware? GPU programmers do have to handle device removed (<https:\/\/docs.microsoft.com\/en-us\/windows\/uwp\/gaming\/handling-device-lost-scenarios>), which could mean try to reinitialize and reload, and that could mean using a different device, but it also could mean crash or quit.  I'm focused on GPUs because I'm a graphics programmer, but I imagine you could apply this to any specific hardware (storage, audio, etc.) Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?",
        "user": "UBSMEUXAA",
        "ts": "1611100075.040700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Handle device removed scenarios in Direct3D 11 - UWP applications",
                "title_link": "https:\/\/docs.microsoft.com\/en-us\/windows\/uwp\/gaming\/handling-device-lost-scenarios",
                "text": "This topic explains how to recreate the Direct3D and DXGI device interface chain when the graphics adapter is removed or reinitialized.",
                "fallback": "Handle device removed scenarios in Direct3D 11 - UWP applications",
                "thumb_url": "https:\/\/docs.microsoft.com\/en-us\/media\/logos\/logo-ms-social.png",
                "from_url": "https:\/\/docs.microsoft.com\/en-us\/windows\/uwp\/gaming\/handling-device-lost-scenarios",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/docs.microsoft.com\/favicon.ico",
                "service_name": "docs.microsoft.com",
                "id": 1,
                "original_url": "https:\/\/docs.microsoft.com\/en-us\/windows\/uwp\/gaming\/handling-device-lost-scenarios"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oNGC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?  What features of distributed programming are generally not necessary for local hardware? GPU programmers do have to handle device removed ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/docs.microsoft.com\/en-us\/windows\/uwp\/gaming\/handling-device-lost-scenarios"
                            },
                            {
                                "type": "text",
                                "text": "), which could mean try to reinitialize and reload, and that could mean using a different device, but it also could mean crash or quit.  I'm focused on GPUs because I'm a graphics programmer, but I imagine you could apply this to any specific hardware (storage, audio, etc.) Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7dc7324a-aaa7-4f12-83ea-213383291892",
        "type": "message",
        "text": "Similarly for security models. In docker or CGroups situation, you may or may not have access to a system resource depending on the security policy. Your application can decide how to handle that. Your database may try to set up a database on a certain file system, but if it doesn't have access, maybe it falls back to a memory backed store.",
        "user": "U01661S9F34",
        "ts": "1611100088.041000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6=wgV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Similarly for security models. In docker or CGroups situation, you may or may not have access to a system resource depending on the security policy. Your application can decide how to handle that. Your database may try to set up a database on a certain file system, but if it doesn't have access, maybe it falls back to a memory backed store."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c7169fa7-721d-49d0-85d2-5cb9e936fe32",
        "type": "message",
        "text": "&gt; I'm focused on GPUs because I'm a graphics programmer\nI'm a database programmer, so this is fun to compare perspectives :slightly_smiling_face:",
        "user": "U01661S9F34",
        "ts": "1611100154.041200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l=C9",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm focused on GPUs because I'm a graphics programmer"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm a database programmer, so this is fun to compare perspectives "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "0caa8245-cd6e-4307-b0fa-b36dae537064",
        "type": "message",
        "text": "&gt; I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?\n&gt; Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?\nMicrokernels are the best practical example I can think of that try to do exactly this: <http:\/\/www.microkernel.info>\n\nIt's more about security and reliability. It does have a performance cost. (Which I'm sure sounds like pure pain to a GPU programmer lol)",
        "user": "U01661S9F34",
        "ts": "1611100637.041500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "daZ",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?\nMaybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Microkernels are the best practical example I can think of that try to do exactly this: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/www.microkernel.info"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt's more about security and reliability. It does have a performance cost. (Which I'm sure sounds like pure pain to a GPU programmer lol)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "09485a9a-648f-4b64-88eb-a5e706eacf00",
        "type": "message",
        "text": "Your example about cloud GPU is already here as well, That's basically what Google Stadia is.",
        "user": "U01661S9F34",
        "ts": "1611100790.041700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ACQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your example about cloud GPU is already here as well, That's basically what Google Stadia is."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "6fd185d5-f122-481f-8111-b2b189512e1f",
        "type": "message",
        "text": "When I started the thread I was thinking about all the ways in which non-programmable processors (built out of programmable components!) hide inside our computers. It's a place for bugs and especially security issues to hide. It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them. I said \"distributed computing\" just because it was the closest term I could think of, but it did pull in unintended connotations that it's been interesting to see explored :slightly_smiling_face:",
        "user": "UCUSW7WVD",
        "ts": "1611100992.041900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YxL+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I started the thread I was thinking about all the ways in which non-programmable processors (built out of programmable components!) hide inside our computers. It's a place for bugs and especially security issues to hide. It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them. I said \"distributed computing\" just because it was the closest term I could think of, but it did pull in unintended connotations that it's been interesting to see explored "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c05cd72c-64e2-48dc-96ca-bb04345a5437",
        "type": "message",
        "text": "&gt; It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them.\nThis sounds like the idea of a microkernel taken to the level of firmware \/ BIOS \/ UEFI. Sounds like an awesome research project to explore :star-struck:",
        "user": "U01661S9F34",
        "ts": "1611101248.042100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GbtsE",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This sounds like the idea of a microkernel taken to the level of firmware \/ BIOS \/ UEFI. Sounds like an awesome research project to explore "
                            },
                            {
                                "type": "emoji",
                                "name": "star-struck"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "64fec974-b687-4041-af2e-b5bbf2abe382",
        "type": "message",
        "text": "I'm also reminded of a podcast I listened to a while ago: <https:\/\/oxide.computer\/podcast\/on-the-metal-3-ron-minnich\/>\nGoogle does some of this kind of thing on their servers, and also on chrome-books with U-root. (Trusting trust type stuff at the firmware level.)\nIt's frustratingly difficult because the hardware vendors do not want this. It has taken companies like Google, Facebook, and Amazon to strong arm them into opening up their firmware more....",
        "user": "U01661S9F34",
        "ts": "1611101846.042300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611101886.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LKj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm also reminded of a podcast I listened to a while ago: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/oxide.computer\/podcast\/on-the-metal-3-ron-minnich\/"
                            },
                            {
                                "type": "text",
                                "text": "\nGoogle does some of this kind of thing on their servers, and also on chrome-books with U-root. (Trusting trust type stuff at the firmware level.)\nIt's frustratingly difficult because the hardware vendors do not want this. It has taken companies like Google, Facebook, and Amazon to strong arm them into opening up their firmware more...."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "33ee2ad4-b990-4d48-945a-d89a0db68292",
        "type": "message",
        "text": "Also, Alan Kay's quote as mentioned by <@U0112C10V4Y>\n&gt; \"Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine.\"\nI remember talking to <@UCUSW7WVD> about this exact quote a while ago.\nThe closest modern equivalent we have is probably FPGAs.",
        "user": "U01661S9F34",
        "ts": "1611102388.042700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611102411.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qdN5V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, Alan Kay's quote as mentioned by "
                            },
                            {
                                "type": "user",
                                "user_id": "U0112C10V4Y"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine.\""
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I remember talking to "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " about this exact quote a while ago.\nThe closest modern equivalent we have is probably FPGAs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a6af23b1-8478-4ebc-8b40-ab801f0ff0bb",
        "type": "message",
        "text": "Yeah I was probably being way too specific about what the definition of distributed system is now that we're explicitly talking about distributed systems *within* hardware. Back to the original post, what I know of FPGA architecture, it's laid out in a similar way as MFM",
        "user": "UBSMEUXAA",
        "ts": "1611107643.043300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YsU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I was probably being way too specific about what the definition of distributed system is now that we're explicitly talking about distributed systems "
                            },
                            {
                                "type": "text",
                                "text": "within ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "hardware. Back to the original post, what I know of FPGA architecture, it's laid out in a similar way as MFM"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "U01661S9F34"
                ],
                "count": 2
            }
        ]
    }
]