[
    {
        "client_msg_id": "9b49f2bd-9e40-4e13-8bdb-fc52e3da8a00",
        "type": "message",
        "text": "This project has a vibe similar to the original design and implementation of C++. A preprocessor on top of C. In this case, a preprocessor on top of C#. It's always interesting to me  to see the struggles that come about when building macros in an Algol based language. Nim macros deal with many of the same issues. There always ends up being a lot of boilerplate and ceremony around dealing with the tree structure. (That you inevitably hide by writing more macros once you are bootstrapped far enough lol).",
        "user": "U01661S9F34",
        "ts": "1610662040.001200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gY496",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This project has a vibe similar to the original design and implementation of C++. A preprocessor on top of C. In this case, a preprocessor on top of C#. It's always interesting to me  to see the struggles that come about when building macros in an Algol based language. Nim macros deal with many of the same issues. There always ends up being a lot of boilerplate and ceremony around dealing with the tree structure. (That you inevitably hide by writing more macros once you are bootstrapped far enough lol)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "4ad479cc-d289-471e-8211-26fad26fb247",
        "type": "message",
        "text": "What issues do you mean? What boilerplate and ceremony? I don't think LeMP is similar to C++, as it solves problems that C++ never tried to solve (whereas most problems solved by C++98 were solved by C# 2.0... and those problems solved by C++ but not C# are largely not solved by LeMP either. Even C++'s new support for compile-time code execution has little resemblance to what LeMP does, as LeMP simply has a macro to invoke the C# interactive engine at compile-time.)",
        "user": "UD6EXQVM0",
        "ts": "1610686189.001700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1610687506.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I=PS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What issues do you mean? What boilerplate and ceremony? I don't think LeMP is similar to C++, as it solves problems that C++ never tried to solve (whereas most problems solved by C++98 were solved by C# 2.0... and those problems solved by C++ but not C# are largely not solved by LeMP either. Even C++'s new support for compile-time code execution has little resemblance to what LeMP does, as LeMP simply has a macro to invoke the C# interactive engine at compile-time.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "46655d02-5623-415f-8d58-17910b0ee7e7",
        "type": "message",
        "text": "I ended up using something called ffmpeg-normalize with a command line of\nffmpeg-normalize --sample-rate 44100 -t -14 [filename] -o [out_filename]\nSee <https:\/\/superuser.com\/a\/323127\/91637>",
        "user": "UD6EXQVM0",
        "ts": "1610686900.002100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "Super User",
                "title": "How can I normalize audio using ffmpeg?",
                "title_link": "https:\/\/superuser.com\/a\/323127\/91637",
                "text": "I want the loudest peak sound in a movie clip to be as loud as the codec allows, then have every other sound amplified accordingly. What's a practical example in order to accomplish this using ffm...",
                "fallback": "Super User: How can I normalize audio using ffmpeg?",
                "thumb_url": "https:\/\/cdn.sstatic.net\/Sites\/superuser\/Img\/apple-touch-icon@2.png?v=e869e4459439",
                "from_url": "https:\/\/superuser.com\/a\/323127\/91637",
                "thumb_width": 316,
                "thumb_height": 316,
                "service_icon": "https:\/\/cdn.sstatic.net\/Sites\/superuser\/Img\/apple-touch-icon.png?v=0ad5b7a83e49",
                "id": 1,
                "original_url": "https:\/\/superuser.com\/a\/323127\/91637"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "akT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I ended up using something called ffmpeg-normalize with a command line of\nffmpeg-normalize --sample-rate 44100 -t -14 [filename] -o [out_filename]\nSee "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/superuser.com\/a\/323127\/91637"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593666684.026200",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3a51759c-e3a0-4641-96dc-b701fa8a632a",
        "type": "message",
        "text": "Let me clarify. I am speaking from a historical perspective. I don't mean that it solves similar problems, I mean that it is similar to the original implementation of C++. In 1979 Bjarne Stroustrup created C++ as a preprocessor on top of C. It didn't start out as a separate language from whole cloth. LeMP seems similar in that regards.\n\nIn regards to boilerplate, your first example: `change_temporarily` is in fact built up of several lower level macros is it not? And this required you to implement several other fairly complicated bits of infrastructure, including `collection_with_change_events` (if that's not boilerplate \/ ceremony code, idk what is) and your `macro macro` to interface with the C# interactive engine. You don't deal with the C# interactive engine directly in your `change_temporarily` macro (though you could in theory), instead you have built up to it using a series of lower level macros that you progressively develop.\n\nI don't mean to imply this is a bad thing! I believe what you are doing is *fundamental* to the nature of macro systems. You inevitably build up infrastructure organically on top of itself like this. What is interesting to me is the shape macros take in an imperative <http:\/\/wiki.c2.com\/?AlgolFamily|Algol descendent language> compared to a lisp ends up being very different (more verbose).\nAs the resident shill for the fringe language <https:\/\/nim-lang.org|Nim> in this community, which has a very similar macro system (at least on the surface), I can tell you that Nim has run into many of the same issues you are running into. This appears to be an interesting case of <https:\/\/en.wikipedia.org\/wiki\/Convergent_evolution|convergent evolution>.",
        "user": "U01661S9F34",
        "ts": "1610688122.002900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1610688357.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KA3qp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let me clarify. I am speaking from a historical perspective. I don't mean that it solves similar problems, I mean that it is similar to the original implementation of C++. In 1979 "
                            },
                            {
                                "type": "text",
                                "text": "Bjarne Stroustrup created C++ as a preprocessor on top of C. It didn't start out as a separate language from whole cloth. LeMP seems similar in that regards.",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nIn regards to boilerplate, your first example: "
                            },
                            {
                                "type": "text",
                                "text": "change_temporarily",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is in fact built up of several lower level macros is it not? And this required you to implement several other fairly complicated bits of infrastructure, including "
                            },
                            {
                                "type": "text",
                                "text": "collection_with_change_events",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (if that's not boilerplate \/ ceremony code, idk what is) and your "
                            },
                            {
                                "type": "text",
                                "text": "macro macro",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to interface with the C# interactive engine. You don't deal with the C# interactive engine directly in your "
                            },
                            {
                                "type": "text",
                                "text": "change_temporarily",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " macro (though you could in theory), instead you have built up to it using a series of lower level macros that you progressively develop.\n\nI don't mean to imply this is a bad thing! I believe what you are doing is "
                            },
                            {
                                "type": "text",
                                "text": "fundamental",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to the nature of macro systems. You inevitably build up infrastructure organically on top of itself like this. What is interesting to me is the shape macros take in an imperative "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/wiki.c2.com\/?AlgolFamily",
                                "text": "Algol descendent language"
                            },
                            {
                                "type": "text",
                                "text": " compared to a lisp ends up being very different (more verbose).\nAs the resident shill for the fringe language "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/nim-lang.org",
                                "text": "Nim"
                            },
                            {
                                "type": "text",
                                "text": " in this community, which has a very similar macro system (at least on the surface), I can tell you that Nim has run into many of the same issues you are running into. This appears to be an interesting case of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Convergent_evolution",
                                "text": "convergent evolution"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "aa89fe0e-5991-4c26-ba99-2a6093730619",
        "type": "message",
        "text": "`change_temporarily` is built on the `on_finally` macro, that's true, but I don't see how this is any different from Lisp where macros are even more ubiquitous. Can you give an example of something that would end up more verbose in LeMP (or Nim, though I haven't used Nim nor Lisp) than in Lisp?\n\n`CollectionWithChangeEvents` isn't used by anything at all (I wrote it and then decided I didn't need it after all). `macro` is, of course, a macro, but in a Lisp I understand that one typically also uses a macro to define other macros.\n\nI don't think this is fundamentally a matter of Algol (conventional) languages vs Lisps. The \"Loyc tree\" way of seeing things is intended to abolish most of the differences between \"Lisps\" and \"Algols\", so that the only differences left are the parser, printer and some historical baggage that neither type of language is able to shed.\n\nAnd by the way, something that might not be obvious is that I'm trying to shift C# from being a \"statement-based\" language to a \"expression-based\" language like Lisp is. So Enhanced C# is fundamentally expression-based, e.g. the statement `if (c) Foo();` is perfectly equivalent to the expression `#if(c, Foo())`.\n\nAdmittedly there can be some \"ceremony\" necessary to bridge this gap, e.g. the `case` statement expects an expression argument, so if the user wants to write a statement in its natural form `if (c) Foo();`, the user must enclose the statement in braces, and the `case` statement must in turn remove the braces before processing the syntax tree. I would say this falls into the category of historical baggage - there is no reason an Algol-style language can't embrace an expression-based nature from the start, like <http:\/\/loyc.net\/les\/|LES> does. In addition, since LeMP is a preprocessor it does face substantial difficulties as a result of the fact that it can't add features to C# itself.",
        "user": "UD6EXQVM0",
        "ts": "1610689533.003500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1610693426.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KpZ0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "`change_temporarily` is built on the `on_finally` macro, that's true, but I don't see how this is any different from Lisp where macros are even more ubiquitous. Can you give an example of something that would end up more verbose in LeMP (or Nim, though I haven't used Nim nor Lisp) than in Lisp?\n\n`CollectionWithChangeEvents` isn't used by anything at all (I wrote it and then decided I didn't need it after all). `macro` is, of course, a macro, but in a Lisp I understand that one typically also uses a macro to define other macros.\n\nI don't think this is fundamentally a matter of Algol (conventional) languages vs Lisps. The \"Loyc tree\" way of seeing things is intended to abolish most of the differences between \"Lisps\" and \"Algols\", so that the only differences left are the parser, printer and some historical baggage that neither type of language is able to shed.\n\nAnd by the way, something that might not be obvious is that I'm trying to shift C# from being a \"statement-based\" language to a \"expression-based\" language like Lisp is. So Enhanced C# is fundamentally expression-based, e.g. the statement `if (c) Foo();` is perfectly equivalent to the expression `#if(c, Foo())`.\n\nAdmittedly there can be some \"ceremony\" necessary to bridge this gap, e.g. the `case` statement expects an expression argument, so if the user wants to write a statement in its natural form `if (c) Foo();`, the user must enclose the statement in braces, and the `case` statement must in turn remove the braces before processing the syntax tree. I would say this falls into the category of historical baggage - there is no reason an Algol-style language can't embrace an expression-based nature from the start, like "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/loyc.net\/les\/",
                                "text": "LES"
                            },
                            {
                                "type": "text",
                                "text": " does. In addition, since LeMP is a preprocessor it does face substantial difficulties as a result of the fact that it can't add features to C# itself."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "f268b965-0794-47d7-9342-a97e5bb57529",
        "type": "message",
        "text": "So, yeah, I have to write quite a bit of infrastructure to get macros to work well on an uncooperative language like C#, but I don't consider this to be a result of C# being in the Algol family _per se_, rather it is the result of various decisions they made, such as having a bright red line between expressions, statements, and declarations (a decision which they doubled down on when they introduced the new pattern syntax, creating another category of syntax that is distinct from, and highly ambiguous with, the others... sigh)",
        "user": "UD6EXQVM0",
        "ts": "1610690424.003800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1610691922.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YJFH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So, yeah, I have to write quite a bit of infrastructure to get macros to work well on an uncooperative language like C#, but I don't consider this to be a result of C# being in the Algol family "
                            },
                            {
                                "type": "text",
                                "text": "per se",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", rather it is the result of various decisions they made, such as having a bright red line between expressions, statements, and declarations (a decision which they doubled down on when they introduced the new pattern syntax, creating another category of syntax that is distinct from, and highly ambiguous with, the others... sigh)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "e223694d-a052-46eb-b4c6-8d5f6bee7ca0",
        "type": "message",
        "text": "Hmm, but now that I think about it, I can't name a single Algol-style language, other than my own LES, that rejected the statement\/expression dichotomy. LES is also meant to provide homoiconicity. I'd be kind of shocked if it turned out that I was the first one to do this stuff in an Algol style language... but I'm inclined to apologize, because from your perspective you're probably seeing Algol languages as they are (or tend to be), which is perfectly reasonable, and I'm seeing them in an unconventional way, and so the onus is on me to explain that....",
        "user": "UD6EXQVM0",
        "ts": "1610691792.004200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1610693327.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=Ia",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm, but now that I think about it, I can't name a single Algol-style language, other than my own LES, that rejected the statement\/expression dichotomy. LES is also meant to provide homoiconicity. I'd be kind of shocked if it turned out that I was the first one to do this stuff in an Algol style language... but I'm inclined to apologize, because from your perspective you're probably seeing Algol languages as they are (or tend to be), which is perfectly reasonable, and I'm seeing them in an unconventional way, and so the onus is on me to explain that...."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "688382b0-802b-4c86-9d35-07cfb3f1455c",
        "type": "message",
        "text": "Where can I learn more about your project?",
        "user": "UD6EXQVM0",
        "ts": "1610693989.005300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MMjrN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where can I learn more about your project?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600002072.034000",
        "parent_user_id": "U0123H7JRDM"
    },
    {
        "client_msg_id": "de68aa8f-75da-4d8d-a9e6-578d5e330424",
        "type": "message",
        "text": "I think you hit the nail on the head: Algol languages have pretty much all kept the statement\/expression dichotomy. Adding macros to an Algol language seems to drive the language to push more things into expressions.\n\nNim is interesting because it cares less about homoiconicity as a principle. It's a practical language first and foremost. But it's interesting to see certain homoiconic properties emerge (and also where they fail)\n\nNim trying to get more \"expression-ey\" and failing\n<https:\/\/github.com\/nim-lang\/Nim\/pull\/11992>\n\nNim having similar issues with `case` :stuck_out_tongue:\n<https:\/\/github.com\/nim-lang\/Nim\/issues\/12874>",
        "user": "U01661S9F34",
        "ts": "1610696797.005500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U01661S9F34",
            "ts": "1610696807.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/Gi4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you hit the nail on the head: Algol languages have pretty much all kept the statement\/expression dichotomy. Adding macros to an Algol language seems to drive the language to push more things into expressions.\n\nNim is interesting because it cares less about homoiconicity as a principle. It's a practical language first and foremost. But it's interesting to see certain homoiconic properties emerge (and also where they fail)\n\nNim trying to get more \"expression-ey\" and failing\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/nim-lang\/Nim\/pull\/11992"
                            },
                            {
                                "type": "text",
                                "text": "\n\nNim having similar issues with "
                            },
                            {
                                "type": "text",
                                "text": "case",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/nim-lang\/Nim\/issues\/12874"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610142886.167600",
        "parent_user_id": "UD6EXQVM0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "44d454d0-75ec-4911-b402-e344a1c2e0c9",
        "type": "message",
        "text": "Which language syntax is that, and how does your \"intellisense\" system work?",
        "user": "UD6EXQVM0",
        "ts": "1610697260.006000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1610697271.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VDW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Which language syntax is that, and how does your \"intellisense\" system work?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606934381.142700",
        "parent_user_id": "UE0H4170F"
    }
]