[
    {
        "client_msg_id": "f6331c1b-82f3-49d6-8256-5fb283daa582",
        "type": "message",
        "text": "Thanks <@UCGAK10LS>. The background of my question was the user's point of view: how much does a user have to know about computation and\/or constraint programming to understand what is and is not possible in a formula.",
        "user": "UJBAJNFLK",
        "ts": "1615391886.162300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vj7Et",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": ". The background of my question was the user's point of view: how much does a user have to know about computation and\/or constraint programming to understand what is and is not possible in a formula."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7e4d40ef-27e1-43e6-82f9-fa2446c10a3f",
        "type": "message",
        "text": "<@UA14TGLTC> You wrote: “_Unordered and ordered collections are entirely different beasts. Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things._”\n\nHow do you model ordered collections “properly”? I’m only used to programming languages\/environments where I end up using lists\/vectors\/arrays, which of course impose arbitrary order. Sure, sometimes there are set data types that at least express that order doesn’t matter, but it sounded like your advice was hinting at more than just picking the correct type — I might also be missing the relevant experience here with constraint languages…",
        "user": "U5STGTB3J",
        "ts": "1615392408.162500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f3UC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " You wrote: “"
                            },
                            {
                                "type": "text",
                                "text": "Unordered and ordered collections are entirely different beasts. Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things.",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "”\n\nHow do you model ordered collections “properly”? I’m only used to programming languages\/environments where I end up using lists\/vectors\/arrays, which of course impose arbitrary order. Sure, sometimes there are set data types that at least express that order doesn’t matter, but it sounded like your advice was hinting at more than just picking the correct type — I might also be missing the relevant experience here with constraint languages…"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "69c142e8-78d4-4bd9-86d8-3cb81528f079",
        "type": "message",
        "text": "<@U5STGTB3J> I'm wondering if he's thinking in `data Nat = Zero | Suc Nat` terms...?",
        "user": "U013ZLJARC7",
        "ts": "1615394254.162800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf4ae9e5b293",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f4ae9e5b29386489b18b3bc6b1f41a22.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iJyXA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " I'm wondering if he's thinking in "
                            },
                            {
                                "type": "text",
                                "text": "data Nat = Zero | Suc Nat",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " terms...?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "4B80FB9A-733E-4116-B1DC-003456D3A5BF",
        "type": "message",
        "text": "the way i read the document\/app distinction is basically an app lets you do something whereas a document is something you get at the end of using some tool (that you can keep, or edit later)",
        "user": "UHWC9PXBL",
        "ts": "1615408197.166300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "omq2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the way i read the document\/app distinction is basically an app lets you do something whereas a document is something you get at the end of using some tool (that you can keep, or edit later)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1614710701.086300",
        "parent_user_id": "UKDM3GLAJ"
    },
    {
        "client_msg_id": "16d9a380-f8e6-4ec2-ab09-4578a29c1018",
        "type": "message",
        "text": "<@UJBAJNFLK> I don't know the answer to that yet, as I don't yet have a working programming language :innocent:",
        "user": "UCGAK10LS",
        "ts": "1615424650.166700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "snRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I don't know the answer to that yet, as I don't yet have a working programming language "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "fb9577ea-7b97-4b19-943d-f5c56b00bf40",
        "type": "message",
        "text": "<@U5STGTB3J> Doing ordered collections \"properly\" means including only as much ordering data as is needed to capture the desired order. So, if you have a collection of elements, and those elements are in a total order, then you can annotate each element with a natural number indicating its position in the sequence. If your elements are in a _partial order_, then you could encode their relative position using something like a multiset (which are partially ordered by the \"inclusion\" (⊆) relation) containing \"elements that precede this element\", or whatever value best _explains_ how the ordering was constructed and how it will be maintained as the elements change. (For example, maybe a nodes-and-edges model is better.)",
        "user": "UCGAK10LS",
        "ts": "1615425394.166900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pdj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " Doing ordered collections \"properly\" means including only as much ordering data as is needed to capture the desired order. So, if you have a collection of elements, and those elements are in a total order, then you can annotate each element with a natural number indicating its position in the sequence. If your elements are in a "
                            },
                            {
                                "type": "text",
                                "text": "partial order",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then you could encode their relative position using something like a multiset (which are partially ordered by the \"inclusion\" (⊆) relation) containing \"elements that precede this element\", or whatever value best "
                            },
                            {
                                "type": "text",
                                "text": "explains",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " how the ordering was constructed and how it will be maintained as the elements change. (For example, maybe a nodes-and-edges model is better.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "97aef314-db05-4745-8c20-d8d6b142468d",
        "type": "message",
        "text": "<@U5STGTB3J> with order there are two challenges:\n1. Purity: Accidentally ordering unordered collections.  It means that you can't print a set without suppling an order.  It means you cannot loop over a set either.  You can map over a set, but all the results have to be independent.  Yes, debugging becomes kind of tricky.  When looking under the hood, it's fine to see the order, but for application level debugging, you need different ways of inspecting the unordered collections.  Back a long while ago Ruby, my weapon of choice, had unordered Hashes.  Given her intrinsically imperative nature, that went badly.  So the most Rubyesk of solutions was adopted: all Hashes are ordered by when you insert keys.  This has problems, but it is useful and unsurprising.\n2. Modeling: Having good ways of managing orders.  Consish lists are simple and effective.  Annotating data with indices leads to madness.  A decent expandable Array (push, pop, queue, drop, splice) works 95% of the time.  For that last 5%, you'll want some sort of omnibus tree or rope structure together with cursors, ranges, and the like.",
        "user": "UA14TGLTC",
        "ts": "1615429729.167100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vl\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " with order there are two challenges:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Purity: Accidentally ordering unordered collections.  It means that you can't print a set without suppling an order.  It means you cannot loop over a set either.  You can map over a set, but all the results have to be independent.  Yes, debugging becomes kind of tricky.  When looking under the hood, it's fine to see the order, but for application level debugging, you need different ways of inspecting the unordered collections.  Back a long while ago Ruby, my weapon of choice, had unordered Hashes.  Given her intrinsically imperative nature, that went badly.  So the most Rubyesk of solutions was adopted: all Hashes are ordered by when you insert keys.  This has problems, but it is useful and unsurprising."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Modeling: Having good ways of managing orders.  Consish lists are simple and effective.  Annotating data with indices leads to madness.  A decent expandable Array (push, pop, queue, drop, splice) works 95% of the time.  For that last 5%, you'll want some sort of omnibus tree or rope structure together with cursors, ranges, and the like."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5984C0ED-07F6-4A5D-A6F9-EC80CCEDF773",
        "type": "message",
        "text": "In the “future of coding”, your point #2 should definitely be relegated to the language runtime and not appear anywhere in the language itself IMO. I consider it an implementation detail.",
        "user": "UCGAK10LS",
        "ts": "1615430005.169900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6uO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the “future of coding”, your point #2 should definitely be relegated to the language runtime and not appear anywhere in the language itself IMO. I consider it an implementation detail."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "297B70A3-0CBE-4DCC-8DD9-330E937E52D6",
        "type": "message",
        "text": "I’d say the key is to give users of the language good ways to specific the abstract ordering information they need and ways to operate over such ordered collections",
        "user": "UCGAK10LS",
        "ts": "1615430110.172400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "21aie",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’d say the key is to give users of the language good ways to specific the abstract ordering information they need and ways to operate over such ordered collections"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2b37460a-ec54-47cf-ad9c-4fac2734b400",
        "type": "message",
        "text": "In the language itself, you need to decide on what level or degree sequence munging you want to feel natural.  On one extreme, you might go with ordering by time column.  In that case, try to avoid use cases where mutable indicies (1, 2, 3) seem like a solution.  On the other extreme, you might want to support, I don't know, arbitrary selections of DOMish tree-nodes.  Yes, in an especially high-level language you'll likely want the application developer to be able to ignore the underlying representation.  (Often this means doing tricks to as to avoid allocating small arrays.)  Perhaps providing a DLS escape value for fixed sized arrays, or, I don't know whatever your GPU's shader language supports.  It becomes a matter of answering, \"What is this system naturally good for?\"  And the even better question, \"What is this system naturally bad at?\"",
        "user": "UA14TGLTC",
        "ts": "1615430736.172600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UC0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the language itself, you need to decide on what level or degree sequence munging you want to feel natural.  On one extreme, you might go with ordering by time column.  In that case, try to avoid use cases where mutable indicies (1, 2, 3) seem like a solution.  On the other extreme, you might want to support, I don't know, arbitrary selections of DOMish tree-nodes.  Yes, in an especially high-level language you'll likely want the application developer to be able to ignore the underlying representation.  (Often this means doing tricks to as to avoid allocating small arrays.)  Perhaps providing a DLS escape value for fixed sized arrays, or, I don't know whatever your GPU's shader language supports.  It becomes a matter of answering, \"What is this system naturally good for?\"  And the even better question, \"What is this system naturally bad at?\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b70b45fb-c38a-41dd-9a85-fc6cd99ce9e3",
        "type": "message",
        "text": "Disclaimer: what follows is my thoughts on language design for \"the future of coding\" (the next decade), not for a near-term business need or specific market niche.\n\nI have trouble accepting the \"you have to make a performance trade-off\" hypothesis that I feel is alluded to (\"what is it bad at?\"). I feel it is invoking the myth that the higher-level your language is, the worse its execution efficiency must be. (Once upon a time, garbage collection overhead was ridiculed.) In reality every program is just a _specification_ and efficiency comes down to how well that specification can be translated into a hardware-consumable language. A smart mapping requires a smart implementation, and also a smart choice of hardware platform. I'm dead certain that CPUs and cache hierarchies are not the future, so assessing a language based on its ability to support \"cache locality\" and such is a dangerous mental trap. As I've previously said, implementation issues will be a fun puzzle that comes _after_ the language has been designed, and not a moment sooner. (As long as the language has a clear specification, a \"suboptimal\" implementation will be easy to develop.) The kinds of applications (and therefore markets) for which the language is \"fast enough\" will be revealed in the course of building the \"best\" implementation possible on each potential hardware platform, such as a CPU, GPU, or AI chip.",
        "user": "UCGAK10LS",
        "ts": "1615432621.172800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615432876.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N5l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Disclaimer: what follows is my thoughts on language design for \"the future of coding\" (the next decade), not for a near-term business need or specific market niche.\n\nI have trouble accepting the \"you have to make a performance trade-off\" hypothesis that I feel is alluded to (\"what is it bad at?\"). I feel it is invoking the myth that the higher-level your language is, the worse its execution efficiency must be. (Once upon a time, garbage collection overhead was ridiculed.) In reality every program is just a "
                            },
                            {
                                "type": "text",
                                "text": "specification",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and efficiency comes down to how well that specification can be translated into a hardware-consumable language. A smart mapping requires a smart implementation, and also a smart choice of hardware platform. I'm dead certain that CPUs and cache hierarchies are not the future, so assessing a language based on its ability to support \"cache locality\" and such is a dangerous mental trap. As I've previously said, implementation issues will be a fun puzzle that comes "
                            },
                            {
                                "type": "text",
                                "text": "after",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the language has been designed, and not a moment sooner. (As long as the language has a clear specification, a \"suboptimal\" implementation will be easy to develop.) The kinds of applications (and therefore markets) for which the language is \"fast enough\" will be revealed in the course of building the \"best\" implementation possible on each potential hardware platform, such as a CPU, GPU, or AI chip."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6d941db8-75b4-4642-b8c7-d3545ad0b1af",
        "type": "message",
        "text": "You may not have been hinting that way, and if so just ignore the above :stuck_out_tongue:\n\nAnyway, if we can throw the \"efficiency is a problem\" hypothesis in the dustbin, the only real concern is _what does a user of the language experience_? How do we present the \"raw essence\" of order and nothing else? I think that's what the interesting problem here. You're right that oftentimes indices may not encode the _essence_ of the order the user is trying to express, and perhaps a graph model (which cons-lists and trees try to approximate) is a more faithful encoding, and better supports the operations that will be performed upon the collection. Happily, logic languages (and the kind of language I'm designing) are particularly good at representing and operating over graphs.",
        "user": "UCGAK10LS",
        "ts": "1615432778.173000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615433005.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fkj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You may not have been hinting that way, and if so just ignore the above "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            },
                            {
                                "type": "text",
                                "text": "\n\nAnyway, if we can throw the \"efficiency is a problem\" hypothesis in the dustbin, the only real concern is "
                            },
                            {
                                "type": "text",
                                "text": "what does a user of the language experience",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? How do we present the \"raw essence\" of order and nothing else? I think that's what the interesting problem here. You're right that oftentimes indices may not encode the"
                            },
                            {
                                "type": "text",
                                "text": " essence ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "of the order the user is trying to express, and perhaps a graph model (which cons-lists and trees try to approximate) is a more faithful encoding, and better supports the operations that will be performed upon the collection. Happily, logic languages (and the kind of language I'm designing) are particularly good at representing and operating over graphs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    }
]