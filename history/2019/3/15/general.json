[
    {
        "client_msg_id": "3e612d61-a621-4711-b760-04b501769096",
        "type": "message",
        "text": "I am against the expression of code bound to \"special\" scopes such as member variables and closures in general, so this discussion to me is \"settling the point of precedency between a louse and a flea\"",
        "user": "UEH6T3RJB",
        "ts": "1552652196.342000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5184556fcf3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Antranig Basman",
            "display_name": "Bosmon",
            "team": "T5TCAFTA9",
            "name": "amb26slack",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT"
    },
    {
        "client_msg_id": "34ffcc00-faa6-4766-bfb6-428b90512b75",
        "type": "message",
        "text": "Intriguing take, <@UEH6T3RJB>. I do feel that the typical scopes end up with the problem of copying the same information around without adding any meaning. Could you elaborate on your thoughts and alternative models?",
        "user": "U8A5MS6R1",
        "ts": "1552681509.342300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh Chaturvedi",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT"
    },
    {
        "client_msg_id": "841ec8eb-2584-4dd8-8184-87af69af8b90",
        "type": "message",
        "text": "Java (kinda) and C# have implicit this and also lambdas\/closures. C++ lambdas are clunky but I'm not sure how they aren't \"fully developed\".",
        "user": "UD6EXQVM0",
        "ts": "1552682967.342500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1552683066.000000"
        },
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT"
    },
    {
        "client_msg_id": "ed527eed-5a79-4290-a477-94ddf41f53db",
        "type": "message",
        "text": "Hi there <@U8A5MS6R1> - the basic strategy is in the OAP paper that <@UCUSW7WVD> and I were talking over in the <#C5T9GPWFL|general> thread - lets see if this link works - <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1544229974163900> . Instead of special scopes (objects\/closures) designed to eliminate power of reference (and hence, preventing global oversight of the contents of memory), we code against a single, global, structural scope, but reserve all power of reference to the integration domain. Wherever we write anything resembling traditional code it is expressed as pure functions of its immediate arguments.",
        "user": "UEH6T3RJB",
        "ts": "1552691114.343000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5184556fcf3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Antranig Basman",
            "display_name": "Bosmon",
            "team": "T5TCAFTA9",
            "name": "amb26slack",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1544229974163900",
                "fallback": "[December 7th, 2018 4:46 PM] ak: <@UEH6T3RJB>'s <https:\/\/github.com\/amb26\/papers\/raw\/master\/onward-2016\/onward-2016.pdf> [1] really buries the lede. Here's what I think the primary proposal is, from deep inside section 6, 80% of the way down.\n\nThe basic recommendation:\n\n&gt; ...all design elements be exposed in a structured space of publicly addressible names...\n\nIn more detail:\n\n&gt;  We propose an aggressive program to assimilate the functions of traditional programming languages and their component systems, by stratifying them vertically into two parts:\n&gt;\n&gt;  * On top, an integration domain which encodes not only relations between runtime values, but also the structure of any adaptations expressed in the “virtual class” idiom seen in section 4.3, using the selector structure described in section 6.1.1 to predicate the addresses of these relations and the targets of these adaptations. In order to retain the symmetry implied by our “algebra of differences”, all component structure is expressed within the integration domain, that is, it encodes all classes as well as virtual classes.\n&gt;\n&gt;  * Below the integration domain, then, remains a highly impoverished language dialect that just consists of free functions which express any remnant computation that could not be effectively expressed in the integration domain. The free functions in the impoverished language are addressible through stable names in their own global namespace, and each of them obeys the Law of Demeter strongly, in that they are pure functions of their immediate arguments.\n&gt;\n&gt; ...assimilating the power of reference to the addresses of state into an integration domain which is incapable of computation...\n\n[1] Promoted from <https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1543845454059000?thread_ts=1543729043.042700&amp;cid=C5T9GPWFL>",
                "ts": "1544229974.163900",
                "author_id": "UCUSW7WVD",
                "author_subname": "Kartik Agaram",
                "channel_id": "C5T9GPWFL",
                "channel_name": "general",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "text": "<@UEH6T3RJB>'s <https:\/\/github.com\/amb26\/papers\/raw\/master\/onward-2016\/onward-2016.pdf> [1] really buries the lede. Here's what I think the primary proposal is, from deep inside section 6, 80% of the way down.\n\nThe basic recommendation:\n\n&gt; ...all design elements be exposed in a structured space of publicly addressible names...\n\nIn more detail:\n\n&gt;  We propose an aggressive program to assimilate the functions of traditional programming languages and their component systems, by stratifying them vertically into two parts:\n&gt;\n&gt;  * On top, an integration domain which encodes not only relations between runtime values, but also the structure of any adaptations expressed in the “virtual class” idiom seen in section 4.3, using the selector structure described in section 6.1.1 to predicate the addresses of these relations and the targets of these adaptations. In order to retain the symmetry implied by our “algebra of differences”, all component structure is expressed within the integration domain, that is, it encodes all classes as well as virtual classes.\n&gt;\n&gt;  * Below the integration domain, then, remains a highly impoverished language dialect that just consists of free functions which express any remnant computation that could not be effectively expressed in the integration domain. The free functions in the impoverished language are addressible through stable names in their own global namespace, and each of them obeys the Law of Demeter strongly, in that they are pure functions of their immediate arguments.\n&gt;\n&gt; ...assimilating the power of reference to the addresses of state into an integration domain which is incapable of computation...\n\n[1] Promoted from <https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1543845454059000?thread_ts=1543729043.042700&amp;cid=C5T9GPWFL>",
                "author_name": "Kartik Agaram",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UCUSW7WVD",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2018-09-14\/435669206004_3ed0e6ac6eafe8bcf338_48.jpg",
                "mrkdwn_in": [
                    "text"
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1544229974163900",
                "footer": "Thread in #general"
            }
        ],
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "03A72176-B20A-4048-AA15-32E5F3FA373C",
        "type": "message",
        "text": "Hi Niluka. I'm a volunteer at Dynamicland, maybe I can answer. Josh may know more about the vision for it, but at the moment RealTalk doesn't have any explicit accessibility features that I've seen. Given that it is a tangible environment, and given what a huge area accessibility covers, I think there's a lot of possibilities to explore there.",
        "user": "UGXH0HCSF",
        "ts": "1552692386.350300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3cf031cf9b0e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-13\/575581797875_3cf031cf9b0ec26554a6_72.jpg",
            "first_name": "Carl",
            "real_name": "Carl Tashian",
            "display_name": "carl",
            "team": "T5TCAFTA9",
            "name": "carl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552519997.313200",
        "parent_user_id": "UDPV407CZ"
    },
    {
        "client_msg_id": "0261cbdb-94d2-484c-8d9a-a95973ce4bd6",
        "type": "message",
        "text": "<@UD6EXQVM0> re C++: lack of full closures means workarounds are needed. If you leave the scope you need to capture the identifiers by value (preventing sharing mutable values across several lambdas), or if you do capture local scope identifiers by reference you obviously can't use the lambda outside it. They do cover majority of the useful use cases, but I wouldn't call them fully developed because of this.",
        "user": "UGJ9KAZM3",
        "ts": "1552693718.350600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a9ca5b79893e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-05\/567982344725_a9ca5b79893ede5381e5_72.jpg",
            "first_name": "Iridian",
            "real_name": "Iridian Kiiskinen",
            "display_name": "Iridian",
            "team": "T5TCAFTA9",
            "name": "iridian",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT"
    },
    {
        "client_msg_id": "5e02f151-feff-4f44-9d96-697a734ed210",
        "type": "message",
        "text": "Okay, that's due to C++'s lack of GC so Java\/C# don't have that issue. Note that Java can only capture read-only variables (i.e. it captures by value) while C# has no such limitation (but since captured variables end up on the heap, there must be limitations, as certain data types can't be stored on the heap in C#.)",
        "user": "UD6EXQVM0",
        "ts": "1552694080.350800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1552751824.000000"
        },
        "thread_ts": "1552584175.332300",
        "parent_user_id": "UC6997THT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGJ9KAZM3"
                ],
                "count": 1
            }
        ]
    }
]