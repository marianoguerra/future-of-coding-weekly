[
    {
        "client_msg_id": "5ae507e5-1f18-4008-be50-a2d234fc6b31",
        "type": "message",
        "text": ":slightly_smiling_face: They seem to open sourced a lot of it - <https:\/\/www.thegamecreators.com\/product\/dark-basic-pro-open-source>",
        "user": "UPVBV34EL",
        "ts": "1574238962.224300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "259a1e56ad2e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-28\/811814014976_259a1e56ad2e11fe3d56_72.jpg",
            "first_name": "",
            "real_name": "Shubhadeep Roychowdhury",
            "display_name": "Shubhadeep Roychowdhury",
            "team": "T5TCAFTA9",
            "name": "shubhadeeproychowdhur",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Dark Basic Pro Open Source - TheGameCreators",
                "title_link": "https:\/\/www.thegamecreators.com\/product\/dark-basic-pro-open-source",
                "text": "We specialise in game creation tools for a range of devices such as Windows, iOS, Android. With game making tools like GameGuru, AppGameKit, FPS Creator and Dark Basic Professional you can make all types of games.",
                "fallback": "Dark Basic Pro Open Source - TheGameCreators",
                "from_url": "https:\/\/www.thegamecreators.com\/product\/dark-basic-pro-open-source",
                "service_name": "thegamecreators.com",
                "id": 1,
                "original_url": "https:\/\/www.thegamecreators.com\/product\/dark-basic-pro-open-source"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZTgEA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " They seem to open sourced a lot of it - "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.thegamecreators.com\/product\/dark-basic-pro-open-source"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574195594.223400",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "6f04ccd6-9e91-4dfc-83bb-5807585fb322",
        "type": "message",
        "text": "<@UCUSW7WVD> Having read both of your articles you linked earlier, I think you're onto something… I'm just not sure if I understand it fully yet. Can you try to explain what you mean by tests being \"like a Fourier transform\" — is that your way of highlighting the property that reduces the granularity from individual atoms (all possible program states) to slightly higher-level and neatly organized composites?\n\nI'm also not quite sure how to close the loop from there to the trees vs. semi-lattices argument, and would love to hear more about where you see the connection.",
        "user": "U5STGTB3J",
        "ts": "1574256350.224800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sQ3Be",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " Having read both of your articles you linked earlier, I think you're onto something… I'm just not sure if I understand it fully yet. Can you try to explain what you mean by tests being \"like a Fourier transform\" — is that your way of highlighting the property that reduces the granularity from individual atoms (all possible program states) to slightly higher-level and neatly organized composites?\n\nI'm also not quite sure how to close the loop from there to the trees vs. semi-lattices argument, and would love to hear more about where you see the connection."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "78520075-0876-4a60-b0cc-de569d1530c1",
        "type": "message",
        "text": "There is something to micro services (although I have no experience there and would've never made the connection) or the actor model, or Alan Kay's original idea of object orientation that seem to at least point into an interesting direction. While it could easily be interpreted as just another form of modularization it has a different quality to it, although I'm having a hard time to describe it more precisely. I believe it has something to do with what we see in biological systems, a strong inspiration for Alan Kay when designing object oriented systems, and looking at nature it is a de-facto proven way of organizing much more complex systems reliably. They also clearly exhibit strong hierarchical tree structures, although part of why they're so clearly visible to us is likely that we're hardwired to see them (see paper _The Architecture of Complexity_). They also have many properties of much higher connectivity, which yields their emergent properties. And that I believe is the part that's missing in software. So far we have mostly designed pure trees, and not just used trees as a way to understand a much more connected semi-lattice; perhaps using several different trees to model different aspects of the same system.",
        "user": "U5STGTB3J",
        "ts": "1574256968.225000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8QjMO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is something to micro services (although I have no experience there and would've never made the connection) or the actor model, or Alan Kay's original idea of object orientation that seem to at least point into an interesting direction. While it could easily be interpreted as just another form of modularization it has a different quality to it, although I'm having a hard time to describe it more precisely. I believe it has something to do with what we see in biological systems, a strong inspiration for Alan Kay when designing object oriented systems, and looking at nature it is a de-facto proven way of organizing much more complex systems reliably. They also clearly exhibit strong hierarchical tree structures, although part of why they're so clearly visible to us is likely that we're hardwired to see them (see paper "
                            },
                            {
                                "type": "text",
                                "text": "The Architecture of Complexity",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). They also have many properties of much higher connectivity, which yields their emergent properties. And that I believe is the part that's missing in software. So far we have mostly designed pure trees, and not just used trees as a way to understand a much more connected semi-lattice; perhaps using several different trees to model different aspects of the same system."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "df305ab3-6204-4046-a2d7-8d018cb57731",
        "type": "message",
        "text": "We also usually build software from the bottom up assembling smaller components. Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…\n\nI'm convinced more iterative design and development processes that try to loop around a working product and improve it in small increments are usually more successful because they are at least somewhat leaving the space of purely bottom-up assembly of components behind and come a bit closer to an unfolding process. But I doubt it's anywhere close to what Alexander has in mind.",
        "user": "U5STGTB3J",
        "ts": "1574257634.225200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gKm7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We also usually build software from the bottom up assembling smaller components. Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…\n\nI'm convinced more iterative design and development processes that try to loop around a working product and improve it in small increments are usually more successful because they are at least somewhat leaving the space of purely bottom-up assembly of components behind and come a bit closer to an unfolding process. But I doubt it's anywhere close to what Alexander has in mind."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "271538b4-fdc9-47f4-a909-bcb32fddfa6d",
        "type": "message",
        "text": "omg! I remember that!",
        "user": "UNBPP291C",
        "ts": "1574258924.225400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gcf29e340a09",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Ian Rumac",
            "display_name": "Ian Rumac",
            "team": "T5TCAFTA9",
            "name": "ian.rumac",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HTeR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "omg! I remember that!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574195594.223400",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "0039c79a-b292-4943-92c7-95f12e9fbc4a",
        "type": "message",
        "text": "Back then I just learned QBasic and wanted to make a game, but tbh it didn’t seem “powerful” (I was an idiot), so I ended up doing C++\/OpenGL\/GLUT combo. But DB is so simple and effective now that I look at it, not surprised it’s still alive. The syntax is amazingly readable for what it offers",
        "user": "UNBPP291C",
        "ts": "1574259109.225600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gcf29e340a09",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Ian Rumac",
            "display_name": "Ian Rumac",
            "team": "T5TCAFTA9",
            "name": "ian.rumac",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mMztR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Back then I just learned QBasic and wanted to make a game, but tbh it didn’t seem “powerful” (I was an idiot), so I ended up doing C++\/OpenGL\/GLUT combo. But DB is so simple and effective now that I look at it, not surprised it’s still alive. The syntax is amazingly readable for what it offers"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574195594.223400",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "9786db2a-d260-4715-af44-a159389ba1bd",
        "type": "message",
        "text": "<@U5STGTB3J> \"Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…\" -- Isn't this just Top Down Design? Also known as Stepwise Refinement. <https:\/\/inf.ethz.ch\/personal\/wirth\/Articles\/StepwiseRefinement.pdf> To use this approach practically while coding and writing tests, the lower level modules start out as stubs, which can be refined into partial solutions that can pass some unit tests but don't fully solve the problem (because you haven't figured out how to solve the complete problem yet). This means your dependencies may change as you replace a stub or trial solution of a submodule with a more final implementation that meets all the requirements. It is tempting to let your dependencies determine your design, or to let whatever code is easiest to write determine your design. That's bottom up thinking. To break out of this, I have to alternate between sessions of coding, and sessions of top down thinking where I don't write code, and instead think about how my present code fails to implement my vision and goals.",
        "user": "UJN1TAYEQ",
        "ts": "1574263790.225800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jai",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " \"Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…\" -- Isn't this just Top Down Design? Also known as Stepwise Refinement. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/inf.ethz.ch\/personal\/wirth\/Articles\/StepwiseRefinement.pdf"
                            },
                            {
                                "type": "text",
                                "text": " To use this approach practically while coding and writing tests, the lower level modules start out as stubs, which can be refined into partial solutions that can pass some unit tests but don't fully solve the problem (because you haven't figured out how to solve the complete problem yet). This means your dependencies may change as you replace a stub or trial solution of a submodule with a more final implementation that meets all the requirements. It is tempting to let your dependencies determine your design, or to let whatever code is easiest to write determine your design. That's bottom up thinking. To break out of this, I have to alternate between sessions of coding, and sessions of top down thinking where I don't write code, and instead think about how my present code fails to implement my vision and goals."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "8503ffea-1b48-4bf9-bda6-5d165e5e1994",
        "type": "message",
        "text": "That I completely agree with you. I remember how easy it was when I was doing it using DB. I am really happy to see that they are still alive and releasing new things.",
        "user": "UPVBV34EL",
        "ts": "1574263847.226000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "259a1e56ad2e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-28\/811814014976_259a1e56ad2e11fe3d56_72.jpg",
            "first_name": "",
            "real_name": "Shubhadeep Roychowdhury",
            "display_name": "Shubhadeep Roychowdhury",
            "team": "T5TCAFTA9",
            "name": "shubhadeeproychowdhur",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wPl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That I completely agree with you. I remember how easy it was when I was doing it using DB. I am really happy to see that they are still alive and releasing new things."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574195594.223400",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "f084c8b1-067b-4711-925c-ddf4e1dcc1b0",
        "type": "message",
        "text": "<@UJN1TAYEQ> Ah, that's interesting. My initial reaction is \"of course it's not\", but I haven't read this particular paper of Wirth yet. :wink:\n\nI don't think the top-down nature of Alexander's approach is the important piece, but what he calls _unfolding_ in _The Nature of Order_ — uncovering the structure of the whole while looking at all dimensions at once.\n\nWe certainly know how to develop software in small increments, but that usually means we're still trying to reach a more or less well defined goal and just cut the path towards it into manageable pieces, maybe even allowing slight diversions along the way. The process, however, is still primarily goal-driven.\n\nWhat Alexander describes sounds a lot more like the process of a sculptor carving pieces of material from a block until an image manifests itself, \"discovering the sculpture that's been hiding in the block\", but the sculptor wouldn't be able to tell you in the beginning what they're going to end up with.\n\nI'll give Wirth's paper a read, he usually is worth the time. Thanks for making the connection to it and sharing a link!",
        "user": "U5STGTB3J",
        "ts": "1574264926.226200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1574264960.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "88mVc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Ah, that's interesting. My initial reaction is \"of course it's not\", but I haven't read this particular paper of Wirth yet. "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI don't think the top-down nature of Alexander's approach is the important piece, but what he calls "
                            },
                            {
                                "type": "text",
                                "text": "unfolding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in "
                            },
                            {
                                "type": "text",
                                "text": "The Nature of Order",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — uncovering the structure of the whole while looking at all dimensions at once.\n\nWe certainly know how to develop software in small increments, but that usually means we're still trying to reach a more or less well defined goal and just cut the path towards it into manageable pieces, maybe even allowing slight diversions along the way. The process, however, is still primarily goal-driven.\n\nWhat Alexander describes sounds a lot more like the process of a sculptor carving pieces of material from a block until an image manifests itself, \"discovering the sculpture that's been hiding in the block\", but the sculptor wouldn't be able to tell you in the beginning what they're going to end up with.\n\nI'll give Wirth's paper a read, he usually is worth the time. Thanks for making the connection to it and sharing a link!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "de2772b9-0c03-4e33-bb6f-d61b8226d08d",
        "type": "message",
        "text": "I haven't read the Nature of Order, so I'll look that up. \"Uncovering the structure of the whole while looking at all dimensions at once\" is something I am trying to do in my project. Since I've taken on a project at the limits of my abilities, I can only use an iterative approach, where I build a trial solution, and then iterate as new problems and challenges come to the forefront. Pure top down design (using a single iteration) doesn't work for me until the problem is trivial or well understood (by me). I have to write code to make progress and get a fuller understanding of the problem, but with new knowledge and insight comes the need to refactor the design and even change module boundaries (aka uncovering the structure of the whole). My brain isn't big enough to look at all dimensions at once, so I keep copious design notes to record my past insights and decisions, and work on a few dimensions at a time during each major iteration. Quoting Wirth, programmers \"must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top.\"",
        "user": "UJN1TAYEQ",
        "ts": "1574266211.226500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ige",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven't read the Nature of Order, so I'll look that up. \"Uncovering the structure of the whole while looking at all dimensions at once\" is something I am trying to do in my project. Since I've taken on a project at the limits of my abilities, I can only use an iterative approach, where I build a trial solution, and then iterate as new problems and challenges come to the forefront. Pure top down design (using a single iteration) doesn't work for me until the problem is trivial or well understood (by me). I have to write code to make progress and get a fuller understanding of the problem, but with new knowledge and insight comes the need to refactor the design and even change module boundaries (aka uncovering the structure of the whole). My brain isn't big enough to look at all dimensions at once, so I keep copious design notes to record my past insights and decisions, and work on a few dimensions at a time during each major iteration. Quoting Wirth, programmers \"must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "0ea31c66-eafc-48fa-93e7-ff37928ff144",
        "type": "message",
        "text": "<@UJN1TAYEQ> Well, if you end up reading _The Nature of Order_, please enlighten us. It's four books with over 2000 pages total. You might want to read posts about it instead. I haven't read it either, but read several summaries and posts that focus on the unfolding process (which I believe is in book 2 or 3). I don't have the time right now to find the links, but I'm pretty sure you'll find some of them here somewhere…",
        "user": "U5STGTB3J",
        "ts": "1574266658.226700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Feg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Well, if you end up reading "
                            },
                            {
                                "type": "text",
                                "text": "The Nature of Order",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", please enlighten us. It's four books with over 2000 pages total. You might want to read posts about it instead. I haven't read it either, but read several summaries and posts that focus on the unfolding process (which I believe is in book 2 or 3). I don't have the time right now to find the links, but I'm pretty sure you'll find some of them here somewhere…"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "6013f8fa-3493-4ef5-b56d-2042bcb4c944",
        "type": "message",
        "text": "Well, I guess I've got better at this note taking thing: Here's something to start with:\n\n• <http:\/\/iamronen.com\/quality\/christopher-alexander-the-nature-of-order\/>\n• <http:\/\/www.livingneighborhoods.org\/library\/empirical-findings.pdf>\n• <http:\/\/www.permacultureproject.com\/wp-content\/uploads\/2015\/02\/Alexander-as-phenomenology-of-wholeness-dec-081.pdf>\n• <http:\/\/jomardpublishing.com\/UploadFiles\/Files\/journals\/NDI\/V2N2\/SalingarosN.pdf>\n• <https:\/\/arxiv.org\/pdf\/1303.7303.pdf>\n• <http:\/\/zeta.math.utsa.edu\/~yxk833\/life.carpet.html>\n• <https:\/\/youtu.be\/98LdFA-_zfA>\n\nI wouldn't expect going down this rabbit hole to yield any immediate and practical conclusions for what you're trying to do. You will also see that this is a strong diversion from the analytical world of ours talking a lot about abstract emotional concepts like beauty and our capabilities to \"see\" or feel these properties indirectly.\n\nI'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion, which isn't even closely what I am looking for by studying his work. But who knows, maybe he just reached enlightenment and has finally figured it out…",
        "user": "U5STGTB3J",
        "ts": "1574267368.226900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PHgC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well, I guess I've got better at this note taking thing: Here's something to start with:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/iamronen.com\/quality\/christopher-alexander-the-nature-of-order\/"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/www.livingneighborhoods.org\/library\/empirical-findings.pdf"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/www.permacultureproject.com\/wp-content\/uploads\/2015\/02\/Alexander-as-phenomenology-of-wholeness-dec-081.pdf"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/jomardpublishing.com\/UploadFiles\/Files\/journals\/NDI\/V2N2\/SalingarosN.pdf"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/arxiv.org\/pdf\/1303.7303.pdf"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/zeta.math.utsa.edu\/~yxk833\/life.carpet.html"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/youtu.be\/98LdFA-_zfA"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI wouldn't expect going down this rabbit hole to yield any immediate and practical conclusions for what you're trying to do. You will also see that this is a strong diversion from the analytical world of ours talking a lot about abstract emotional concepts like beauty and our capabilities to \"see\" or feel these properties indirectly.\n\nI'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion, which isn't even closely what I am looking for by studying his work. But who knows, maybe he just reached enlightenment and has finally figured it out…"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "14271dea-5bd6-40f5-ac18-5b599eb887ff",
        "type": "message",
        "text": "Volume 2, The Nature Of Order (Wikipedia synopsis) \"Complex systems do not spring into existence fully formed, but rather through a series of small, incremental changes. The process begins with a simple system and incrementally changes that system such that each change preserves the structure of the previous step. Alexander calls these increments \"structure-preserving transformations,\" and they are essential to his process.\" That's what I was trying to explain earlier.",
        "user": "UJN1TAYEQ",
        "ts": "1574267898.227100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5pw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Volume 2, The Nature Of Order (Wikipedia synopsis) \"Complex systems do not spring into existence fully formed, but rather through a series of small, incremental changes. The process begins with a simple system and incrementally changes that system such that each change preserves the structure of the previous step. Alexander calls these increments \"structure-preserving transformations,\" and they are essential to his process.\" That's what I was trying to explain earlier."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "6a2cc0f0-4166-47e4-8797-90951b4d8702",
        "type": "message",
        "text": "&gt;  Quoting Wirth, programmers \"must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top.\"\n\nI think the underdeveloped skill in our industry that could also potentially be augmented with better tools is our capacity to work with several dimensions (different tree approximations of the same semi-lattice) at once as well as how easy we can jump back and forth between different levels of complexity (the depth within those trees), _up and down the ladder of abstraction_.",
        "user": "U5STGTB3J",
        "ts": "1574267909.227300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qfrFM",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Quoting Wirth, programmers \"must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top.\""
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think the underdeveloped skill in our industry that could also potentially be augmented with better tools is our capacity to work with several dimensions (different tree approximations of the same semi-lattice) at once as well as how easy we can jump back and forth between different levels of complexity (the depth within those trees), "
                            },
                            {
                                "type": "text",
                                "text": "up and down the ladder of abstraction",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "844cac5f-82a7-4dbe-ae44-8a44f498907e",
        "type": "message",
        "text": "&gt; _Wikipedia synopsis_\n\nWell, the rabbit hole just looks like any other from up there… :wink:",
        "user": "U5STGTB3J",
        "ts": "1574268152.227500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wev",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wikipedia synopsis",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nWell, the rabbit hole just looks like any other from up there… "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "5aa2fc70-0578-43a9-861f-7a72647c4468",
        "type": "message",
        "text": "\"I'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion\" -- I think that Alexander's notion of \"life\" is a very desireable property for an FoC system to have, even if the concept is slippery. Donald Norman jumped off the same cliff, I think. He wrote \"The Design of Everyday Things\" -- which has lessons for programming language design -- and later followed up with \"Emotional Design: Why we Love or Hate Everyday Things\" (which I haven't read yet). Norman recanted his previous belief that emotion has no place in design (and revised The Design of Everyday Things to remove this assertion).",
        "user": "UJN1TAYEQ",
        "ts": "1574268471.227700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AFQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"I'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion\" -- I think that Alexander's notion of \"life\" is a very desireable property for an FoC system to have, even if the concept is slippery. Donald Norman jumped off the same cliff, I think. He wrote \"The Design of Everyday Things\" -- which has lessons for programming language design -- and later followed up with \"Emotional Design: Why we Love or Hate Everyday Things\" (which I haven't read yet). Norman recanted his previous belief that emotion has no place in design (and revised The Design of Everyday Things to remove this assertion)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "96c230b4-9e25-4f15-b140-421a32397fc7",
        "type": "message",
        "text": "from my notes, derived from Christopher Alexander:\nQuality Without a Name:\n* Usability - Will the feature make Curv more usable for novices?\n  Is the feature something that developers will enjoy using?\n  Would either group miss it if it was no longer available?\n* Readability - Is the intent of the feature clear and well presented?\n* Configurability - Can the user adapt the feature to his or her needs?\n* Profoundness - Does the feature strike the user as special or unique,\n  but at the same time, insightful and correct?",
        "user": "UJN1TAYEQ",
        "ts": "1574268773.227900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H7tgS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "from my notes, derived from Christopher Alexander:\nQuality Without a Name:\n* Usability - Will the feature make Curv more usable for novices?\n  Is the feature something that developers will enjoy using?\n  Would either group miss it if it was no longer available?\n* Readability - Is the intent of the feature clear and well presented?\n* Configurability - Can the user adapt the feature to his or her needs?\n* Profoundness - Does the feature strike the user as special or unique,\n  but at the same time, insightful and correct?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "5c1eaba0-774c-40c9-81d6-60153de8b237",
        "type": "message",
        "text": "I fully agree that what Alexander calls \"life\" in one period and \"wholeness\" or \"quality without a name\" in others is a very valuable concept and we could certainly use more of it  — I'm just less interested in the spiritual conclusion from his late period which leaves me somewhat unsatisfied.\n\nOn the other hand, understanding the extraordinary amount of several decades of work after his _Pattern Language_, which is what most programmers know him for, shows what a huge amount of ideas is still ripe to be adapted to our industry (and others that involve a lot of design).",
        "user": "U5STGTB3J",
        "ts": "1574269637.228100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fDi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I fully agree that what Alexander calls \"life\" in one period and \"wholeness\" or \"quality without a name\" in others is a very valuable concept and we could certainly use more of it  — I'm just less interested in the spiritual conclusion from his late period which leaves me somewhat unsatisfied.\n\nOn the other hand, understanding the extraordinary amount of several decades of work after his "
                            },
                            {
                                "type": "text",
                                "text": "Pattern Language",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which is what most programmers know him for, shows what a huge amount of ideas is still ripe to be adapted to our industry (and others that involve a lot of design)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "3f6ef1bb-16d8-4d83-8409-daf85014c7a8",
        "type": "message",
        "text": "<@UJN1TAYEQ> I like your list of how you adapted his principles directly to software design. Would love to read more about it. In particular I would find your take on the 15 fundamental properties of wholeness adapted to software design very interesting — not sure if that is already what you based those four on, or if he published that later. It's definitely in Nature of Order and I think that's in book 1.",
        "user": "U5STGTB3J",
        "ts": "1574269935.228300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UYv5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " I like your list of how you adapted his principles directly to software design. Would love to read more about it. In particular I would find your take on the 15 fundamental properties of wholeness adapted to software design very interesting — not sure if that is already what you based those four on, or if he published that later. It's definitely in Nature of Order and I think that's in book 1."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "0cec28f4-7679-49cb-9d62-a5d08ab5e784",
        "type": "message",
        "text": "It sounds like you break it down into features and then apply the principles to those features individually — do I understand that correctly?\nDo you also look at the system as a whole and how those properties are preserved across individual features?",
        "user": "U5STGTB3J",
        "ts": "1574270053.228500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Zax",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It sounds like you break it down into features and then apply the principles to those features individually — do I understand that correctly?\nDo you also look at the system as a whole and how those properties are preserved across individual features?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "eb8b0184-8a9e-43be-95a3-64874f775e84",
        "type": "message",
        "text": "15 properties of wholeness:\n\n• <http:\/\/www.tkwa.com\/fifteen-properties\/>\n• <https:\/\/blog.p2pfoundation.net\/the-fifteen-geometric-properties-of-wholeness\/2014\/03\/01>\n• <https:\/\/www.archdaily.com\/626429\/unified-architectural-theory-chapter-11\/>\n\nForget all the links above and look at these first — I think this is potentially the most useful for us to adapt in software design. Alexander's unfolding process is what he came up with after identifying the 15 properties and doing a ton of empirical research to show that people can generally sense the presence or absence of these properties (in architecture of course). His process then makes sure that you create and preserve the properties.\n\nI'm particularly after _Levels of Scale_ as one of the properties we don't really follow in software where the \"size\" or scale of our abstractions can be completely arbitrary — everything is just a function call (or a method on an object, if you're into that kind of thing), but we have no sense for which level of scale we're operating on, mixing and matching low-level algorithms in high-level structures and vice versa.\n\nAh, that just makes me realize that I really need to stop posting here and get my act together and write some proper blog posts about this.",
        "user": "U5STGTB3J",
        "ts": "1574270610.228700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1574270674.000000"
        },
        "attachments": [
            {
                "title": "The Fifteen Fundamental Properties of Wholeness | The Kubala Washatko Architects, Inc.",
                "title_link": "http:\/\/www.tkwa.com\/fifteen-properties\/",
                "text": "Architecture, planning, and design firm in the Milwaukee WI area, specializing in sustainable design and historic preservation.",
                "fallback": "The Fifteen Fundamental Properties of Wholeness | The Kubala Washatko Architects, Inc.",
                "from_url": "http:\/\/www.tkwa.com\/fifteen-properties\/",
                "service_icon": "http:\/\/www.tkwa.com\/favicon.ico",
                "service_name": "tkwa.com",
                "id": 1,
                "original_url": "http:\/\/www.tkwa.com\/fifteen-properties\/"
            },
            {
                "service_name": "P2P Foundation",
                "title": "The Fifteen Geometric Properties of Wholeness | P2P Foundation",
                "title_link": "https:\/\/blog.p2pfoundation.net\/the-fifteen-geometric-properties-of-wholeness\/2014\/03\/01",
                "text": "From the book The Battle for the Life and Beauty of the Earth: A Struggle Between Two World-Systems (Center for Environmental Structure) by Christopher Alexander. The Fifteen Geometric Properties of Wholeness Here are the fifteen properties, now expressed as fifteen transformations that generate life. These provide the active juice with which a living system provides... Continue reading →",
                "fallback": "P2P Foundation: The Fifteen Geometric Properties of Wholeness | P2P Foundation",
                "image_url": "https:\/\/cdn3-blog.p2pfoundation.net\/wp-content\/uploads\/15-properties-leitner-1024x768.png",
                "ts": 1393700526,
                "from_url": "https:\/\/blog.p2pfoundation.net\/the-fifteen-geometric-properties-of-wholeness\/2014\/03\/01",
                "image_width": 333,
                "image_height": 250,
                "image_bytes": 457226,
                "service_icon": "https:\/\/blog.p2pfoundation.net\/favicon.ico",
                "id": 2,
                "original_url": "https:\/\/blog.p2pfoundation.net\/the-fifteen-geometric-properties-of-wholeness\/2014\/03\/01"
            },
            {
                "service_name": "ArchDaily",
                "title": "Unified Architectural Theory: Chapter 11",
                "title_link": "https:\/\/www.archdaily.com\/626429\/unified-architectural-theory-chapter-11\/",
                "text": "We will be publishing Nikos Salingaros’ book, Unified Architectural Theory, in a series of installments, making it di...",
                "fallback": "ArchDaily: Unified Architectural Theory: Chapter 11",
                "image_url": "https:\/\/images.adsttc.com\/media\/images\/5544\/ca88\/e58e\/ce70\/6c00\/04a0\/medium_jpg\/459067891_399fb7e089_b.jpg?1430571651",
                "image_width": 376,
                "image_height": 250,
                "ts": 1430562623,
                "from_url": "https:\/\/www.archdaily.com\/626429\/unified-architectural-theory-chapter-11\/",
                "image_bytes": 110377,
                "service_icon": "https:\/\/www.archdaily.com\/favicon.ico",
                "id": 3,
                "original_url": "https:\/\/www.archdaily.com\/626429\/unified-architectural-theory-chapter-11\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6bx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "15 properties of wholeness:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "http:\/\/www.tkwa.com\/fifteen-properties\/"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/blog.p2pfoundation.net\/the-fifteen-geometric-properties-of-wholeness\/2014\/03\/01"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.archdaily.com\/626429\/unified-architectural-theory-chapter-11\/"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nForget all the links above and look at these first — I think this is potentially the most useful for us to adapt in software design. Alexander's unfolding process is what he came up with after identifying the 15 properties and doing a ton of empirical research to show that people can generally sense the presence or absence of these properties (in architecture of course). His process then makes sure that you create and preserve the properties.\n\nI'm particularly after "
                            },
                            {
                                "type": "text",
                                "text": "Levels of Scale",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as one of the properties we don't really follow in software where the \"size\" or scale of our abstractions can be completely arbitrary — everything is just a function call (or a method on an object, if you're into that kind of thing), but we have no sense for which level of scale we're operating on, mixing and matching low-level algorithms in high-level structures and vice versa.\n\nAh, that just makes me realize that I really need to stop posting here and get my act together and write some proper blog posts about this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d66e0701-6c0d-4d9a-86e3-b656f29afef7",
        "type": "message",
        "text": "I spend most of my time thinking about individual features, so the QWAN is easiest to apply in that context. I try to periodically look at the system as a whole and I try to see how the QWAN applies to the gestalt, but it's more difficult. I can occasionally see design alternatives where if I modify multiple features at once, then I jump to a different part of the design landscape where the fitness of the design is improved along certain axes.",
        "user": "UJN1TAYEQ",
        "ts": "1574271050.229100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "noLl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I spend most of my time thinking about individual features, so the QWAN is easiest to apply in that context. I try to periodically look at the system as a whole and I try to see how the QWAN applies to the gestalt, but it's more difficult. I can occasionally see design alternatives where if I modify multiple features at once, then I jump to a different part of the design landscape where the fitness of the design is improved along certain axes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "2e4e02ff-c1f4-4685-8ce0-e54548958da9",
        "type": "message",
        "text": "<@UAVCC2X70> had a great thread back about Christopher Alexander back in March, that I got a lot out of, but.. it turns out Slack at some point added a restriction on free plans. It doesn't just keep us from searching for old threads if we don't pay, it also refuses to _show_ them. Which means that what I thought of as a permalink for a thread isn't really all that permanent. That is some *bullshit*. Sign me up to move elsewhere.\n\nAnyway, where was I? Unfolding wholeness. It's a dashed subtle idea, and I never grokked it until March, and now I fear I've forgotten a lot of the nuance yet again. But it's _not_ the same as iterative refinement. One very concrete sentence that particularly stood out for me because it fits my prejudices:\n\n\n> In order for code to be living structure, even the tools used to make the code need to be living structure.",
        "user": "UCUSW7WVD",
        "ts": "1574271329.229300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1574271671.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HqVIu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAVCC2X70"
                            },
                            {
                                "type": "text",
                                "text": " had a great thread back about Christopher Alexander back in March, that I got a lot out of, but.. it turns out Slack at some point added a restriction on free plans. It doesn't just keep us from searching for old threads if we don't pay, it also refuses to "
                            },
                            {
                                "type": "text",
                                "text": "show",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " them. Which means that what I thought of as a permalink for a thread isn't really all that permanent. That is some "
                            },
                            {
                                "type": "text",
                                "text": "bullshit",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Sign me up to move elsewhere.\n\nAnyway, where was I? Unfolding wholeness. It's a dashed subtle idea, and I never grokked it until March, and now I fear I've forgotten a lot of the nuance yet again. But it's "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the same as iterative refinement. One very concrete sentence that particularly stood out for me because it fits my prejudices:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In order for code to be living structure, even the tools used to make the code need to be living structure."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "daaca42e-631e-4422-bc8e-d34a9e39e8c6",
        "type": "message",
        "text": "<@U5STGTB3J>\n\n\n&gt; Can you try to explain what you mean by tests being \"like a Fourier transform..?\n\nIt's very easy to think of a program as the sum of its source code. Subsystems, functions, lines of code. This decomposition is often useful. I think of it as the time domain in my analogy.\n\nAn alternative worldview is to think of a program as a space of inputs that it handles, decomposing into different _regimes_. Within a regime behavior changes smoothly\/continuously. Across a regime boundary behavior changes abruptly\/discontinuously. I find this decomposition more useful, partly because it's not reified anywhere in the source code and so easy to forget. I consider this the frequency domain in my analogy.\n\nOne place where you can see the frequency domain if you squint, and if a program is written in a certain way, is by staring at its tests. Usually you'll have one test per regime, and areas around the test will tend to behave similarly. One could imagine trying to add multiple tests per regime to help nail down the boundary more carefully and so reify the frequency domain in the limit. If we did that, a whole new universe of tools would open up. But it's definitely still an open problem.",
        "user": "UCUSW7WVD",
        "ts": "1574286443.229900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xv0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can you try to explain what you mean by tests being \"like a Fourier transform..?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt's very easy to think of a program as the sum of its source code. Subsystems, functions, lines of code. This decomposition is often useful. I think of it as the time domain in my analogy.\n\nAn alternative worldview is to think of a program as a space of inputs that it handles, decomposing into different "
                            },
                            {
                                "type": "text",
                                "text": "regimes",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Within a regime behavior changes smoothly\/continuously. Across a regime boundary behavior changes abruptly\/discontinuously. I find this decomposition more useful, partly because it's not reified anywhere in the source code and so easy to forget. I consider this the frequency domain in my analogy.\n\nOne place where you can see the frequency domain if you squint, and if a program is written in a certain way, is by staring at its tests. Usually you'll have one test per regime, and areas around the test will tend to behave similarly. One could imagine trying to add multiple tests per regime to help nail down the boundary more carefully and so reify the frequency domain in the limit. If we did that, a whole new universe of tools would open up. But it's definitely still an open problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "E6ED9F04-FA96-4AE0-B38E-BE6BCDA5E750",
        "type": "message",
        "text": "<@UCUSW7WVD> let's see if I grokked this: I think I understand why you picked tests, and it certainly makes this easier to understand than what I’m about to try, but what still puzzles me a little is this: how the program is written is highly subjective, so one domain is based on an arbitrary factor — which makes sense, it's about how we design things after all. But then I would rather try to base the second domain on a different property dependent on the same arbitrary design, but tests are a completely different beast and also completely arbitrarily designed. I know we’re talking about a metaphor here and that's probably not the point, but I would’ve rather picked a property of the program design to stay within the same level of arbitrariness… I don’t know, encoded invariants maybe? Assuming a tester would try to hit all encoded invariants through something like designing the unit tests based on cyclomatic complexity, trying to exercise all possible code paths.\n\nAnyway, the metaphor works and I think I understand that part. Would you agree that the connection to trees and lattices then is this: time domain or decomposition in subsystems (program structure) is one tree approximation, frequency domain or decomposition in regimes (invariants?) is a different tree approximation, but both trees stem from the same program, therefore likely a more complex lattice structure?",
        "user": "U5STGTB3J",
        "ts": "1574288090.245500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "d84898a0-21c5-4fbc-89af-397e0e93e7ba",
        "type": "message",
        "text": "> Would you agree that the connection to trees and lattices then is this:\n\nI hadn't thought about it quite that far :smile: Originally I linked my posts as examples where I point out flaws in one (dominant) approach to tree-based decomposition in software. So I was agreeing with you that we've been doing things wrong for decades. But perhaps my approach is also tree-based, so it isn't completely relevant to this particular thread. As Doug Moen pointed out above (at least in my interpretation of <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1574212062223500?thread_ts=1574069038.213900&cid=C5U3SEW6A>), trees are valuable approximations or abstractions even if they don't capture every last nuance about cities or software.\n\n\n> how the program is written is highly subjective, so [the time] domain is based on an arbitrary factor.. I would rather try to base the second domain on a different [independent] property..\n\nYou're absolutely right! Congratulations, you found a soft spot in my argument I've waited years for someone to point out :heart:\n\nI'd like the way we visualize the domain of a problem to be independent of how our code happens to be written. Unfortunately tests don't do that. They co-evolve with the code. So two programs written by different people for the exact same domain could end up having incompatible tests, if they choose a fundamentally different approach to solving it, and their internal data structures are different, and there are cascading effects throughout tests of different granularities everywhere. In defense of tests:\n\n\n• A lot of times there's one obvious architecture. Compilers have a certain flow of parsing, optimization and code-generation that is fairly timeless.\n• Having a frequency domain to visualize is super helpful even if it's only for your program's architecture. It's better than nothing, until we come up with something better.\n• I've been writing tests for years in a way that tries to mitigate this problem as much as possible. Rather than have tests run sub-components and make assertions on their behavior, I always run the whole program, emitting a _trace_ of domain-specific events (facts deduced by the program), namespaced by different conceptual sub-components. Then different tests make assertions on the state of the trace. Fine-grained unit tests may focus on just traces pertaining to a specific namespace, while coarse-grained integration tests may look at a different namespace. I call this approach white-box testing (<http:\/\/akkartik.name\/post\/tracing-tests>) and it isn't a complete solution to the problem, because it is possible to imagine a program so radically different that it doesn't even share the same coarse sub-components. But for the most part, in practice, white-box tests help because they simplify the problem of compatibility to just having the same namespace names and trace format.",
        "user": "UCUSW7WVD",
        "ts": "1574290209.245700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1574290519.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bEd",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Would you agree that the connection to trees and lattices then is this:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI hadn't thought about it quite that far "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " Originally I linked my posts as examples where I point out flaws in one (dominant) approach to tree-based decomposition in software. So I was agreeing with you that we've been doing things wrong for decades. But perhaps my approach is also tree-based, so it isn't completely relevant to this particular thread. As Doug Moen pointed out above (at least in my interpretation of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1574212062223500?thread_ts=1574069038.213900&cid=C5U3SEW6A"
                            },
                            {
                                "type": "text",
                                "text": "), trees are valuable approximations or abstractions even if they don't capture every last nuance about cities or software.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "how the program is written is highly subjective, so [the time] domain is based on an arbitrary factor.. I would rather try to base the second domain on a different [independent] property.."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYou're absolutely right! Congratulations, you found a soft spot in my argument I've waited years for someone to point out "
                            },
                            {
                                "type": "emoji",
                                "name": "heart"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI'd like the way we visualize the domain of a problem to be independent of how our code happens to be written. Unfortunately tests don't do that. They co-evolve with the code. So two programs written by different people for the exact same domain could end up having incompatible tests, if they choose a fundamentally different approach to solving it, and their internal data structures are different, and there are cascading effects throughout tests of different granularities everywhere. In defense of tests:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A lot of times there's one obvious architecture. Compilers have a certain flow of parsing, optimization and code-generation that is fairly timeless."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Having a frequency domain to visualize is super helpful even if it's only for your program's architecture. It's better than nothing, until we come up with something better."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I've been writing tests for years in a way that tries to mitigate this problem as much as possible. Rather than have tests run sub-components and make assertions on their behavior, I always run the whole program, emitting a "
                                    },
                                    {
                                        "type": "text",
                                        "text": "trace",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " of domain-specific events (facts deduced by the program), namespaced by different conceptual sub-components. Then different tests make assertions on the state of the trace. Fine-grained unit tests may focus on just traces pertaining to a specific namespace, while coarse-grained integration tests may look at a different namespace. I call this approach white-box testing ("
                                    },
                                    {
                                        "type": "link",
                                        "url": "http:\/\/akkartik.name\/post\/tracing-tests"
                                    },
                                    {
                                        "type": "text",
                                        "text": ") and it isn't a complete solution to the problem, because it is possible to imagine a program so radically different that it doesn't even share the same coarse sub-components. But for the most part, in practice, white-box tests help because they simplify the problem of compatibility to just having the same namespace names and trace format."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1574069038.213900",
        "parent_user_id": "U5STGTB3J"
    }
]