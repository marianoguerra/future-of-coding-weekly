[
    {
        "client_msg_id": "e9948340-bb26-4d58-bbd2-8facc35e3fd4",
        "type": "message",
        "text": "<@UAL7940NM> I changed the last example like you suggested. Now it starts with the code example before adding the “base” parameter to the “digits” function. Thanks!",
        "user": "U79HM6726",
        "ts": "1560079731.030400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4ac39488e9c",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/24ac39488e9c4f2833d087a1343707dc.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Yair Chuchem",
            "display_name": "yairchu",
            "team": "T5TCAFTA9",
            "name": "yairchu",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559859894.009500",
        "parent_user_id": "U79HM6726"
    },
    {
        "client_msg_id": "8f4ba22f-0b49-4609-a450-891f937e8968",
        "type": "message",
        "text": "I’ll try to tl;dr what caught my ear and feel free to correct me :slightly_smiling_face:\n\ntldr: the Lobster language has a static duck typing system. Similar to C++ templates, code gets specialised and type-checked when it is used. Instead of needing type-classes, the same function gets different specialisations with differing types and each one is checked individually. When there’s a type-error, the compiler also provides you with a stack-trace to it, but in compile time.\n\nThat’s an interesting middle ground between dynamic languages and conventional static languages!\n\nI guess that in my comparison table\n<https:\/\/htmlpreview.github.io\/?https:\/\/github.com\/lamdu\/presentations\/blob\/master\/videos\/friendly-static-types\/comparison.html>\nit will be somewhat similar to inferred static typing but better because it will allow you to run code when parts of it have errors and you could also provide actual example values when there are type errors.",
        "user": "U79HM6726",
        "ts": "1560083144.030600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4ac39488e9c",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/24ac39488e9c4f2833d087a1343707dc.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Yair Chuchem",
            "display_name": "yairchu",
            "team": "T5TCAFTA9",
            "name": "yairchu",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559892828.012900",
        "parent_user_id": "UHDQ62M4P"
    },
    {
        "client_msg_id": "037eb48d-c74a-409c-9e5e-f6f3d6194784",
        "type": "message",
        "text": "Yair: yup, you are pretty much spot on. I would put it close to Static Inferred but quite a bit close to Dynamic in reality. The amount of cases that Lobster can deal with that Static Inferred will error on is significant. The compile time stack traces do not give values though, they still give types. But they tend to be more readable than C++ errors, and less cryptic than Haskell :slightly_smiling_face:",
        "user": "UHDQ62M4P",
        "ts": "1560109170.031000",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559892828.012900",
        "parent_user_id": "UHDQ62M4P"
    },
    {
        "client_msg_id": "1f91b335-bcf3-481d-8f63-5a2c59d29e21",
        "type": "message",
        "text": "To me regexp implies operating on text (I understand it doesn't have to, but from a pragmatic standpoint that's what most people will assume), while pattern relates more to pattern matching than a bitmap pattern. So I'd vote pattern.  Especially considering novel syntax that is not modeled after an existing regular expression syntax",
        "user": "UBSMEUXAA",
        "ts": "1560112640.031400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559978864.020800",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "159a00cf-3b42-427e-99df-36a3a6a2b57d",
        "type": "message",
        "text": "Is the behavior similar to a pointer or a reference otherwise? If g.players has not been defined a pointer implies I'd get a runtime error (or maybe compile time in Rust) but if all paths are valid I think path might be better",
        "user": "UBSMEUXAA",
        "ts": "1560112942.031600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559978791.019500",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "1f09ac43-34c1-41c5-b77f-b861f91a3b0b",
        "type": "message",
        "text": "Interesting question. Debugging would be a lot easier if the debugger would show the path instead of the pointer.",
        "user": "UHQSZ9KGQ",
        "ts": "1560146767.032200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90d161f80c47",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-30\/650326290964_90d161f80c474ff88805_72.jpg",
            "first_name": "",
            "real_name": "Jules Jacobs",
            "display_name": "Jules Jacobs",
            "team": "T5TCAFTA9",
            "name": "julesjacobs",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1559978791.019500",
        "parent_user_id": "UEQ6M68H0"
    }
]