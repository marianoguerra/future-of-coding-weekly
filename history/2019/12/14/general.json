[
    {
        "client_msg_id": "13e550de-686b-45c9-93d5-b4a15a69ac8a",
        "type": "message",
        "text": "As I mentioned before, the definition of \"code\" keeps changing. In 1956, \"code\" was machine code, and Fortran programs were not code, they were a way of programming without writing code. Today, the Scratch programming language is considered \"no code\", despite it being a very thin layer of graphical syntax on top of a conventional imperative programming language. For programming language research, I need a definition of \"code\" that is general and timeless.",
        "user": "UJN1TAYEQ",
        "ts": "1576334251.010800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0d9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As I mentioned before, the definition of \"code\" keeps changing. In 1956, \"code\" was machine code, and Fortran programs were not code, they were a way of programming without writing code. Today, the Scratch programming language is considered \"no code\", despite it being a very thin layer of graphical syntax on top of a conventional imperative programming language. For programming language research, I need a definition of \"code\" that is general and timeless."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1573264632.251900",
        "parent_user_id": "UAVCC2X70",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2a419421-f4ba-498c-b906-fa90939d616a",
        "type": "message",
        "text": "I guess we all know the proper engineering definition of analog and digital. The confusion comes from people incorrectly using \"analog\" as a synonym for \"primitive\" or \"antiquated\".\n&gt; Early computing devices were “analog”\nWrong. The abacus is digital. (Although the slide rule is analog.)\n&gt; for example, Charles Babbage’s difference engine\nWrong. The difference engine is digital, as were later mechanical and electro-mechanical calculators. The Difference Engine #1 was designed to operate on 20 digit decimal numbers, and you can't get that level of accuracy from an analog computer.\n&gt; Likewise, the telegraph was analog.\nWrong again. The telegraph quantizes line voltages into two levels, on and off, and it quantizes the duration of square wave impulses into two durations, \"dit\" and \"dah\" (short and long).\n\nThe Analytical Engine (1837) was the first programmable, general purpose, Turing-complete computer. It was digital, and I think it had to be digital. I've never heard of a general purpose, programmable analog computer, only special purpose machines for performing specific calculations. I don't think analog \"computers\" are in the same category, so I don't think that the analog\/digital axis is really relevant to the rest of the post.",
        "user": "UJN1TAYEQ",
        "ts": "1576353872.011100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1576356413.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SOfsT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess we all know the proper engineering definition of analog and digital. The confusion comes from people incorrectly using \"analog\" as a synonym for \"primitive\" or \"antiquated\".\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Early computing devices were “analog”"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wrong. The abacus is digital. (Although the slide rule is analog.)\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "for example, Charles Babbage’s difference engine"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wrong. The difference engine is digital, as were later mechanical and electro-mechanical calculators. The Difference Engine #1 was designed to operate on 20 digit decimal numbers, and you can't get that level of accuracy from an analog computer.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Likewise, the telegraph was analog."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wrong again. The telegraph quantizes line voltages into two levels, on and off, and it quantizes the duration of square wave impulses into two durations, \"dit\" and \"dah\" (short and long).\n\nThe Analytical Engine (1837) was the first programmable, general purpose, Turing-complete computer. It was digital, and I think it had to be digital. I've never heard of a general purpose, programmable analog computer, only special purpose machines for performing specific calculations. I don't think analog \"computers\" are in the same category, so I don't think that the analog\/digital axis is really relevant to the rest of the post."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576262057.005600",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "4ca8629f-3993-4689-8ff1-b5a0db648f6d",
        "type": "message",
        "text": "PROLOG to my knowledge is not a temporal solver, but is decision tree explorer, where you can ask hypotheses and it will do a backtracking search through this decision tree to find a winning match. It could also follow predicate chains; so you could say a dog is a mammal, all mammals nurse their young, and it could make the conclusion that dogs nurse their young. But as the 5th generation project found out to their dismay it is not a good general purpose language, and if you ask someone to make a payroll system in PROLOG they are in deep s**t. Even in areas where PROLOG would be expected to be great, like making a chess program, the winning chess programs use heuristics, and very careful pruning algorithms which PROLOG did not facilitate. I think PROLOG reflects the intrinsic problem of making something too closely tied to logic, and not enough practical aspects. Coq, Agda, and other languages exist which can prove programs correct, but making something useful in those languages is quite difficult. This has created a rather serious gulf between academic logicians and those striving to make a useful tool.",
        "user": "UEQ6M68H0",
        "ts": "1576383926.011700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U58r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "PROLOG to my knowledge is not a temporal solver, but is decision tree explorer, where you can ask hypotheses and it will do a backtracking search through this decision tree to find a winning match. It could also follow predicate chains; so you could say a dog is a mammal, all mammals nurse their young, and it could make the conclusion that dogs nurse their young. But as the 5th generation project found out to their dismay it is not a good general purpose language, and if you ask someone to make a payroll system in PROLOG they are in deep s**t. Even in areas where PROLOG would be expected to be great, like making a chess program, the winning chess programs use heuristics, and very careful pruning algorithms which PROLOG did not facilitate. I think PROLOG reflects the intrinsic problem of making something too closely tied to logic, and not enough practical aspects. Coq, Agda, and other languages exist which can prove programs correct, but making something useful in those languages is quite difficult. This has created a rather serious gulf between academic logicians and those striving to make a useful tool."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575999812.302200",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UL3CJ7YKC"
                ],
                "count": 2
            }
        ]
    }
]