[
    {
        "client_msg_id": "edfdfab6-8e7f-4572-b909-85da66f57fe4",
        "type": "message",
        "text": "Took a chance to read the post at last.  Hot take...\n\nNow that we've seen data passing through functions, what would the opposite – functions passing over data – look like?\n\nAbout those object balls running along channels, a fun thing with arrows <https:\/\/en.wikibooks.org\/wiki\/Haskell\/Understanding_arrows>, PROPs <https:\/\/golem.ph.utexas.edu\/category\/2018\/04\/props_in_network_theory.html> and Propagators <https:\/\/groups.csail.mit.edu\/mac\/users\/gjs\/propagators\/> is that you can draw a path while parametrizing over what passes through it, like reusibng the same plumbing with different fluids.\n\nHaving channel length matter does give you a locality and smoothness that keeps paradox at bay.  It's more than obvious that you, like everyone else who has tried, have been baffled by the order of operations in Max\/MSP: looks like a dataflow network, feels like a dataflow network, absolutely is not a dataflow network.  Likewise the fact that Max\/MSP nodes are objects with methods and state rather than pure functions confuses everyone sometimes.\n\nAbout time travel.  Your five types mainly revolve around the interaction between user time (which of course simply goes forward at human scale), edit action time (undo\/redo), and simulation time (the balls moving around).\n\nOne solution to your \"problem\" with remembering the channel that a ball used to enter a function is to \"just\" remember which channel the ball came in on.  From learning about Propagators, I took away the notion of lifting a datum so as to store provenance metadata with it.\n\nAnother silly solution is to embrace time symmetry.  Suppose a function with one entrance and two exits has the quality that when a ball enters, two exit.  Time reversed, it now has two entrances and one exit.  Balls entering have to do so at the same time.  So if you make an edit that adds a ball on one channel, you implicitly also add one in the other.  Fixpoint fun follows.",
        "user": "UA14TGLTC",
        "ts": "1567341978.009200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Revised Report on the Propagator Model",
                "title_link": "https:\/\/groups.csail.mit.edu\/mac\/users\/gjs\/propagators\/",
                "text": "Revised Report on the Propagator Model",
                "fallback": "Revised Report on the Propagator Model",
                "from_url": "https:\/\/groups.csail.mit.edu\/mac\/users\/gjs\/propagators\/",
                "service_icon": "https:\/\/groups.csail.mit.edu\/favicon.ico",
                "service_name": "groups.csail.mit.edu",
                "id": 1,
                "original_url": "https:\/\/groups.csail.mit.edu\/mac\/users\/gjs\/propagators\/"
            }
        ],
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "2FF1703C-1118-4E0D-8D9C-233498D0CF87",
        "type": "message",
        "text": "&gt;&gt;&gt; The Propagator Programming Model is built on the idea that the basic computational elements are autonomous machines interconnected by shared cells through which they communicate. Each machine continuously examines the cells it is interested in, and adds information to some based on computations it can make from information from the others. Cells accumulate information from the propagators that produce that information. The key idea here is additivity. New ways to make contributions can be added just by adding new propagators; if an approach to a problem doesn't turn out to work well, it can be identified by its premises and ignored, dynamically and without disruption.",
        "user": "UHWC9PXBL",
        "ts": "1567349086.009800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "65358C64-9002-4A4B-9C1D-084938B5F667",
        "type": "message",
        "text": "paging alan kay lol",
        "user": "UHWC9PXBL",
        "ts": "1567349127.010300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "5EA74276-F2EB-417F-8078-C921FF2628C5",
        "type": "message",
        "text": "this is insanely cool though thank you for sharing",
        "user": "UHWC9PXBL",
        "ts": "1567349140.010800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Garth Goldwater",
            "display_name": "Garth Goldwater",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "f8ca7bf1-c4cb-4933-a18a-ea415795f8df",
        "type": "message",
        "text": "<@UA14TGLTC> Great feedback, thanks!\n\n&gt; Now that we've seen data passing through functions, what would the opposite – functions passing over data – look like?\n\nA previous concept for function application was that there'd be a function and data geometrically intersecting — it didn't matter if the data was conveyed to the function or vice versa. I've moved away from _intersection_ to experiment with more directed ways of treating geometry as functions, data, or both, to see what feels good. Too soo to say, since it'll depend on other things (like how I end up handling collections, for instance).\n\n&gt; About those object balls running along channels, a fun thing with arrows <https:\/\/en.wikibooks.org\/wiki\/Haskell\/Understanding_arrows>, PROPs <https:\/\/golem.ph.utexas.edu\/category\/2018\/04\/props_in_network_theory.html> and Propagators <https:\/\/groups.csail.mit.edu\/mac\/users\/gjs\/propagators\/> is that you can draw a path while parametrizing over what passes through it, like reusibng the same plumbing with different fluids.\n\nMy understanding of category theory is fairly poor, so while I'm familiar with arrows, the discussion of PROPs was pretty devoid of footholds for me. That said, the mention of bond graphs was helpful. I evaluated bond graphs for a Hest precursor about 8 years ago, but found them to be a frustratingly lossy generalization, useful for only very coarse analytics and not useful (to me) for the design of systems.\n\nPropagators seem interesting. I've only read the abstract so far, but it sounds vaguely like CES meets Forth. Too late tonight for me to read it, but I'm excited to get to it soon.\n\n&gt; It's more than obvious that you, like everyone else who has tried, have been baffled by the order of operations in Max\/MSP: looks like a dataflow network, feels like a dataflow network, absolutely is not a dataflow network.  Likewise the fact that Max\/MSP nodes are objects with methods and state rather than pure functions confuses everyone sometimes.\n\nI have to play computer in my head when looking at Max, and that's the ultimate failing of pretty much every \"visual\" language. They could fix that entirely by improving the GUI, no changes to the model are needed.\n\n&gt; About time travel.  Your five types mainly revolve around the interaction between user time (which of course simply goes forward at human scale), edit action time (undo\/redo), and simulation time (the balls moving around).\n\nThe latter two are arguably one and the same. It might be useful to attempt to distinguish them (I currently am), but they mostly overlap\/intersect.\n\n&gt; One solution to your \"problem\" with remembering the channel that a ball used to enter a function is to \"just\" remember which channel the ball came in on.\n\nOne prototype ago, that's how it worked. Since then, I've kept coming back to the idea that.. I don't want to have to force decisions like this on my future self. So I'm looking for a way to let me.. build the runtime so that you _can_ have points remember which edge they came in on, but you can also record history as an external thing, or not record any history.. and select which kind of time travel objects participate in on the fly. So I think the challenge is.. determining what underlying data representation(s) will let me do this stuff a la carte with really good performance characteristics _in fuckin javascript_ (because this stuff _has to_ run on the web, even though I want the editor tool to be native).\n\n&gt; Suppose a function with one entrance and two exits has the quality that when a ball enters, two exit.  Time reversed, it now has two entrances and one exit.  Balls entering have to do so at the same time.  So if you make an edit that adds a ball on one channel, you implicitly also add one in the other.\n\nThat's how the current prototype works, but I've found symmetry doesn't solve any problems I'm currently facing, so it's just over-constraining.",
        "user": "UC2A2ARPT",
        "ts": "1567403785.011100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1567404108.000000"
        },
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "2c287a8b-06ce-4a30-9ba7-8d65a08ff463",
        "type": "message",
        "text": "How do you handle functions that take two arguments?  The first ball just waits for a second to arrive?  Just keep the term \"PROPs\" in your back pocket, expect to hear it again in a few years.  The time symmetry idea is silly and not likely suitable.  The only really important thing to keep in mind, I think, is that from some perspective all the state\/change\/movement should be visible.  \"Visual\" languages generally do fall down from hiding details in ways that lead to behavior being as mysterious and inscrutable as typical software systems.  (Likewise, hidden state in the physical world is disorienting.  Thinking of pluming problems or anything with wiring, weather, and geckos...)",
        "user": "UA14TGLTC",
        "ts": "1567405944.011900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566801692.212900",
        "parent_user_id": "UC2A2ARPT"
    }
]